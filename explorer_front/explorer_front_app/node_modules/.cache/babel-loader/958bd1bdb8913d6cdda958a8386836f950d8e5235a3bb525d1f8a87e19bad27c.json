{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\nvar Plots = require('../../plots/plots');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Titles = require('../../components/titles');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar axAttrs = require('./layout_attributes');\nvar cleanTicks = require('./clean_ticks');\nvar constants = require('../../constants/numerical');\nvar ONEMAXYEAR = constants.ONEMAXYEAR;\nvar ONEAVGYEAR = constants.ONEAVGYEAR;\nvar ONEMINYEAR = constants.ONEMINYEAR;\nvar ONEMAXQUARTER = constants.ONEMAXQUARTER;\nvar ONEAVGQUARTER = constants.ONEAVGQUARTER;\nvar ONEMINQUARTER = constants.ONEMINQUARTER;\nvar ONEMAXMONTH = constants.ONEMAXMONTH;\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\nvar ONEMINMONTH = constants.ONEMINMONTH;\nvar ONEWEEK = constants.ONEWEEK;\nvar ONEDAY = constants.ONEDAY;\nvar HALFDAY = ONEDAY / 2;\nvar ONEHOUR = constants.ONEHOUR;\nvar ONEMIN = constants.ONEMIN;\nvar ONESEC = constants.ONESEC;\nvar MINUS_SIGN = constants.MINUS_SIGN;\nvar BADNUM = constants.BADNUM;\nvar ZERO_PATH = {\n  K: 'zeroline'\n};\nvar GRID_PATH = {\n  K: 'gridline',\n  L: 'path'\n};\nvar MINORGRID_PATH = {\n  K: 'minor-gridline',\n  L: 'path'\n};\nvar TICK_PATH = {\n  K: 'tick',\n  L: 'path'\n};\nvar TICK_TEXT = {\n  K: 'tick',\n  L: 'text'\n};\nvar MARGIN_MAPPING = {\n  width: ['x', 'r', 'l', 'xl', 'xr'],\n  height: ['y', 't', 'b', 'yt', 'yb'],\n  right: ['r', 'xr'],\n  left: ['l', 'xl'],\n  top: ['t', 'yt'],\n  bottom: ['b', 'yb']\n};\nvar alignmentConstants = require('../../constants/alignment');\nvar MID_SHIFT = alignmentConstants.MID_SHIFT;\nvar CAP_SHIFT = alignmentConstants.CAP_SHIFT;\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar OPPOSITE_SIDE = alignmentConstants.OPPOSITE_SIDE;\nvar TEXTPAD = 3;\nvar axes = module.exports = {};\naxes.setConvert = require('./set_convert');\nvar autoType = require('./axis_autotype');\nvar axisIds = require('./axis_ids');\nvar idSort = axisIds.idSort;\nvar isLinked = axisIds.isLinked;\n\n// tight coupling to chart studio\naxes.id2name = axisIds.id2name;\naxes.name2id = axisIds.name2id;\naxes.cleanId = axisIds.cleanId;\naxes.list = axisIds.list;\naxes.listIds = axisIds.listIds;\naxes.getFromId = axisIds.getFromId;\naxes.getFromTrace = axisIds.getFromTrace;\nvar autorange = require('./autorange');\naxes.getAutoRange = autorange.getAutoRange;\naxes.findExtremes = autorange.findExtremes;\nvar epsilon = 0.0001;\nfunction expandRange(range) {\n  var delta = (range[1] - range[0]) * epsilon;\n  return [range[0] - delta, range[1] + delta];\n}\n\n/*\n * find the list of possible axes to reference with an xref or yref attribute\n * and coerce it to that list\n *\n * attr: the attribute we're generating a reference for. Should end in 'x' or 'y'\n *     but can be prefixed, like 'ax' for annotation's arrow x\n * dflt: the default to coerce to, or blank to use the first axis (falling back on\n *     extraOption if there is no axis)\n * extraOption: aside from existing axes with this letter, what non-axis value is allowed?\n *     Only required if it's different from `dflt`\n */\naxes.coerceRef = function (containerIn, containerOut, gd, attr, dflt, extraOption) {\n  var axLetter = attr.charAt(attr.length - 1);\n  var axlist = gd._fullLayout._subplots[axLetter + 'axis'];\n  var refAttr = attr + 'ref';\n  var attrDef = {};\n  if (!dflt) dflt = axlist[0] || (typeof extraOption === 'string' ? extraOption : extraOption[0]);\n  if (!extraOption) extraOption = dflt;\n  axlist = axlist.concat(axlist.map(function (x) {\n    return x + ' domain';\n  }));\n\n  // data-ref annotations are not supported in gl2d yet\n\n  attrDef[refAttr] = {\n    valType: 'enumerated',\n    values: axlist.concat(extraOption ? typeof extraOption === 'string' ? [extraOption] : extraOption : []),\n    dflt: dflt\n  };\n\n  // xref, yref\n  return Lib.coerce(containerIn, containerOut, attrDef, refAttr);\n};\n\n/*\n * Get the type of an axis reference. This can be 'range', 'domain', or 'paper'.\n * This assumes ar is a valid axis reference and returns 'range' if it doesn't\n * match the patterns for 'paper' or 'domain'.\n *\n * ar: the axis reference string\n *\n */\naxes.getRefType = function (ar) {\n  if (ar === undefined) {\n    return ar;\n  }\n  if (ar === 'paper') {\n    return 'paper';\n  }\n  if (ar === 'pixel') {\n    return 'pixel';\n  }\n  if (/( domain)$/.test(ar)) {\n    return 'domain';\n  } else {\n    return 'range';\n  }\n};\n\n/*\n * coerce position attributes (range-type) that can be either on axes or absolute\n * (paper or pixel) referenced. The biggest complication here is that we don't know\n * before looking at the axis whether the value must be a number or not (it may be\n * a date string), so we can't use the regular valType='number' machinery\n *\n * axRef (string): the axis this position is referenced to, or:\n *     paper: fraction of the plot area\n *     pixel: pixels relative to some starting position\n * attr (string): the attribute in containerOut we are coercing\n * dflt (number): the default position, as a fraction or pixels. If the attribute\n *     is to be axis-referenced, this will be converted to an axis data value\n *\n * Also cleans the values, since the attribute definition itself has to say\n * valType: 'any' to handle date axes. This allows us to accept:\n * - for category axes: category names, and convert them here into serial numbers.\n *   Note that this will NOT work for axis range endpoints, because we don't know\n *   the category list yet (it's set by ax.makeCalcdata during calc)\n *   but it works for component (note, shape, images) positions.\n * - for date axes: JS Dates or milliseconds, and convert to date strings\n * - for other types: coerce them to numbers\n */\naxes.coercePosition = function (containerOut, gd, coerce, axRef, attr, dflt) {\n  var cleanPos, pos;\n  var axRefType = axes.getRefType(axRef);\n  if (axRefType !== 'range') {\n    cleanPos = Lib.ensureNumber;\n    pos = coerce(attr, dflt);\n  } else {\n    var ax = axes.getFromId(gd, axRef);\n    dflt = ax.fraction2r(dflt);\n    pos = coerce(attr, dflt);\n    cleanPos = ax.cleanPos;\n  }\n  containerOut[attr] = cleanPos(pos);\n};\naxes.cleanPosition = function (pos, gd, axRef) {\n  var cleanPos = axRef === 'paper' || axRef === 'pixel' ? Lib.ensureNumber : axes.getFromId(gd, axRef).cleanPos;\n  return cleanPos(pos);\n};\naxes.redrawComponents = function (gd, axIds) {\n  axIds = axIds ? axIds : axes.listIds(gd);\n  var fullLayout = gd._fullLayout;\n  function _redrawOneComp(moduleName, methodName, stashName, shortCircuit) {\n    var method = Registry.getComponentMethod(moduleName, methodName);\n    var stash = {};\n    for (var i = 0; i < axIds.length; i++) {\n      var ax = fullLayout[axes.id2name(axIds[i])];\n      var indices = ax[stashName];\n      for (var j = 0; j < indices.length; j++) {\n        var ind = indices[j];\n        if (!stash[ind]) {\n          method(gd, ind);\n          stash[ind] = 1;\n          // once is enough for images (which doesn't use the `i` arg anyway)\n          if (shortCircuit) return;\n        }\n      }\n    }\n  }\n\n  // annotations and shapes 'draw' method is slow,\n  // use the finer-grained 'drawOne' method instead\n  _redrawOneComp('annotations', 'drawOne', '_annIndices');\n  _redrawOneComp('shapes', 'drawOne', '_shapeIndices');\n  _redrawOneComp('images', 'draw', '_imgIndices', true);\n  _redrawOneComp('selections', 'drawOne', '_selectionIndices');\n};\nvar getDataConversions = axes.getDataConversions = function (gd, trace, target, targetArray) {\n  var ax;\n\n  // If target points to an axis, use the type we already have for that\n  // axis to find the data type. Otherwise use the values to autotype.\n  var d2cTarget = target === 'x' || target === 'y' || target === 'z' ? target : targetArray;\n\n  // In the case of an array target, make a mock data array\n  // and call supplyDefaults to the data type and\n  // setup the data-to-calc method.\n  if (Lib.isArrayOrTypedArray(d2cTarget)) {\n    ax = {\n      type: autoType(targetArray, undefined, {\n        autotypenumbers: gd._fullLayout.autotypenumbers\n      }),\n      _categories: []\n    };\n    axes.setConvert(ax);\n\n    // build up ax._categories (usually done during ax.makeCalcdata()\n    if (ax.type === 'category') {\n      for (var i = 0; i < targetArray.length; i++) {\n        ax.d2c(targetArray[i]);\n      }\n    }\n    // TODO what to do for transforms?\n  } else {\n    ax = axes.getFromTrace(gd, trace, d2cTarget);\n  }\n\n  // if 'target' has corresponding axis\n  // -> use setConvert method\n  if (ax) return {\n    d2c: ax.d2c,\n    c2d: ax.c2d\n  };\n\n  // special case for 'ids'\n  // -> cast to String\n  if (d2cTarget === 'ids') return {\n    d2c: toString,\n    c2d: toString\n  };\n\n  // otherwise (e.g. numeric-array of 'marker.color' or 'marker.size')\n  // -> cast to Number\n\n  return {\n    d2c: toNum,\n    c2d: toNum\n  };\n};\nfunction toNum(v) {\n  return +v;\n}\nfunction toString(v) {\n  return String(v);\n}\naxes.getDataToCoordFunc = function (gd, trace, target, targetArray) {\n  return getDataConversions(gd, trace, target, targetArray).d2c;\n};\n\n// get counteraxis letter for this axis (name or id)\n// this can also be used as the id for default counter axis\naxes.counterLetter = function (id) {\n  var axLetter = id.charAt(0);\n  if (axLetter === 'x') return 'y';\n  if (axLetter === 'y') return 'x';\n};\n\n// incorporate a new minimum difference and first tick into\n// forced\n// note that _forceTick0 is linearized, so needs to be turned into\n// a range value for setting tick0\naxes.minDtick = function (ax, newDiff, newFirst, allow) {\n  // doesn't make sense to do forced min dTick on log or category axes,\n  // and the plot itself may decide to cancel (ie non-grouped bars)\n  if (['log', 'category', 'multicategory'].indexOf(ax.type) !== -1 || !allow) {\n    ax._minDtick = 0;\n  } else if (ax._minDtick === undefined) {\n    // undefined means there's nothing there yet\n\n    ax._minDtick = newDiff;\n    ax._forceTick0 = newFirst;\n  } else if (ax._minDtick) {\n    if ((ax._minDtick / newDiff + 1e-6) % 1 < 2e-6 &&\n    // existing minDtick is an integer multiple of newDiff\n    // (within rounding err)\n    // and forceTick0 can be shifted to newFirst\n\n    ((newFirst - ax._forceTick0) / newDiff % 1 + 1.000001) % 1 < 2e-6) {\n      ax._minDtick = newDiff;\n      ax._forceTick0 = newFirst;\n    } else if ((newDiff / ax._minDtick + 1e-6) % 1 > 2e-6 ||\n    // if the converse is true (newDiff is a multiple of minDtick and\n    // newFirst can be shifted to forceTick0) then do nothing - same\n    // forcing stands. Otherwise, cancel forced minimum\n\n    ((newFirst - ax._forceTick0) / ax._minDtick % 1 + 1.000001) % 1 > 2e-6) {\n      ax._minDtick = 0;\n    }\n  }\n};\n\n// save a copy of the initial axis ranges in fullLayout\n// use them in mode bar and dblclick events\naxes.saveRangeInitial = function (gd, overwrite) {\n  var axList = axes.list(gd, '', true);\n  var hasOneAxisChanged = false;\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    var isNew = ax._rangeInitial0 === undefined && ax._rangeInitial1 === undefined;\n    var hasChanged = isNew || ax.range[0] !== ax._rangeInitial0 || ax.range[1] !== ax._rangeInitial1;\n    var autorange = ax.autorange;\n    if (isNew && autorange !== true || overwrite && hasChanged) {\n      ax._rangeInitial0 = autorange === 'min' || autorange === 'max reversed' ? undefined : ax.range[0];\n      ax._rangeInitial1 = autorange === 'max' || autorange === 'min reversed' ? undefined : ax.range[1];\n      ax._autorangeInitial = autorange;\n      hasOneAxisChanged = true;\n    }\n  }\n  return hasOneAxisChanged;\n};\n\n// save a copy of the initial spike visibility\naxes.saveShowSpikeInitial = function (gd, overwrite) {\n  var axList = axes.list(gd, '', true);\n  var hasOneAxisChanged = false;\n  var allSpikesEnabled = 'on';\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    var isNew = ax._showSpikeInitial === undefined;\n    var hasChanged = isNew || !(ax.showspikes === ax._showspikes);\n    if (isNew || overwrite && hasChanged) {\n      ax._showSpikeInitial = ax.showspikes;\n      hasOneAxisChanged = true;\n    }\n    if (allSpikesEnabled === 'on' && !ax.showspikes) {\n      allSpikesEnabled = 'off';\n    }\n  }\n  gd._fullLayout._cartesianSpikesEnabled = allSpikesEnabled;\n  return hasOneAxisChanged;\n};\naxes.autoBin = function (data, ax, nbins, is2d, calendar, size) {\n  var dataMin = Lib.aggNums(Math.min, null, data);\n  var dataMax = Lib.aggNums(Math.max, null, data);\n  if (ax.type === 'category' || ax.type === 'multicategory') {\n    return {\n      start: dataMin - 0.5,\n      end: dataMax + 0.5,\n      size: Math.max(1, Math.round(size) || 1),\n      _dataSpan: dataMax - dataMin\n    };\n  }\n  if (!calendar) calendar = ax.calendar;\n\n  // piggyback off tick code to make \"nice\" bin sizes and edges\n  var dummyAx;\n  if (ax.type === 'log') {\n    dummyAx = {\n      type: 'linear',\n      range: [dataMin, dataMax]\n    };\n  } else {\n    dummyAx = {\n      type: ax.type,\n      range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),\n      calendar: calendar\n    };\n  }\n  axes.setConvert(dummyAx);\n  size = size && cleanTicks.dtick(size, dummyAx.type);\n  if (size) {\n    dummyAx.dtick = size;\n    dummyAx.tick0 = cleanTicks.tick0(undefined, dummyAx.type, calendar);\n  } else {\n    var size0;\n    if (nbins) size0 = (dataMax - dataMin) / nbins;else {\n      // totally auto: scale off std deviation so the highest bin is\n      // somewhat taller than the total number of bins, but don't let\n      // the size get smaller than the 'nice' rounded down minimum\n      // difference between values\n      var distinctData = Lib.distinctVals(data);\n      var msexp = Math.pow(10, Math.floor(Math.log(distinctData.minDiff) / Math.LN10));\n      var minSize = msexp * Lib.roundUp(distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);\n      size0 = Math.max(minSize, 2 * Lib.stdev(data) / Math.pow(data.length, is2d ? 0.25 : 0.4));\n\n      // fallback if ax.d2c output BADNUMs\n      // e.g. when user try to plot categorical bins\n      // on a layout.xaxis.type: 'linear'\n      if (!isNumeric(size0)) size0 = 1;\n    }\n    axes.autoTicks(dummyAx, size0);\n  }\n  var finalSize = dummyAx.dtick;\n  var binStart = axes.tickIncrement(axes.tickFirst(dummyAx), finalSize, 'reverse', calendar);\n  var binEnd, bincount;\n\n  // check for too many data points right at the edges of bins\n  // (>50% within 1% of bin edges) or all data points integral\n  // and offset the bins accordingly\n  if (typeof finalSize === 'number') {\n    binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);\n    bincount = 1 + Math.floor((dataMax - binStart) / finalSize);\n    binEnd = binStart + bincount * finalSize;\n  } else {\n    // month ticks - should be the only nonlinear kind we have at this point.\n    // dtick (as supplied by axes.autoTick) only has nonlinear values on\n    // date and log axes, but even if you display a histogram on a log axis\n    // we bin it on a linear axis (which one could argue against, but that's\n    // a separate issue)\n    if (dummyAx.dtick.charAt(0) === 'M') {\n      binStart = autoShiftMonthBins(binStart, data, finalSize, dataMin, calendar);\n    }\n\n    // calculate the endpoint for nonlinear ticks - you have to\n    // just increment until you're done\n    binEnd = binStart;\n    bincount = 0;\n    while (binEnd <= dataMax) {\n      binEnd = axes.tickIncrement(binEnd, finalSize, false, calendar);\n      bincount++;\n    }\n  }\n  return {\n    start: ax.c2r(binStart, 0, calendar),\n    end: ax.c2r(binEnd, 0, calendar),\n    size: finalSize,\n    _dataSpan: dataMax - dataMin\n  };\n};\nfunction autoShiftNumericBins(binStart, data, ax, dataMin, dataMax) {\n  var edgecount = 0;\n  var midcount = 0;\n  var intcount = 0;\n  var blankCount = 0;\n  function nearEdge(v) {\n    // is a value within 1% of a bin edge?\n    return (1 + (v - binStart) * 100 / ax.dtick) % 100 < 2;\n  }\n  for (var i = 0; i < data.length; i++) {\n    if (data[i] % 1 === 0) intcount++;else if (!isNumeric(data[i])) blankCount++;\n    if (nearEdge(data[i])) edgecount++;\n    if (nearEdge(data[i] + ax.dtick / 2)) midcount++;\n  }\n  var dataCount = data.length - blankCount;\n  if (intcount === dataCount && ax.type !== 'date') {\n    if (ax.dtick < 1) {\n      // all integers: if bin size is <1, it's because\n      // that was specifically requested (large nbins)\n      // so respect that... but center the bins containing\n      // integers on those integers\n\n      binStart = dataMin - 0.5 * ax.dtick;\n    } else {\n      // otherwise start half an integer down regardless of\n      // the bin size, just enough to clear up endpoint\n      // ambiguity about which integers are in which bins.\n\n      binStart -= 0.5;\n      if (binStart + ax.dtick < dataMin) binStart += ax.dtick;\n    }\n  } else if (midcount < dataCount * 0.1) {\n    if (edgecount > dataCount * 0.3 || nearEdge(dataMin) || nearEdge(dataMax)) {\n      // lots of points at the edge, not many in the middle\n      // shift half a bin\n      var binshift = ax.dtick / 2;\n      binStart += binStart + binshift < dataMin ? binshift : -binshift;\n    }\n  }\n  return binStart;\n}\nfunction autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {\n  var stats = Lib.findExactDates(data, calendar);\n  // number of data points that needs to be an exact value\n  // to shift that increment to (near) the bin center\n  var threshold = 0.8;\n  if (stats.exactDays > threshold) {\n    var numMonths = Number(dtick.substr(1));\n    if (stats.exactYears > threshold && numMonths % 12 === 0) {\n      // The exact middle of a non-leap-year is 1.5 days into July\n      // so if we start the bins here, all but leap years will\n      // get hover-labeled as exact years.\n      binStart = axes.tickIncrement(binStart, 'M6', 'reverse') + ONEDAY * 1.5;\n    } else if (stats.exactMonths > threshold) {\n      // Months are not as clean, but if we shift half the *longest*\n      // month (31/2 days) then 31-day months will get labeled exactly\n      // and shorter months will get labeled with the correct month\n      // but shifted 12-36 hours into it.\n      binStart = axes.tickIncrement(binStart, 'M1', 'reverse') + ONEDAY * 15.5;\n    } else {\n      // Shifting half a day is exact, but since these are month bins it\n      // will always give a somewhat odd-looking label, until we do something\n      // smarter like showing the bin boundaries (or the bounds of the actual\n      // data in each bin)\n      binStart -= HALFDAY;\n    }\n    var nextBinStart = axes.tickIncrement(binStart, dtick);\n    if (nextBinStart <= dataMin) return nextBinStart;\n  }\n  return binStart;\n}\n\n// ----------------------------------------------------\n// Ticks and grids\n// ----------------------------------------------------\n\n// ensure we have minor tick0 and dtick calculated\naxes.prepMinorTicks = function (mockAx, ax, opts) {\n  if (!ax.minor.dtick) {\n    delete mockAx.dtick;\n    var hasMajor = ax.dtick && isNumeric(ax._tmin);\n    var mockMinorRange;\n    if (hasMajor) {\n      var tick2 = axes.tickIncrement(ax._tmin, ax.dtick, true);\n      // mock range a tiny bit smaller than one major tick interval\n      mockMinorRange = [ax._tmin, tick2 * 0.99 + ax._tmin * 0.01];\n    } else {\n      var rl = Lib.simpleMap(ax.range, ax.r2l);\n      // If we don't have a major dtick, the concept of minor ticks is a little\n      // ambiguous - just take a stab and say minor.nticks should span 1/5 the axis\n      mockMinorRange = [rl[0], 0.8 * rl[0] + 0.2 * rl[1]];\n    }\n    mockAx.range = Lib.simpleMap(mockMinorRange, ax.l2r);\n    mockAx._isMinor = true;\n    axes.prepTicks(mockAx, opts);\n    if (hasMajor) {\n      var numericMajor = isNumeric(ax.dtick);\n      var numericMinor = isNumeric(mockAx.dtick);\n      var majorNum = numericMajor ? ax.dtick : +ax.dtick.substring(1);\n      var minorNum = numericMinor ? mockAx.dtick : +mockAx.dtick.substring(1);\n      if (numericMajor && numericMinor) {\n        if (!isMultiple(majorNum, minorNum)) {\n          // give up on minor ticks - outside the below exceptions,\n          // this can only happen if minor.nticks is smaller than two jumps\n          // in the auto-tick scale and the first jump is not an even multiple\n          // (5 -> 2 or for dates 3 ->2, 15 -> 10 etc)  or if you provided\n          // an explicit dtick, in which case it's fine to give up,\n          // you can provide an explicit minor.dtick.\n          if (majorNum === 2 * ONEWEEK && minorNum === 3 * ONEDAY) {\n            mockAx.dtick = ONEWEEK;\n          } else if (majorNum === ONEWEEK && !(ax._input.minor || {}).nticks) {\n            // minor.nticks defaults to 5, but in this one case we want 7,\n            // so the minor ticks show on all days of the week\n            mockAx.dtick = ONEDAY;\n          } else if (isClose(majorNum / minorNum, 2.5)) {\n            // 5*10^n -> 2*10^n and you've set nticks < 5\n            // quarters are pretty common, we don't do this by default as it\n            // would add an extra digit to display, but minor has no labels\n            mockAx.dtick = majorNum / 2;\n          } else {\n            mockAx.dtick = majorNum;\n          }\n        } else if (majorNum === 2 * ONEWEEK && minorNum === 2 * ONEDAY) {\n          // this is a weird one: we don't want to automatically choose\n          // 2-day minor ticks for 2-week major, even though it IS an even multiple,\n          // because people would expect to see the weeks clearly\n          mockAx.dtick = ONEWEEK;\n        }\n      } else if (String(ax.dtick).charAt(0) === 'M') {\n        if (numericMinor) {\n          mockAx.dtick = 'M1';\n        } else {\n          if (!isMultiple(majorNum, minorNum)) {\n            // unless you provided an explicit ax.dtick (in which case\n            // it's OK for us to give up, you can provide an explicit\n            // minor.dtick too), this can only happen with:\n            // minor.nticks < 3 and dtick === M3, or\n            // minor.nticks < 5 and dtick === 5 * 10^n years\n            // so in all cases we just give up.\n            mockAx.dtick = ax.dtick;\n          } else if (majorNum >= 12 && minorNum === 2) {\n            // another special carve-out: for year major ticks, don't show\n            // 2-month minor ticks, bump to quarters\n            mockAx.dtick = 'M3';\n          }\n        }\n      } else if (String(mockAx.dtick).charAt(0) === 'L') {\n        if (String(ax.dtick).charAt(0) === 'L') {\n          if (!isMultiple(majorNum, minorNum)) {\n            mockAx.dtick = isClose(majorNum / minorNum, 2.5) ? ax.dtick / 2 : ax.dtick;\n          }\n        } else {\n          mockAx.dtick = 'D1';\n        }\n      } else if (mockAx.dtick === 'D2' && +ax.dtick > 1) {\n        // the D2 log axis tick spacing is confusing for unlabeled minor ticks if\n        // the major dtick is more than one order of magnitude.\n        mockAx.dtick = 1;\n      }\n    }\n    // put back the original range, to use to find the full set of minor ticks\n    mockAx.range = ax.range;\n  }\n  if (ax.minor._tick0Init === undefined) {\n    // ensure identical tick0\n    mockAx.tick0 = ax.tick0;\n  }\n};\nfunction isMultiple(bigger, smaller) {\n  return Math.abs((bigger / smaller + 0.5) % 1 - 0.5) < 0.001;\n}\nfunction isClose(a, b) {\n  return Math.abs(a / b - 1) < 0.001;\n}\n\n// ensure we have tick0, dtick, and tick rounding calculated\naxes.prepTicks = function (ax, opts) {\n  var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts);\n\n  // calculate max number of (auto) ticks to display based on plot size\n  if (ax.tickmode === 'auto' || !ax.dtick) {\n    var nt = ax.nticks;\n    var minPx;\n    if (!nt) {\n      if (ax.type === 'category' || ax.type === 'multicategory') {\n        minPx = ax.tickfont ? Lib.bigFont(ax.tickfont.size || 12) : 15;\n        nt = ax._length / minPx;\n      } else {\n        minPx = ax._id.charAt(0) === 'y' ? 40 : 80;\n        nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;\n      }\n\n      // radial axes span half their domain,\n      // multiply nticks value by two to get correct number of auto ticks.\n      if (ax._name === 'radialaxis') nt *= 2;\n    }\n    if (!(ax.minor && ax.minor.tickmode !== 'array')) {\n      // add a couple of extra digits for filling in ticks when we\n      // have explicit tickvals without tick text\n      if (ax.tickmode === 'array') nt *= 100;\n    }\n    ax._roughDTick = Math.abs(rng[1] - rng[0]) / nt;\n    axes.autoTicks(ax, ax._roughDTick);\n\n    // check for a forced minimum dtick\n    if (ax._minDtick > 0 && ax.dtick < ax._minDtick * 2) {\n      ax.dtick = ax._minDtick;\n      ax.tick0 = ax.l2r(ax._forceTick0);\n    }\n  }\n  if (ax.ticklabelmode === 'period') {\n    adjustPeriodDelta(ax);\n  }\n\n  // check for missing tick0\n  if (!ax.tick0) {\n    ax.tick0 = ax.type === 'date' ? '2000-01-01' : 0;\n  }\n\n  // ensure we don't try to make ticks below our minimum precision\n  // see https://github.com/plotly/plotly.js/issues/2892\n  if (ax.type === 'date' && ax.dtick < 0.1) ax.dtick = 0.1;\n\n  // now figure out rounding of tick values\n  autoTickRound(ax);\n};\nfunction nMonths(dtick) {\n  return +dtick.substring(1);\n}\nfunction adjustPeriodDelta(ax) {\n  // adjusts ax.dtick and sets ax._definedDelta\n  var definedDelta;\n  function mDate() {\n    return !(isNumeric(ax.dtick) || ax.dtick.charAt(0) !== 'M');\n  }\n  var isMDate = mDate();\n  var tickformat = axes.getTickFormat(ax);\n  if (tickformat) {\n    var noDtick = ax._dtickInit !== ax.dtick;\n    if (!/%[fLQsSMX]/.test(tickformat)\n    // %f: microseconds as a decimal number [000000, 999999]\n    // %L: milliseconds as a decimal number [000, 999]\n    // %Q: milliseconds since UNIX epoch\n    // %s: seconds since UNIX epoch\n    // %S: second as a decimal number [00,61]\n    // %M: minute as a decimal number [00,59]\n    // %X: the locale’s time, such as %-I:%M:%S %p\n    ) {\n      if (/%[HI]/.test(tickformat)\n      // %H: hour (24-hour clock) as a decimal number [00,23]\n      // %I: hour (12-hour clock) as a decimal number [01,12]\n      ) {\n        definedDelta = ONEHOUR;\n        if (noDtick && !isMDate && ax.dtick < ONEHOUR) ax.dtick = ONEHOUR;\n      } else if (/%p/.test(tickformat) // %p: either AM or PM\n      ) {\n        definedDelta = HALFDAY;\n        if (noDtick && !isMDate && ax.dtick < HALFDAY) ax.dtick = HALFDAY;\n      } else if (/%[Aadejuwx]/.test(tickformat)\n      // %A: full weekday name\n      // %a: abbreviated weekday name\n      // %d: zero-padded day of the month as a decimal number [01,31]\n      // %e: space-padded day of the month as a decimal number [ 1,31]\n      // %j: day of the year as a decimal number [001,366]\n      // %u: Monday-based (ISO 8601) weekday as a decimal number [1,7]\n      // %w: Sunday-based weekday as a decimal number [0,6]\n      // %x: the locale’s date, such as %-m/%-d/%Y\n      ) {\n        definedDelta = ONEDAY;\n        if (noDtick && !isMDate && ax.dtick < ONEDAY) ax.dtick = ONEDAY;\n      } else if (/%[UVW]/.test(tickformat)\n      // %U: Sunday-based week of the year as a decimal number [00,53]\n      // %V: ISO 8601 week of the year as a decimal number [01, 53]\n      // %W: Monday-based week of the year as a decimal number [00,53]\n      ) {\n        definedDelta = ONEWEEK;\n        if (noDtick && !isMDate && ax.dtick < ONEWEEK) ax.dtick = ONEWEEK;\n      } else if (/%[Bbm]/.test(tickformat)\n      // %B: full month name\n      // %b: abbreviated month name\n      // %m: month as a decimal number [01,12]\n      ) {\n        definedDelta = ONEAVGMONTH;\n        if (noDtick && (isMDate ? nMonths(ax.dtick) < 1 : ax.dtick < ONEMINMONTH)) ax.dtick = 'M1';\n      } else if (/%[q]/.test(tickformat)\n      // %q: quarter of the year as a decimal number [1,4]\n      ) {\n        definedDelta = ONEAVGQUARTER;\n        if (noDtick && (isMDate ? nMonths(ax.dtick) < 3 : ax.dtick < ONEMINQUARTER)) ax.dtick = 'M3';\n      } else if (/%[Yy]/.test(tickformat)\n      // %Y: year with century as a decimal number, such as 1999\n      // %y: year without century as a decimal number [00,99]\n      ) {\n        definedDelta = ONEAVGYEAR;\n        if (noDtick && (isMDate ? nMonths(ax.dtick) < 12 : ax.dtick < ONEMINYEAR)) ax.dtick = 'M12';\n      }\n    }\n  }\n  isMDate = mDate();\n  if (isMDate && ax.tick0 === ax._dowTick0) {\n    // discard Sunday/Monday tweaks\n    ax.tick0 = ax._rawTick0;\n  }\n  ax._definedDelta = definedDelta;\n}\nfunction positionPeriodTicks(tickVals, ax, definedDelta) {\n  for (var i = 0; i < tickVals.length; i++) {\n    var v = tickVals[i].value;\n    var a = i;\n    var b = i + 1;\n    if (i < tickVals.length - 1) {\n      a = i;\n      b = i + 1;\n    } else if (i > 0) {\n      a = i - 1;\n      b = i;\n    } else {\n      a = i;\n      b = i;\n    }\n    var A = tickVals[a].value;\n    var B = tickVals[b].value;\n    var actualDelta = Math.abs(B - A);\n    var delta = definedDelta || actualDelta;\n    var periodLength = 0;\n    if (delta >= ONEMINYEAR) {\n      if (actualDelta >= ONEMINYEAR && actualDelta <= ONEMAXYEAR) {\n        periodLength = actualDelta;\n      } else {\n        periodLength = ONEAVGYEAR;\n      }\n    } else if (definedDelta === ONEAVGQUARTER && delta >= ONEMINQUARTER) {\n      if (actualDelta >= ONEMINQUARTER && actualDelta <= ONEMAXQUARTER) {\n        periodLength = actualDelta;\n      } else {\n        periodLength = ONEAVGQUARTER;\n      }\n    } else if (delta >= ONEMINMONTH) {\n      if (actualDelta >= ONEMINMONTH && actualDelta <= ONEMAXMONTH) {\n        periodLength = actualDelta;\n      } else {\n        periodLength = ONEAVGMONTH;\n      }\n    } else if (definedDelta === ONEWEEK && delta >= ONEWEEK) {\n      periodLength = ONEWEEK;\n    } else if (delta >= ONEDAY) {\n      periodLength = ONEDAY;\n    } else if (definedDelta === HALFDAY && delta >= HALFDAY) {\n      periodLength = HALFDAY;\n    } else if (definedDelta === ONEHOUR && delta >= ONEHOUR) {\n      periodLength = ONEHOUR;\n    }\n    var inBetween;\n    if (periodLength >= actualDelta) {\n      // ensure new label positions remain between ticks\n      periodLength = actualDelta;\n      inBetween = true;\n    }\n    var endPeriod = v + periodLength;\n    if (ax.rangebreaks && periodLength > 0) {\n      var nAll = 84; // highly divisible 7 * 12\n      var n = 0;\n      for (var c = 0; c < nAll; c++) {\n        var r = (c + 0.5) / nAll;\n        if (ax.maskBreaks(v * (1 - r) + r * endPeriod) !== BADNUM) n++;\n      }\n      periodLength *= n / nAll;\n      if (!periodLength) {\n        tickVals[i].drop = true;\n      }\n      if (inBetween && actualDelta > ONEWEEK) periodLength = actualDelta; // center monthly & longer periods\n    }\n    if (periodLength > 0 ||\n    // not instant\n    i === 0 // taking care first tick added\n    ) {\n      tickVals[i].periodX = v + periodLength / 2;\n    }\n  }\n}\n\n// calculate the ticks: text, values, positioning\n// if ticks are set to automatic, determine the right values (tick0,dtick)\n// in any case, set tickround to # of digits to round tick labels to,\n// or codes to this effect for log and date scales\naxes.calcTicks = function calcTicks(ax, opts) {\n  var type = ax.type;\n  var calendar = ax.calendar;\n  var ticklabelstep = ax.ticklabelstep;\n  var isPeriod = ax.ticklabelmode === 'period';\n  var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts);\n  var axrev = rng[1] < rng[0];\n  var minRange = Math.min(rng[0], rng[1]);\n  var maxRange = Math.max(rng[0], rng[1]);\n  var maxTicks = Math.max(1000, ax._length || 0);\n  var ticksOut = [];\n  var minorTicks = [];\n  var tickVals = [];\n  var minorTickVals = [];\n  var hasMinor = ax.minor && (ax.minor.ticks || ax.minor.showgrid);\n\n  // calc major first\n  for (var major = 1; major >= (hasMinor ? 0 : 1); major--) {\n    var isMinor = !major;\n    if (major) {\n      ax._dtickInit = ax.dtick;\n      ax._tick0Init = ax.tick0;\n    } else {\n      ax.minor._dtickInit = ax.minor.dtick;\n      ax.minor._tick0Init = ax.minor.tick0;\n    }\n    var mockAx = major ? ax : Lib.extendFlat({}, ax, ax.minor);\n    if (isMinor) {\n      axes.prepMinorTicks(mockAx, ax, opts);\n    } else {\n      axes.prepTicks(mockAx, opts);\n    }\n\n    // now that we've figured out the auto values for formatting\n    // in case we're missing some ticktext, we can break out for array ticks\n    if (mockAx.tickmode === 'array') {\n      if (major) {\n        tickVals = [];\n        ticksOut = arrayTicks(ax, !isMinor);\n      } else {\n        minorTickVals = [];\n        minorTicks = arrayTicks(ax, !isMinor);\n      }\n      continue;\n    }\n\n    // fill tickVals based on overlaying axis\n    if (mockAx.tickmode === 'sync') {\n      tickVals = [];\n      ticksOut = syncTicks(ax);\n      continue;\n    }\n\n    // add a tiny bit so we get ticks which may have rounded out\n    var exRng = expandRange(rng);\n    var startTick = exRng[0];\n    var endTick = exRng[1];\n    var numDtick = isNumeric(mockAx.dtick);\n    var isDLog = type === 'log' && !(numDtick || mockAx.dtick.charAt(0) === 'L');\n\n    // find the first tick\n    var x0 = axes.tickFirst(mockAx, opts);\n    if (major) {\n      ax._tmin = x0;\n\n      // No visible ticks? Quit.\n      // I've only seen this on category axes with all categories off the edge.\n      if (x0 < startTick !== axrev) break;\n\n      // return the full set of tick vals\n      if (type === 'category' || type === 'multicategory') {\n        endTick = axrev ? Math.max(-0.5, endTick) : Math.min(ax._categories.length - 0.5, endTick);\n      }\n    }\n    var prevX = null;\n    var x = x0;\n    var majorId;\n    if (major) {\n      // ids for ticklabelstep\n      var _dTick;\n      if (numDtick) {\n        _dTick = ax.dtick;\n      } else {\n        if (type === 'date') {\n          if (typeof ax.dtick === 'string' && ax.dtick.charAt(0) === 'M') {\n            _dTick = ONEAVGMONTH * ax.dtick.substring(1);\n          }\n        } else {\n          _dTick = ax._roughDTick;\n        }\n      }\n      majorId = Math.round((ax.r2l(x) - ax.r2l(ax.tick0)) / _dTick) - 1;\n    }\n    var dtick = mockAx.dtick;\n    if (mockAx.rangebreaks && mockAx._tick0Init !== mockAx.tick0) {\n      // adjust tick0\n      x = moveOutsideBreak(x, ax);\n      if (!axrev) {\n        x = axes.tickIncrement(x, dtick, !axrev, calendar);\n      }\n    }\n    if (major && isPeriod) {\n      // add one item to label period before tick0\n      x = axes.tickIncrement(x, dtick, !axrev, calendar);\n      majorId--;\n    }\n    for (; axrev ? x >= endTick : x <= endTick; x = axes.tickIncrement(x, dtick, axrev, calendar)) {\n      if (major) majorId++;\n      if (mockAx.rangebreaks) {\n        if (!axrev) {\n          if (x < startTick) continue;\n          if (mockAx.maskBreaks(x) === BADNUM && moveOutsideBreak(x, mockAx) >= maxRange) break;\n        }\n      }\n\n      // prevent infinite loops - no more than one tick per pixel,\n      // and make sure each value is different from the previous\n      if (tickVals.length > maxTicks || x === prevX) break;\n      prevX = x;\n      var obj = {\n        value: x\n      };\n      if (major) {\n        if (isDLog && x !== (x | 0)) {\n          obj.simpleLabel = true;\n        }\n        if (ticklabelstep > 1 && majorId % ticklabelstep) {\n          obj.skipLabel = true;\n        }\n        tickVals.push(obj);\n      } else {\n        obj.minor = true;\n        minorTickVals.push(obj);\n      }\n    }\n  }\n  if (hasMinor) {\n    var canOverlap = ax.minor.ticks === 'inside' && ax.ticks === 'outside' || ax.minor.ticks === 'outside' && ax.ticks === 'inside';\n    if (!canOverlap) {\n      // remove duplicate minors\n\n      var majorValues = tickVals.map(function (d) {\n        return d.value;\n      });\n      var list = [];\n      for (var k = 0; k < minorTickVals.length; k++) {\n        var T = minorTickVals[k];\n        var v = T.value;\n        if (majorValues.indexOf(v) !== -1) {\n          continue;\n        }\n        var found = false;\n        for (var q = 0; !found && q < tickVals.length; q++) {\n          if (\n          // add 10e6 to eliminate problematic digits\n          10e6 + tickVals[q].value === 10e6 + v) {\n            found = true;\n          }\n        }\n        if (!found) list.push(T);\n      }\n      minorTickVals = list;\n    }\n  }\n  if (isPeriod) positionPeriodTicks(tickVals, ax, ax._definedDelta);\n  var i;\n  if (ax.rangebreaks) {\n    var flip = ax._id.charAt(0) === 'y';\n    var fontSize = 1; // one pixel minimum\n    if (ax.tickmode === 'auto') {\n      fontSize = ax.tickfont ? ax.tickfont.size : 12;\n    }\n    var prevL = NaN;\n    for (i = tickVals.length - 1; i > -1; i--) {\n      if (tickVals[i].drop) {\n        tickVals.splice(i, 1);\n        continue;\n      }\n      tickVals[i].value = moveOutsideBreak(tickVals[i].value, ax);\n\n      // avoid overlaps\n      var l = ax.c2p(tickVals[i].value);\n      if (flip ? prevL > l - fontSize : prevL < l + fontSize) {\n        // ensure one pixel minimum\n        tickVals.splice(axrev ? i + 1 : i, 1);\n      } else {\n        prevL = l;\n      }\n    }\n  }\n\n  // If same angle over a full circle, the last tick vals is a duplicate.\n  // TODO must do something similar for angular date axes.\n  if (isAngular(ax) && Math.abs(rng[1] - rng[0]) === 360) {\n    tickVals.pop();\n  }\n\n  // save the last tick as well as first, so we can\n  // show the exponent only on the last one\n  ax._tmax = (tickVals[tickVals.length - 1] || {}).value;\n\n  // for showing the rest of a date when the main tick label is only the\n  // latter part: ax._prevDateHead holds what we showed most recently.\n  // Start with it cleared and mark that we're in calcTicks (ie calculating a\n  // whole string of these so we should care what the previous date head was!)\n  ax._prevDateHead = '';\n  ax._inCalcTicks = true;\n  var lastVisibleHead;\n  var hideLabel = function (tick) {\n    tick.text = '';\n    ax._prevDateHead = lastVisibleHead;\n  };\n  tickVals = tickVals.concat(minorTickVals);\n  var t, p;\n  for (i = 0; i < tickVals.length; i++) {\n    var _minor = tickVals[i].minor;\n    var _value = tickVals[i].value;\n    if (_minor) {\n      minorTicks.push({\n        x: _value,\n        minor: true\n      });\n    } else {\n      lastVisibleHead = ax._prevDateHead;\n      t = axes.tickText(ax, _value, false,\n      // hover\n      tickVals[i].simpleLabel // noSuffixPrefix\n      );\n      p = tickVals[i].periodX;\n      if (p !== undefined) {\n        t.periodX = p;\n        if (p > maxRange || p < minRange) {\n          // hide label if outside the range\n          if (p > maxRange) t.periodX = maxRange;\n          if (p < minRange) t.periodX = minRange;\n          hideLabel(t);\n        }\n      }\n      if (tickVals[i].skipLabel) {\n        hideLabel(t);\n      }\n      ticksOut.push(t);\n    }\n  }\n  ticksOut = ticksOut.concat(minorTicks);\n  ax._inCalcTicks = false;\n  if (isPeriod && ticksOut.length) {\n    // drop very first tick that we added to handle period\n    ticksOut[0].noTick = true;\n  }\n  return ticksOut;\n};\nfunction filterRangeBreaks(ax, ticksOut) {\n  if (ax.rangebreaks) {\n    // remove ticks falling inside rangebreaks\n    ticksOut = ticksOut.filter(function (d) {\n      return ax.maskBreaks(d.x) !== BADNUM;\n    });\n  }\n  return ticksOut;\n}\nfunction syncTicks(ax) {\n  // get the overlaying axis\n  var baseAxis = ax._mainAxis;\n  var ticksOut = [];\n  if (baseAxis._vals) {\n    for (var i = 0; i < baseAxis._vals.length; i++) {\n      // filter vals with noTick flag\n      if (baseAxis._vals[i].noTick) {\n        continue;\n      }\n\n      // get the position of the every tick\n      var pos = baseAxis.l2p(baseAxis._vals[i].x);\n\n      // get the tick for the current axis based on position\n      var vali = ax.p2l(pos);\n      var obj = axes.tickText(ax, vali);\n\n      // assign minor ticks\n      if (baseAxis._vals[i].minor) {\n        obj.minor = true;\n        obj.text = '';\n      }\n      ticksOut.push(obj);\n    }\n  }\n  ticksOut = filterRangeBreaks(ax, ticksOut);\n  return ticksOut;\n}\nfunction arrayTicks(ax, majorOnly) {\n  var rng = Lib.simpleMap(ax.range, ax.r2l);\n  var exRng = expandRange(rng);\n  var tickMin = Math.min(exRng[0], exRng[1]);\n  var tickMax = Math.max(exRng[0], exRng[1]);\n\n  // make sure showing ticks doesn't accidentally add new categories\n  // TODO multicategory, if we allow ticktext / tickvals\n  var tickVal2l = ax.type === 'category' ? ax.d2l_noadd : ax.d2l;\n\n  // array ticks on log axes always show the full number\n  // (if no explicit ticktext overrides it)\n  if (ax.type === 'log' && String(ax.dtick).charAt(0) !== 'L') {\n    ax.dtick = 'L' + Math.pow(10, Math.floor(Math.min(ax.range[0], ax.range[1])) - 1);\n  }\n  var ticksOut = [];\n  for (var isMinor = 0; isMinor <= 1; isMinor++) {\n    if (majorOnly !== undefined && (majorOnly && isMinor || majorOnly === false && !isMinor)) continue;\n    if (isMinor && !ax.minor) continue;\n    var vals = !isMinor ? ax.tickvals : ax.minor.tickvals;\n    var text = !isMinor ? ax.ticktext : [];\n    if (!vals) continue;\n\n    // without a text array, just format the given values as any other ticks\n    // except with more precision to the numbers\n    if (!Lib.isArrayOrTypedArray(text)) text = [];\n    for (var i = 0; i < vals.length; i++) {\n      var vali = tickVal2l(vals[i]);\n      if (vali > tickMin && vali < tickMax) {\n        var obj = axes.tickText(ax, vali, false, String(text[i]));\n        if (isMinor) {\n          obj.minor = true;\n          obj.text = '';\n        }\n        ticksOut.push(obj);\n      }\n    }\n  }\n  ticksOut = filterRangeBreaks(ax, ticksOut);\n  return ticksOut;\n}\nvar roundBase10 = [2, 5, 10];\nvar roundBase24 = [1, 2, 3, 6, 12];\nvar roundBase60 = [1, 2, 5, 10, 15, 30];\n// 2&3 day ticks are weird, but need something btwn 1&7\nvar roundDays = [1, 2, 3, 7, 14];\n// approx. tick positions for log axes, showing all (1) and just 1, 2, 5 (2)\n// these don't have to be exact, just close enough to round to the right value\nvar roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1];\nvar roundLog2 = [-0.301, 0, 0.301, 0.699, 1];\n// N.B. `thetaunit; 'radians' angular axes must be converted to degrees\nvar roundAngles = [15, 30, 45, 90, 180];\nfunction roundDTick(roughDTick, base, roundingSet) {\n  return base * Lib.roundUp(roughDTick / base, roundingSet);\n}\n\n// autoTicks: calculate best guess at pleasant ticks for this axis\n// inputs:\n//      ax - an axis object\n//      roughDTick - rough tick spacing (to be turned into a nice round number)\n// outputs (into ax):\n//   tick0: starting point for ticks (not necessarily on the graph)\n//      usually 0 for numeric (=10^0=1 for log) or jan 1, 2000 for dates\n//   dtick: the actual, nice round tick spacing, usually a little larger than roughDTick\n//      if the ticks are spaced linearly (linear scale, categories,\n//          log with only full powers, date ticks < month),\n//          this will just be a number\n//      months: M#\n//      years: M# where # is 12*number of years\n//      log with linear ticks: L# where # is the linear tick spacing\n//      log showing powers plus some intermediates:\n//          D1 shows all digits, D2 shows 2 and 5\naxes.autoTicks = function (ax, roughDTick, isMinor) {\n  var base;\n  function getBase(v) {\n    return Math.pow(v, Math.floor(Math.log(roughDTick) / Math.LN10));\n  }\n  if (ax.type === 'date') {\n    ax.tick0 = Lib.dateTick0(ax.calendar, 0);\n\n    // the criteria below are all based on the rough spacing we calculate\n    // being > half of the final unit - so precalculate twice the rough val\n    var roughX2 = 2 * roughDTick;\n    if (roughX2 > ONEAVGYEAR) {\n      roughDTick /= ONEAVGYEAR;\n      base = getBase(10);\n      ax.dtick = 'M' + 12 * roundDTick(roughDTick, base, roundBase10);\n    } else if (roughX2 > ONEAVGMONTH) {\n      roughDTick /= ONEAVGMONTH;\n      ax.dtick = 'M' + roundDTick(roughDTick, 1, roundBase24);\n    } else if (roughX2 > ONEDAY) {\n      ax.dtick = roundDTick(roughDTick, ONEDAY, ax._hasDayOfWeekBreaks ? [1, 2, 7, 14] : roundDays);\n      if (!isMinor) {\n        // get week ticks on sunday\n        // this will also move the base tick off 2000-01-01 if dtick is\n        // 2 or 3 days... but that's a weird enough case that we'll ignore it.\n        var tickformat = axes.getTickFormat(ax);\n        var isPeriod = ax.ticklabelmode === 'period';\n        if (isPeriod) ax._rawTick0 = ax.tick0;\n        if (/%[uVW]/.test(tickformat)) {\n          ax.tick0 = Lib.dateTick0(ax.calendar, 2); // Monday\n        } else {\n          ax.tick0 = Lib.dateTick0(ax.calendar, 1); // Sunday\n        }\n        if (isPeriod) ax._dowTick0 = ax.tick0;\n      }\n    } else if (roughX2 > ONEHOUR) {\n      ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);\n    } else if (roughX2 > ONEMIN) {\n      ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);\n    } else if (roughX2 > ONESEC) {\n      ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);\n    } else {\n      // milliseconds\n      base = getBase(10);\n      ax.dtick = roundDTick(roughDTick, base, roundBase10);\n    }\n  } else if (ax.type === 'log') {\n    ax.tick0 = 0;\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    if (ax._isMinor) {\n      // Log axes by default get MORE than nTicks based on the metrics below\n      // But for minor ticks we don't want this increase, we already have\n      // the major ticks.\n      roughDTick *= 1.5;\n    }\n    if (roughDTick > 0.7) {\n      // only show powers of 10\n      ax.dtick = Math.ceil(roughDTick);\n    } else if (Math.abs(rng[1] - rng[0]) < 1) {\n      // span is less than one power of 10\n      var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick);\n\n      // ticks on a linear scale, labeled fully\n      roughDTick = Math.abs(Math.pow(10, rng[1]) - Math.pow(10, rng[0])) / nt;\n      base = getBase(10);\n      ax.dtick = 'L' + roundDTick(roughDTick, base, roundBase10);\n    } else {\n      // include intermediates between powers of 10,\n      // labeled with small digits\n      // ax.dtick = \"D2\" (show 2 and 5) or \"D1\" (show all digits)\n      ax.dtick = roughDTick > 0.3 ? 'D2' : 'D1';\n    }\n  } else if (ax.type === 'category' || ax.type === 'multicategory') {\n    ax.tick0 = 0;\n    ax.dtick = Math.ceil(Math.max(roughDTick, 1));\n  } else if (isAngular(ax)) {\n    ax.tick0 = 0;\n    base = 1;\n    ax.dtick = roundDTick(roughDTick, base, roundAngles);\n  } else {\n    // auto ticks always start at 0\n    ax.tick0 = 0;\n    base = getBase(10);\n    ax.dtick = roundDTick(roughDTick, base, roundBase10);\n  }\n\n  // prevent infinite loops\n  if (ax.dtick === 0) ax.dtick = 1;\n\n  // TODO: this is from log axis histograms with autorange off\n  if (!isNumeric(ax.dtick) && typeof ax.dtick !== 'string') {\n    var olddtick = ax.dtick;\n    ax.dtick = 1;\n    throw 'ax.dtick error: ' + String(olddtick);\n  }\n};\n\n// after dtick is already known, find tickround = precision\n// to display in tick labels\n//   for numeric ticks, integer # digits after . to round to\n//   for date ticks, the last date part to show (y,m,d,H,M,S)\n//      or an integer # digits past seconds\nfunction autoTickRound(ax) {\n  var dtick = ax.dtick;\n  ax._tickexponent = 0;\n  if (!isNumeric(dtick) && typeof dtick !== 'string') {\n    dtick = 1;\n  }\n  if (ax.type === 'category' || ax.type === 'multicategory') {\n    ax._tickround = null;\n  }\n  if (ax.type === 'date') {\n    // If tick0 is unusual, give tickround a bit more information\n    // not necessarily *all* the information in tick0 though, if it's really odd\n    // minimal string length for tick0: 'd' is 10, 'M' is 16, 'S' is 19\n    // take off a leading minus (year < 0) and i (intercalary month) so length is consistent\n    var tick0ms = ax.r2l(ax.tick0);\n    var tick0str = ax.l2r(tick0ms).replace(/(^-|i)/g, '');\n    var tick0len = tick0str.length;\n    if (String(dtick).charAt(0) === 'M') {\n      // any tick0 more specific than a year: alway show the full date\n      if (tick0len > 10 || tick0str.substr(5) !== '01-01') ax._tickround = 'd';\n      // show the month unless ticks are full multiples of a year\n      else ax._tickround = +dtick.substr(1) % 12 === 0 ? 'y' : 'm';\n    } else if (dtick >= ONEDAY && tick0len <= 10 || dtick >= ONEDAY * 15) ax._tickround = 'd';else if (dtick >= ONEMIN && tick0len <= 16 || dtick >= ONEHOUR) ax._tickround = 'M';else if (dtick >= ONESEC && tick0len <= 19 || dtick >= ONEMIN) ax._tickround = 'S';else {\n      // tickround is a number of digits of fractional seconds\n      // of any two adjacent ticks, at least one will have the maximum fractional digits\n      // of all possible ticks - so take the max. length of tick0 and the next one\n      var tick1len = ax.l2r(tick0ms + dtick).replace(/^-/, '').length;\n      ax._tickround = Math.max(tick0len, tick1len) - 20;\n\n      // We shouldn't get here... but in case there's a situation I'm\n      // not thinking of where tick0str and tick1str are identical or\n      // something, fall back on maximum precision\n      if (ax._tickround < 0) ax._tickround = 4;\n    }\n  } else if (isNumeric(dtick) || dtick.charAt(0) === 'L') {\n    // linear or log (except D1, D2)\n    var rng = ax.range.map(ax.r2d || Number);\n    if (!isNumeric(dtick)) dtick = Number(dtick.substr(1));\n    // 2 digits past largest digit of dtick\n    ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);\n    var maxend = Math.max(Math.abs(rng[0]), Math.abs(rng[1]));\n    var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);\n    var minexponent = ax.minexponent === undefined ? 3 : ax.minexponent;\n    if (Math.abs(rangeexp) > minexponent) {\n      if (isSIFormat(ax.exponentformat) && !beyondSI(rangeexp)) {\n        ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);\n      } else ax._tickexponent = rangeexp;\n    }\n  } else {\n    // D1 or D2 (log)\n    ax._tickround = null;\n  }\n}\n\n// months and years don't have constant millisecond values\n// (but a year is always 12 months so we only need months)\n// log-scale ticks are also not consistently spaced, except\n// for pure powers of 10\n// numeric ticks always have constant differences, other datetime ticks\n// can all be calculated as constant number of milliseconds\naxes.tickIncrement = function (x, dtick, axrev, calendar) {\n  var axSign = axrev ? -1 : 1;\n\n  // includes linear, all dates smaller than month, and pure 10^n in log\n  if (isNumeric(dtick)) return Lib.increment(x, axSign * dtick);\n\n  // everything else is a string, one character plus a number\n  var tType = dtick.charAt(0);\n  var dtSigned = axSign * Number(dtick.substr(1));\n\n  // Dates: months (or years - see Lib.incrementMonth)\n  if (tType === 'M') return Lib.incrementMonth(x, dtSigned, calendar);\n\n  // Log scales: Linear, Digits\n  if (tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;\n\n  // log10 of 2,5,10, or all digits (logs just have to be\n  // close enough to round)\n  if (tType === 'D') {\n    var tickset = dtick === 'D2' ? roundLog2 : roundLog1;\n    var x2 = x + axSign * 0.01;\n    var frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);\n    return Math.floor(x2) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n  }\n  throw 'unrecognized dtick ' + String(dtick);\n};\n\n// calculate the first tick on an axis\naxes.tickFirst = function (ax, opts) {\n  var r2l = ax.r2l || Number;\n  var rng = Lib.simpleMap(ax.range, r2l, undefined, undefined, opts);\n  var axrev = rng[1] < rng[0];\n  var sRound = axrev ? Math.floor : Math.ceil;\n  // add a tiny extra bit to make sure we get ticks\n  // that may have been rounded out\n  var r0 = expandRange(rng)[0];\n  var dtick = ax.dtick;\n  var tick0 = r2l(ax.tick0);\n  if (isNumeric(dtick)) {\n    var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0;\n\n    // make sure no ticks outside the category list\n    if (ax.type === 'category' || ax.type === 'multicategory') {\n      tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);\n    }\n    return tmin;\n  }\n  var tType = dtick.charAt(0);\n  var dtNum = Number(dtick.substr(1));\n\n  // Dates: months (or years)\n  if (tType === 'M') {\n    var cnt = 0;\n    var t0 = tick0;\n    var t1, mult, newDTick;\n\n    // This algorithm should work for *any* nonlinear (but close to linear!)\n    // tick spacing. Limit to 10 iterations, for gregorian months it's normally <=3.\n    while (cnt < 10) {\n      t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);\n      if ((t1 - r0) * (t0 - r0) <= 0) {\n        // t1 and t0 are on opposite sides of r0! we've succeeded!\n        if (axrev) return Math.min(t0, t1);\n        return Math.max(t0, t1);\n      }\n      mult = (r0 - (t0 + t1) / 2) / (t1 - t0);\n      newDTick = tType + (Math.abs(Math.round(mult)) || 1) * dtNum;\n      t0 = axes.tickIncrement(t0, newDTick, mult < 0 ? !axrev : axrev, ax.calendar);\n      cnt++;\n    }\n    Lib.error('tickFirst did not converge', ax);\n    return t0;\n  } else if (tType === 'L') {\n    // Log scales: Linear, Digits\n\n    return Math.log(sRound((Math.pow(10, r0) - tick0) / dtNum) * dtNum + tick0) / Math.LN10;\n  } else if (tType === 'D') {\n    var tickset = dtick === 'D2' ? roundLog2 : roundLog1;\n    var frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);\n    return Math.floor(r0) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n  } else throw 'unrecognized dtick ' + String(dtick);\n};\n\n// draw the text for one tick.\n// px,py are the location on gd.paper\n// prefix is there so the x axis ticks can be dropped a line\n// ax is the axis layout, x is the tick value\n// hover is a (truthy) flag for whether to show numbers with a bit\n// more precision for hovertext\naxes.tickText = function (ax, x, hover, noSuffixPrefix) {\n  var out = tickTextObj(ax, x);\n  var arrayMode = ax.tickmode === 'array';\n  var extraPrecision = hover || arrayMode;\n  var axType = ax.type;\n  // TODO multicategory, if we allow ticktext / tickvals\n  var tickVal2l = axType === 'category' ? ax.d2l_noadd : ax.d2l;\n  var i;\n  var inbounds = function (v) {\n    var p = ax.l2p(v);\n    return p >= 0 && p <= ax._length ? v : null;\n  };\n  if (arrayMode && Lib.isArrayOrTypedArray(ax.ticktext)) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    var minDiff = (Math.abs(rng[1] - rng[0]) - (ax._lBreaks || 0)) / 10000;\n    for (i = 0; i < ax.ticktext.length; i++) {\n      if (Math.abs(x - tickVal2l(ax.tickvals[i])) < minDiff) break;\n    }\n    if (i < ax.ticktext.length) {\n      out.text = String(ax.ticktext[i]);\n      out.xbnd = [inbounds(out.x - 0.5), inbounds(out.x + ax.dtick - 0.5)];\n      return out;\n    }\n  }\n  function isHidden(showAttr) {\n    if (showAttr === undefined) return true;\n    if (hover) return showAttr === 'none';\n    var firstOrLast = {\n      first: ax._tmin,\n      last: ax._tmax\n    }[showAttr];\n    return showAttr !== 'all' && x !== firstOrLast;\n  }\n  var hideexp = hover ? 'never' : ax.exponentformat !== 'none' && isHidden(ax.showexponent) ? 'hide' : '';\n  if (axType === 'date') formatDate(ax, out, hover, extraPrecision);else if (axType === 'log') formatLog(ax, out, hover, extraPrecision, hideexp);else if (axType === 'category') formatCategory(ax, out);else if (axType === 'multicategory') formatMultiCategory(ax, out, hover);else if (isAngular(ax)) formatAngle(ax, out, hover, extraPrecision, hideexp);else formatLinear(ax, out, hover, extraPrecision, hideexp);\n\n  // add prefix and suffix\n  if (!noSuffixPrefix) {\n    if (ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;\n    if (ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;\n  }\n  if (ax.labelalias && ax.labelalias.hasOwnProperty(out.text)) {\n    var t = ax.labelalias[out.text];\n    if (typeof t === 'string') out.text = t;\n  }\n\n  // Setup ticks and grid lines boundaries\n  // at 1/2 a 'category' to the left/bottom\n  if (ax.tickson === 'boundaries' || ax.showdividers) {\n    out.xbnd = [inbounds(out.x - 0.5), inbounds(out.x + ax.dtick - 0.5)];\n  }\n  return out;\n};\n\n/**\n * create text for a hover label on this axis, with special handling of\n * log axes (where negative values can't be displayed but can appear in hover text)\n *\n * @param {object} ax: the axis to format text for\n * @param {number or array of numbers} values: calcdata value(s) to format\n * @param {Optional(string)} hoverformat: trace (x|y)hoverformat to override axis.hoverformat\n *\n * @returns {string} `val` formatted as a string appropriate to this axis, or\n *     first value and second value as a range (ie '<val1> - <val2>') if the second value is provided and\n *     it's different from the first value.\n */\naxes.hoverLabelText = function (ax, values, hoverformat) {\n  if (hoverformat) ax = Lib.extendFlat({}, ax, {\n    hoverformat: hoverformat\n  });\n  var val = Lib.isArrayOrTypedArray(values) ? values[0] : values;\n  var val2 = Lib.isArrayOrTypedArray(values) ? values[1] : undefined;\n  if (val2 !== undefined && val2 !== val) {\n    return axes.hoverLabelText(ax, val, hoverformat) + ' - ' + axes.hoverLabelText(ax, val2, hoverformat);\n  }\n  var logOffScale = ax.type === 'log' && val <= 0;\n  var tx = axes.tickText(ax, ax.c2l(logOffScale ? -val : val), 'hover').text;\n  if (logOffScale) {\n    return val === 0 ? '0' : MINUS_SIGN + tx;\n  }\n\n  // TODO: should we do something special if the axis calendar and\n  // the data calendar are different? Somehow display both dates with\n  // their system names? Right now it will just display in the axis calendar\n  // but users could add the other one as text.\n  return tx;\n};\nfunction tickTextObj(ax, x, text) {\n  var tf = ax.tickfont || {};\n  return {\n    x: x,\n    dx: 0,\n    dy: 0,\n    text: text || '',\n    fontSize: tf.size,\n    font: tf.family,\n    fontColor: tf.color\n  };\n}\nfunction formatDate(ax, out, hover, extraPrecision) {\n  var tr = ax._tickround;\n  var fmt = hover && ax.hoverformat || axes.getTickFormat(ax);\n\n  // Only apply extra precision if no explicit format was provided.\n  extraPrecision = !fmt && extraPrecision;\n  if (extraPrecision) {\n    // second or sub-second precision: extra always shows max digits.\n    // for other fields, extra precision just adds one field.\n    if (isNumeric(tr)) tr = 4;else tr = {\n      y: 'm',\n      m: 'd',\n      d: 'M',\n      M: 'S',\n      S: 4\n    }[tr];\n  }\n  var dateStr = Lib.formatDate(out.x, fmt, tr, ax._dateFormat, ax.calendar, ax._extraFormat);\n  var headStr;\n  var splitIndex = dateStr.indexOf('\\n');\n  if (splitIndex !== -1) {\n    headStr = dateStr.substr(splitIndex + 1);\n    dateStr = dateStr.substr(0, splitIndex);\n  }\n  if (extraPrecision) {\n    // if extraPrecision led to trailing zeros, strip them off\n    // actually, this can lead to removing even more zeros than\n    // in the original rounding, but that's fine because in these\n    // contexts uniformity is not so important (if there's even\n    // anything to be uniform with!)\n\n    // can we remove the whole time part?\n    if (headStr !== undefined && (dateStr === '00:00:00' || dateStr === '00:00')) {\n      dateStr = headStr;\n      headStr = '';\n    } else if (dateStr.length === 8) {\n      // strip off seconds if they're zero (zero fractional seconds\n      // are already omitted)\n      // but we never remove minutes and leave just hours\n      dateStr = dateStr.replace(/:00$/, '');\n    }\n  }\n  if (headStr) {\n    if (hover) {\n      // hover puts it all on one line, so headPart works best up front\n      // except for year headPart: turn this into \"Jan 1, 2000\" etc.\n      if (tr === 'd') dateStr += ', ' + headStr;else dateStr = headStr + (dateStr ? ', ' + dateStr : '');\n    } else {\n      if (!ax._inCalcTicks || ax._prevDateHead !== headStr) {\n        ax._prevDateHead = headStr;\n        dateStr += '<br>' + headStr;\n      } else {\n        var isInside = insideTicklabelposition(ax);\n        var side = ax._trueSide || ax.side; // polar mocks the side of the radial axis\n        if (!isInside && side === 'top' || isInside && side === 'bottom') {\n          dateStr += '<br> ';\n        }\n      }\n    }\n  }\n  out.text = dateStr;\n}\nfunction formatLog(ax, out, hover, extraPrecision, hideexp) {\n  var dtick = ax.dtick;\n  var x = out.x;\n  var tickformat = ax.tickformat;\n  var dtChar0 = typeof dtick === 'string' && dtick.charAt(0);\n  if (hideexp === 'never') {\n    // If this is a hover label, then we must *never* hide the exponent\n    // for the sake of display, which could give the wrong value by\n    // potentially many orders of magnitude. If hideexp was 'never', then\n    // it's now succeeded by preventing the other condition from automating\n    // this choice. Thus we can unset it so that the axis formatting takes\n    // precedence.\n    hideexp = '';\n  }\n  if (extraPrecision && dtChar0 !== 'L') {\n    dtick = 'L3';\n    dtChar0 = 'L';\n  }\n  if (tickformat || dtChar0 === 'L') {\n    out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);\n  } else if (isNumeric(dtick) || dtChar0 === 'D' && Lib.mod(x + 0.01, 1) < 0.1) {\n    var p = Math.round(x);\n    var absP = Math.abs(p);\n    var exponentFormat = ax.exponentformat;\n    if (exponentFormat === 'power' || isSIFormat(exponentFormat) && beyondSI(p)) {\n      if (p === 0) out.text = 1;else if (p === 1) out.text = '10';else out.text = '10<sup>' + (p > 1 ? '' : MINUS_SIGN) + absP + '</sup>';\n      out.fontSize *= 1.25;\n    } else if ((exponentFormat === 'e' || exponentFormat === 'E') && absP > 2) {\n      out.text = '1' + exponentFormat + (p > 0 ? '+' : MINUS_SIGN) + absP;\n    } else {\n      out.text = numFormat(Math.pow(10, x), ax, '', 'fakehover');\n      if (dtick === 'D1' && ax._id.charAt(0) === 'y') {\n        out.dy -= out.fontSize / 6;\n      }\n    }\n  } else if (dtChar0 === 'D') {\n    out.text = String(Math.round(Math.pow(10, Lib.mod(x, 1))));\n    out.fontSize *= 0.75;\n  } else throw 'unrecognized dtick ' + String(dtick);\n\n  // if 9's are printed on log scale, move the 10's away a bit\n  if (ax.dtick === 'D1') {\n    var firstChar = String(out.text).charAt(0);\n    if (firstChar === '0' || firstChar === '1') {\n      if (ax._id.charAt(0) === 'y') {\n        out.dx -= out.fontSize / 4;\n      } else {\n        out.dy += out.fontSize / 2;\n        out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) * out.fontSize * (x < 0 ? 0.5 : 0.25);\n      }\n    }\n  }\n}\nfunction formatCategory(ax, out) {\n  var tt = ax._categories[Math.round(out.x)];\n  if (tt === undefined) tt = '';\n  out.text = String(tt);\n}\nfunction formatMultiCategory(ax, out, hover) {\n  var v = Math.round(out.x);\n  var cats = ax._categories[v] || [];\n  var tt = cats[1] === undefined ? '' : String(cats[1]);\n  var tt2 = cats[0] === undefined ? '' : String(cats[0]);\n  if (hover) {\n    // TODO is this what we want?\n    out.text = tt2 + ' - ' + tt;\n  } else {\n    // setup for secondary labels\n    out.text = tt;\n    out.text2 = tt2;\n  }\n}\nfunction formatLinear(ax, out, hover, extraPrecision, hideexp) {\n  if (hideexp === 'never') {\n    // If this is a hover label, then we must *never* hide the exponent\n    // for the sake of display, which could give the wrong value by\n    // potentially many orders of magnitude. If hideexp was 'never', then\n    // it's now succeeded by preventing the other condition from automating\n    // this choice. Thus we can unset it so that the axis formatting takes\n    // precedence.\n    hideexp = '';\n  } else if (ax.showexponent === 'all' && Math.abs(out.x / ax.dtick) < 1e-6) {\n    // don't add an exponent to zero if we're showing all exponents\n    // so the only reason you'd show an exponent on zero is if it's the\n    // ONLY tick to get an exponent (first or last)\n    hideexp = 'hide';\n  }\n  out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n}\nfunction formatAngle(ax, out, hover, extraPrecision, hideexp) {\n  if (ax.thetaunit === 'radians' && !hover) {\n    var num = out.x / 180;\n    if (num === 0) {\n      out.text = '0';\n    } else {\n      var frac = num2frac(num);\n      if (frac[1] >= 100) {\n        out.text = numFormat(Lib.deg2rad(out.x), ax, hideexp, extraPrecision);\n      } else {\n        var isNeg = out.x < 0;\n        if (frac[1] === 1) {\n          if (frac[0] === 1) out.text = 'π';else out.text = frac[0] + 'π';\n        } else {\n          out.text = ['<sup>', frac[0], '</sup>', '⁄', '<sub>', frac[1], '</sub>', 'π'].join('');\n        }\n        if (isNeg) out.text = MINUS_SIGN + out.text;\n      }\n    }\n  } else {\n    out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n  }\n}\n\n// inspired by\n// https://github.com/yisibl/num2fraction/blob/master/index.js\nfunction num2frac(num) {\n  function almostEq(a, b) {\n    return Math.abs(a - b) <= 1e-6;\n  }\n  function findGCD(a, b) {\n    return almostEq(b, 0) ? a : findGCD(b, a % b);\n  }\n  function findPrecision(n) {\n    var e = 1;\n    while (!almostEq(Math.round(n * e) / e, n)) {\n      e *= 10;\n    }\n    return e;\n  }\n  var precision = findPrecision(num);\n  var number = num * precision;\n  var gcd = Math.abs(findGCD(number, precision));\n  return [\n  // numerator\n  Math.round(number / gcd),\n  // denominator\n  Math.round(precision / gcd)];\n}\n\n// format a number (tick value) according to the axis settings\n// new, more reliable procedure than d3.round or similar:\n// add half the rounding increment, then stringify and truncate\n// also automatically switch to sci. notation\nvar SIPREFIXES = ['f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T'];\nfunction isSIFormat(exponentFormat) {\n  return exponentFormat === 'SI' || exponentFormat === 'B';\n}\n\n// are we beyond the range of common SI prefixes?\n// 10^-16 -> 1x10^-16\n// 10^-15 -> 1f\n// ...\n// 10^14 -> 100T\n// 10^15 -> 1x10^15\n// 10^16 -> 1x10^16\nfunction beyondSI(exponent) {\n  return exponent > 14 || exponent < -15;\n}\nfunction numFormat(v, ax, fmtoverride, hover) {\n  var isNeg = v < 0;\n  // max number of digits past decimal point to show\n  var tickRound = ax._tickround;\n  var exponentFormat = fmtoverride || ax.exponentformat || 'B';\n  var exponent = ax._tickexponent;\n  var tickformat = axes.getTickFormat(ax);\n  var separatethousands = ax.separatethousands;\n\n  // special case for hover: set exponent just for this value, and\n  // add a couple more digits of precision over tick labels\n  if (hover) {\n    // make a dummy axis obj to get the auto rounding and exponent\n    var ah = {\n      exponentformat: exponentFormat,\n      minexponent: ax.minexponent,\n      dtick: ax.showexponent === 'none' ? ax.dtick : isNumeric(v) ? Math.abs(v) || 1 : 1,\n      // if not showing any exponents, don't change the exponent\n      // from what we calculate\n      range: ax.showexponent === 'none' ? ax.range.map(ax.r2d) : [0, v || 1]\n    };\n    autoTickRound(ah);\n    tickRound = (Number(ah._tickround) || 0) + 4;\n    exponent = ah._tickexponent;\n    if (ax.hoverformat) tickformat = ax.hoverformat;\n  }\n  if (tickformat) return ax._numFormat(tickformat)(v).replace(/-/g, MINUS_SIGN);\n\n  // 'epsilon' - rounding increment\n  var e = Math.pow(10, -tickRound) / 2;\n\n  // exponentFormat codes:\n  // 'e' (1.2e+6, default)\n  // 'E' (1.2E+6)\n  // 'SI' (1.2M)\n  // 'B' (same as SI except 10^9=B not G)\n  // 'none' (1200000)\n  // 'power' (1.2x10^6)\n  // 'hide' (1.2, use 3rd argument=='hide' to eg\n  //      only show exponent on last tick)\n  if (exponentFormat === 'none') exponent = 0;\n\n  // take the sign out, put it back manually at the end\n  // - makes cases easier\n  v = Math.abs(v);\n  if (v < e) {\n    // 0 is just 0, but may get exponent if it's the last tick\n    v = '0';\n    isNeg = false;\n  } else {\n    v += e;\n    // take out a common exponent, if any\n    if (exponent) {\n      v *= Math.pow(10, -exponent);\n      tickRound += exponent;\n    }\n    // round the mantissa\n    if (tickRound === 0) v = String(Math.floor(v));else if (tickRound < 0) {\n      v = String(Math.round(v));\n      v = v.substr(0, v.length + tickRound);\n      for (var i = tickRound; i < 0; i++) v += '0';\n    } else {\n      v = String(v);\n      var dp = v.indexOf('.') + 1;\n      if (dp) v = v.substr(0, dp + tickRound).replace(/\\.?0+$/, '');\n    }\n    // insert appropriate decimal point and thousands separator\n    v = Lib.numSeparate(v, ax._separators, separatethousands);\n  }\n\n  // add exponent\n  if (exponent && exponentFormat !== 'hide') {\n    if (isSIFormat(exponentFormat) && beyondSI(exponent)) exponentFormat = 'power';\n    var signedExponent;\n    if (exponent < 0) signedExponent = MINUS_SIGN + -exponent;else if (exponentFormat !== 'power') signedExponent = '+' + exponent;else signedExponent = String(exponent);\n    if (exponentFormat === 'e' || exponentFormat === 'E') {\n      v += exponentFormat + signedExponent;\n    } else if (exponentFormat === 'power') {\n      v += '×10<sup>' + signedExponent + '</sup>';\n    } else if (exponentFormat === 'B' && exponent === 9) {\n      v += 'B';\n    } else if (isSIFormat(exponentFormat)) {\n      v += SIPREFIXES[exponent / 3 + 5];\n    }\n  }\n\n  // put sign back in and return\n  // replace standard minus character (which is technically a hyphen)\n  // with a true minus sign\n  if (isNeg) return MINUS_SIGN + v;\n  return v;\n}\naxes.getTickFormat = function (ax) {\n  var i;\n  function convertToMs(dtick) {\n    return typeof dtick !== 'string' ? dtick : Number(dtick.replace('M', '')) * ONEAVGMONTH;\n  }\n  function compareLogTicks(left, right) {\n    var priority = ['L', 'D'];\n    if (typeof left === typeof right) {\n      if (typeof left === 'number') {\n        return left - right;\n      } else {\n        var leftPriority = priority.indexOf(left.charAt(0));\n        var rightPriority = priority.indexOf(right.charAt(0));\n        if (leftPriority === rightPriority) {\n          return Number(left.replace(/(L|D)/g, '')) - Number(right.replace(/(L|D)/g, ''));\n        } else {\n          return leftPriority - rightPriority;\n        }\n      }\n    } else {\n      return typeof left === 'number' ? 1 : -1;\n    }\n  }\n  function isProperStop(dtick, range, convert) {\n    var convertFn = convert || function (x) {\n      return x;\n    };\n    var leftDtick = range[0];\n    var rightDtick = range[1];\n    return (!leftDtick && typeof leftDtick !== 'number' || convertFn(leftDtick) <= convertFn(dtick)) && (!rightDtick && typeof rightDtick !== 'number' || convertFn(rightDtick) >= convertFn(dtick));\n  }\n  function isProperLogStop(dtick, range) {\n    var isLeftDtickNull = range[0] === null;\n    var isRightDtickNull = range[1] === null;\n    var isDtickInRangeLeft = compareLogTicks(dtick, range[0]) >= 0;\n    var isDtickInRangeRight = compareLogTicks(dtick, range[1]) <= 0;\n    return (isLeftDtickNull || isDtickInRangeLeft) && (isRightDtickNull || isDtickInRangeRight);\n  }\n  var tickstop, stopi;\n  if (ax.tickformatstops && ax.tickformatstops.length > 0) {\n    switch (ax.type) {\n      case 'date':\n      case 'linear':\n        {\n          for (i = 0; i < ax.tickformatstops.length; i++) {\n            stopi = ax.tickformatstops[i];\n            if (stopi.enabled && isProperStop(ax.dtick, stopi.dtickrange, convertToMs)) {\n              tickstop = stopi;\n              break;\n            }\n          }\n          break;\n        }\n      case 'log':\n        {\n          for (i = 0; i < ax.tickformatstops.length; i++) {\n            stopi = ax.tickformatstops[i];\n            if (stopi.enabled && isProperLogStop(ax.dtick, stopi.dtickrange)) {\n              tickstop = stopi;\n              break;\n            }\n          }\n          break;\n        }\n      default:\n    }\n  }\n  return tickstop ? tickstop.value : ax.tickformat;\n};\n\n// getSubplots - extract all subplot IDs we need\n// as an array of items like 'xy', 'x2y', 'x2y2'...\n// sorted by x (x,x2,x3...) then y\n// optionally restrict to only subplots containing axis object ax\n//\n// NOTE: this is currently only used OUTSIDE plotly.js (toolpanel, webapp)\n// ideally we get rid of it there (or just copy this there) and remove it here\naxes.getSubplots = function (gd, ax) {\n  var subplotObj = gd._fullLayout._subplots;\n  var allSubplots = subplotObj.cartesian.concat(subplotObj.gl2d || []);\n  var out = ax ? axes.findSubplotsWithAxis(allSubplots, ax) : allSubplots;\n  out.sort(function (a, b) {\n    var aParts = a.substr(1).split('y');\n    var bParts = b.substr(1).split('y');\n    if (aParts[0] === bParts[0]) return +aParts[1] - +bParts[1];\n    return +aParts[0] - +bParts[0];\n  });\n  return out;\n};\n\n// find all subplots with axis 'ax'\n// NOTE: this is only used in axes.getSubplots (only used outside plotly.js) and\n// gl2d/convert (where it restricts axis subplots to only those with gl2d)\naxes.findSubplotsWithAxis = function (subplots, ax) {\n  var axMatch = new RegExp(ax._id.charAt(0) === 'x' ? '^' + ax._id + 'y' : ax._id + '$');\n  var subplotsWithAx = [];\n  for (var i = 0; i < subplots.length; i++) {\n    var sp = subplots[i];\n    if (axMatch.test(sp)) subplotsWithAx.push(sp);\n  }\n  return subplotsWithAx;\n};\n\n// makeClipPaths: prepare clipPaths for all single axes and all possible xy pairings\naxes.makeClipPaths = function (gd) {\n  var fullLayout = gd._fullLayout;\n\n  // for more info: https://github.com/plotly/plotly.js/issues/2595\n  if (fullLayout._hasOnlyLargeSploms) return;\n  var fullWidth = {\n    _offset: 0,\n    _length: fullLayout.width,\n    _id: ''\n  };\n  var fullHeight = {\n    _offset: 0,\n    _length: fullLayout.height,\n    _id: ''\n  };\n  var xaList = axes.list(gd, 'x', true);\n  var yaList = axes.list(gd, 'y', true);\n  var clipList = [];\n  var i, j;\n  for (i = 0; i < xaList.length; i++) {\n    clipList.push({\n      x: xaList[i],\n      y: fullHeight\n    });\n    for (j = 0; j < yaList.length; j++) {\n      if (i === 0) clipList.push({\n        x: fullWidth,\n        y: yaList[j]\n      });\n      clipList.push({\n        x: xaList[i],\n        y: yaList[j]\n      });\n    }\n  }\n\n  // selectors don't work right with camelCase tags,\n  // have to use class instead\n  // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I\n  var axClips = fullLayout._clips.selectAll('.axesclip').data(clipList, function (d) {\n    return d.x._id + d.y._id;\n  });\n  axClips.enter().append('clipPath').classed('axesclip', true).attr('id', function (d) {\n    return 'clip' + fullLayout._uid + d.x._id + d.y._id;\n  }).append('rect');\n  axClips.exit().remove();\n  axClips.each(function (d) {\n    d3.select(this).select('rect').attr({\n      x: d.x._offset || 0,\n      y: d.y._offset || 0,\n      width: d.x._length || 1,\n      height: d.y._length || 1\n    });\n  });\n};\n\n/**\n * Main multi-axis drawing routine!\n *\n * @param {DOM element} gd : graph div\n * @param {string or array of strings} arg : polymorphic argument\n * @param {object} opts:\n * - @param {boolean} skipTitle : optional flag to skip axis title draw/update\n *\n * Signature 1: Axes.draw(gd, 'redraw')\n *   use this to clear and redraw all axes on graph\n *\n * Signature 2: Axes.draw(gd, '')\n *   use this to draw all axes on graph w/o the selectAll().remove()\n *   of the 'redraw' signature\n *\n * Signature 3: Axes.draw(gd, [axId, axId2, ...])\n *   where the items are axis id string,\n *   use this to update multiple axes in one call\n *\n * N.B draw updates:\n * - ax._r (stored range for use by zoom/pan)\n * - ax._rl (stored linearized range for use by zoom/pan)\n */\naxes.draw = function (gd, arg, opts) {\n  var fullLayout = gd._fullLayout;\n  if (arg === 'redraw') {\n    fullLayout._paper.selectAll('g.subplot').each(function (d) {\n      var id = d[0];\n      var plotinfo = fullLayout._plots[id];\n      if (plotinfo) {\n        var xa = plotinfo.xaxis;\n        var ya = plotinfo.yaxis;\n        plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick').remove();\n        plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick').remove();\n        plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick2').remove();\n        plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick2').remove();\n        plotinfo.xaxislayer.selectAll('.' + xa._id + 'divider').remove();\n        plotinfo.yaxislayer.selectAll('.' + ya._id + 'divider').remove();\n        if (plotinfo.minorGridlayer) plotinfo.minorGridlayer.selectAll('path').remove();\n        if (plotinfo.gridlayer) plotinfo.gridlayer.selectAll('path').remove();\n        if (plotinfo.zerolinelayer) plotinfo.zerolinelayer.selectAll('path').remove();\n        fullLayout._infolayer.select('.g-' + xa._id + 'title').remove();\n        fullLayout._infolayer.select('.g-' + ya._id + 'title').remove();\n      }\n    });\n  }\n  var axList = !arg || arg === 'redraw' ? axes.listIds(gd) : arg;\n  var fullAxList = axes.list(gd);\n  // Get the list of the overlaying axis for all 'shift' axes\n  var overlayingShiftedAx = fullAxList.filter(function (ax) {\n    return ax.autoshift;\n  }).map(function (ax) {\n    return ax.overlaying;\n  });\n\n  // order axes that have dependency to other axes\n  axList.map(function (axId) {\n    var ax = axes.getFromId(gd, axId);\n    if (ax.tickmode === 'sync' && ax.overlaying) {\n      var overlayingIndex = axList.findIndex(function (axis) {\n        return axis === ax.overlaying;\n      });\n      if (overlayingIndex >= 0) {\n        axList.unshift(axList.splice(overlayingIndex, 1).shift());\n      }\n    }\n  });\n  var axShifts = {\n    false: {\n      left: 0,\n      right: 0\n    }\n  };\n  return Lib.syncOrAsync(axList.map(function (axId) {\n    return function () {\n      if (!axId) return;\n      var ax = axes.getFromId(gd, axId);\n      if (!opts) opts = {};\n      opts.axShifts = axShifts;\n      opts.overlayingShiftedAx = overlayingShiftedAx;\n      var axDone = axes.drawOne(gd, ax, opts);\n      if (ax._shiftPusher) {\n        incrementShift(ax, ax._fullDepth || 0, axShifts, true);\n      }\n      ax._r = ax.range.slice();\n      ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n      return axDone;\n    };\n  }));\n};\n\n/**\n * Draw one cartesian axis\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n * @param {object} opts\n * - @param {boolean} skipTitle (set to true to skip axis title draw call)\n *\n * Depends on:\n * - ax._mainSubplot (from linkSubplots)\n * - ax._mainAxis\n * - ax._anchorAxis\n * - ax._subplotsWith\n * - ax._counterDomainMin, ax._counterDomainMax (optionally, from linkSubplots)\n * - ax._tickAngles (on redraw only, old value relinked during supplyDefaults)\n * - ax._mainLinePosition (from lsInner)\n * - ax._mainMirrorPosition\n * - ax._linepositions\n *\n * Fills in:\n * - ax._vals:\n * - ax._gridVals:\n * - ax._selections:\n * - ax._tickAngles:\n * - ax._depth (when required only):\n * - and calls ax.setScale\n */\naxes.drawOne = function (gd, ax, opts) {\n  opts = opts || {};\n  var axShifts = opts.axShifts || {};\n  var overlayingShiftedAx = opts.overlayingShiftedAx || [];\n  var i, sp, plotinfo;\n  ax.setScale();\n  var fullLayout = gd._fullLayout;\n  var axId = ax._id;\n  var axLetter = axId.charAt(0);\n  var counterLetter = axes.counterLetter(axId);\n  var mainPlotinfo = fullLayout._plots[ax._mainSubplot];\n\n  // this happens when updating matched group with 'missing' axes\n  if (!mainPlotinfo) return;\n  ax._shiftPusher = ax.autoshift || overlayingShiftedAx.indexOf(ax._id) !== -1 || overlayingShiftedAx.indexOf(ax.overlaying) !== -1;\n  // An axis is also shifted by 1/2 of its own linewidth and inside tick length if applicable\n  // as well as its manually specified `shift` val if we're in the context of `autoshift`\n  if (ax._shiftPusher & ax.anchor === 'free') {\n    var selfPush = ax.linewidth / 2 || 0;\n    if (ax.ticks === 'inside') {\n      selfPush += ax.ticklen;\n    }\n    incrementShift(ax, selfPush, axShifts, true);\n    incrementShift(ax, ax.shift || 0, axShifts, false);\n  }\n\n  // Somewhat inelegant way of making sure that the shift value is only updated when the\n  // Axes.DrawOne() function is called from the right context. An issue when redrawing the\n  // axis as result of using the dragbox, for example.\n  if (opts.skipTitle !== true || ax._shift === undefined) ax._shift = setShiftVal(ax, axShifts);\n  var mainAxLayer = mainPlotinfo[axLetter + 'axislayer'];\n  var mainLinePosition = ax._mainLinePosition;\n  var mainLinePositionShift = mainLinePosition += ax._shift;\n  var mainMirrorPosition = ax._mainMirrorPosition;\n  var vals = ax._vals = axes.calcTicks(ax);\n\n  // Add a couple of axis properties that should cause us to recreate\n  // elements. Used in d3 data function.\n  var axInfo = [ax.mirror, mainLinePositionShift, mainMirrorPosition].join('_');\n  for (i = 0; i < vals.length; i++) {\n    vals[i].axInfo = axInfo;\n  }\n\n  // stash selections to avoid DOM queries e.g.\n  // - stash tickLabels selection, so that drawTitle can use it to scoot title\n  ax._selections = {};\n  // stash tick angle (including the computed 'auto' values) per tick-label class\n  // linkup 'previous' tick angles on redraws\n  if (ax._tickAngles) ax._prevTickAngles = ax._tickAngles;\n  ax._tickAngles = {};\n  // measure [in px] between axis position and outward-most part of bounding box\n  // (touching either the tick label or ticks)\n  // depth can be expansive to compute, so we only do so when required\n  ax._depth = null;\n\n  // calcLabelLevelBbox can be expensive,\n  // so make sure to not call it twice during the same Axes.drawOne call\n  // by stashing label-level bounding boxes per tick-label class\n  var llbboxes = {};\n  function getLabelLevelBbox(suffix) {\n    var cls = axId + (suffix || 'tick');\n    if (!llbboxes[cls]) llbboxes[cls] = calcLabelLevelBbox(ax, cls, mainLinePositionShift);\n    return llbboxes[cls];\n  }\n  if (!ax.visible) return;\n  var transTickFn = axes.makeTransTickFn(ax);\n  var transTickLabelFn = axes.makeTransTickLabelFn(ax);\n  var tickVals;\n  // We remove zero lines, grid lines, and inside ticks if they're within 1px of the end\n  // The key case here is removing zero lines when the axis bound is zero\n  var valsClipped;\n  var insideTicks = ax.ticks === 'inside';\n  var outsideTicks = ax.ticks === 'outside';\n  if (ax.tickson === 'boundaries') {\n    var boundaryVals = getBoundaryVals(ax, vals);\n    valsClipped = axes.clipEnds(ax, boundaryVals);\n    tickVals = insideTicks ? valsClipped : boundaryVals;\n  } else {\n    valsClipped = axes.clipEnds(ax, vals);\n    tickVals = insideTicks && ax.ticklabelmode !== 'period' ? valsClipped : vals;\n  }\n  var gridVals = ax._gridVals = valsClipped;\n  var dividerVals = getDividerVals(ax, vals);\n  if (!fullLayout._hasOnlyLargeSploms) {\n    var subplotsWithAx = ax._subplotsWith;\n\n    // keep track of which subplots (by main counter axis) we've already\n    // drawn grids for, so we don't overdraw overlaying subplots\n    var finishedGrids = {};\n    for (i = 0; i < subplotsWithAx.length; i++) {\n      sp = subplotsWithAx[i];\n      plotinfo = fullLayout._plots[sp];\n      var counterAxis = plotinfo[counterLetter + 'axis'];\n      var mainCounterID = counterAxis._mainAxis._id;\n      if (finishedGrids[mainCounterID]) continue;\n      finishedGrids[mainCounterID] = 1;\n      var gridPath = axLetter === 'x' ? 'M0,' + counterAxis._offset + 'v' + counterAxis._length : 'M' + counterAxis._offset + ',0h' + counterAxis._length;\n      axes.drawGrid(gd, ax, {\n        vals: gridVals,\n        counterAxis: counterAxis,\n        layer: plotinfo.gridlayer.select('.' + axId),\n        minorLayer: plotinfo.minorGridlayer.select('.' + axId),\n        path: gridPath,\n        transFn: transTickFn\n      });\n      axes.drawZeroLine(gd, ax, {\n        counterAxis: counterAxis,\n        layer: plotinfo.zerolinelayer,\n        path: gridPath,\n        transFn: transTickFn\n      });\n    }\n  }\n  var tickPath;\n  var majorTickSigns = axes.getTickSigns(ax);\n  var minorTickSigns = axes.getTickSigns(ax, 'minor');\n  if (ax.ticks || ax.minor && ax.minor.ticks) {\n    var majorTickPath = axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[2]);\n    var minorTickPath = axes.makeTickPath(ax, mainLinePositionShift, minorTickSigns[2], {\n      minor: true\n    });\n    var mirrorMajorTickPath;\n    var mirrorMinorTickPath;\n    var fullMajorTickPath;\n    var fullMinorTickPath;\n    if (ax._anchorAxis && ax.mirror && ax.mirror !== true) {\n      mirrorMajorTickPath = axes.makeTickPath(ax, mainMirrorPosition, majorTickSigns[3]);\n      mirrorMinorTickPath = axes.makeTickPath(ax, mainMirrorPosition, minorTickSigns[3], {\n        minor: true\n      });\n      fullMajorTickPath = majorTickPath + mirrorMajorTickPath;\n      fullMinorTickPath = minorTickPath + mirrorMinorTickPath;\n    } else {\n      mirrorMajorTickPath = '';\n      mirrorMinorTickPath = '';\n      fullMajorTickPath = majorTickPath;\n      fullMinorTickPath = minorTickPath;\n    }\n    if (ax.showdividers && outsideTicks && ax.tickson === 'boundaries') {\n      var dividerLookup = {};\n      for (i = 0; i < dividerVals.length; i++) {\n        dividerLookup[dividerVals[i].x] = 1;\n      }\n      tickPath = function (d) {\n        return dividerLookup[d.x] ? mirrorMajorTickPath : fullMajorTickPath;\n      };\n    } else {\n      tickPath = function (d) {\n        return d.minor ? fullMinorTickPath : fullMajorTickPath;\n      };\n    }\n  }\n  axes.drawTicks(gd, ax, {\n    vals: tickVals,\n    layer: mainAxLayer,\n    path: tickPath,\n    transFn: transTickFn\n  });\n  if (ax.mirror === 'allticks') {\n    var tickSubplots = Object.keys(ax._linepositions || {});\n    for (i = 0; i < tickSubplots.length; i++) {\n      sp = tickSubplots[i];\n      plotinfo = fullLayout._plots[sp];\n      // [bottom or left, top or right], free and main are handled above\n      var linepositions = ax._linepositions[sp] || [];\n      var p0 = linepositions[0];\n      var p1 = linepositions[1];\n      var isMinor = linepositions[2];\n      var spTickPath = axes.makeTickPath(ax, p0, isMinor ? majorTickSigns[0] : minorTickSigns[0], {\n        minor: isMinor\n      }) + axes.makeTickPath(ax, p1, isMinor ? majorTickSigns[1] : minorTickSigns[1], {\n        minor: isMinor\n      });\n      axes.drawTicks(gd, ax, {\n        vals: tickVals,\n        layer: plotinfo[axLetter + 'axislayer'],\n        path: spTickPath,\n        transFn: transTickFn\n      });\n    }\n  }\n  var seq = [];\n\n  // tick labels - for now just the main labels.\n  // TODO: mirror labels, esp for subplots\n\n  seq.push(function () {\n    return axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: mainAxLayer,\n      plotinfo: plotinfo,\n      transFn: transTickLabelFn,\n      labelFns: axes.makeLabelFns(ax, mainLinePositionShift)\n    });\n  });\n  if (ax.type === 'multicategory') {\n    var pad = {\n      x: 2,\n      y: 10\n    }[axLetter];\n    seq.push(function () {\n      var bboxKey = {\n        x: 'height',\n        y: 'width'\n      }[axLetter];\n      var standoff = getLabelLevelBbox()[bboxKey] + pad + (ax._tickAngles[axId + 'tick'] ? ax.tickfont.size * LINE_SPACING : 0);\n      return axes.drawLabels(gd, ax, {\n        vals: getSecondaryLabelVals(ax, vals),\n        layer: mainAxLayer,\n        cls: axId + 'tick2',\n        repositionOnUpdate: true,\n        secondary: true,\n        transFn: transTickFn,\n        labelFns: axes.makeLabelFns(ax, mainLinePositionShift + standoff * majorTickSigns[4])\n      });\n    });\n    seq.push(function () {\n      ax._depth = majorTickSigns[4] * (getLabelLevelBbox('tick2')[ax.side] - mainLinePositionShift);\n      return drawDividers(gd, ax, {\n        vals: dividerVals,\n        layer: mainAxLayer,\n        path: axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[4], {\n          len: ax._depth\n        }),\n        transFn: transTickFn\n      });\n    });\n  } else if (ax.title.hasOwnProperty('standoff')) {\n    seq.push(function () {\n      ax._depth = majorTickSigns[4] * (getLabelLevelBbox()[ax.side] - mainLinePositionShift);\n    });\n  }\n  var hasRangeSlider = Registry.getComponentMethod('rangeslider', 'isVisible')(ax);\n  if (!opts.skipTitle && !(hasRangeSlider && ax.side === 'bottom')) {\n    seq.push(function () {\n      return drawTitle(gd, ax);\n    });\n  }\n  seq.push(function () {\n    var s = ax.side.charAt(0);\n    var sMirror = OPPOSITE_SIDE[ax.side].charAt(0);\n    var pos = axes.getPxPosition(gd, ax);\n    var outsideTickLen = outsideTicks ? ax.ticklen : 0;\n    var llbbox;\n    var push;\n    var mirrorPush;\n    var rangeSliderPush;\n    if (ax.automargin || hasRangeSlider || ax._shiftPusher) {\n      if (ax.type === 'multicategory') {\n        llbbox = getLabelLevelBbox('tick2');\n      } else {\n        llbbox = getLabelLevelBbox();\n        if (axLetter === 'x' && s === 'b') {\n          ax._depth = Math.max(llbbox.width > 0 ? llbbox.bottom - pos : 0, outsideTickLen);\n        }\n      }\n    }\n    var axDepth = 0;\n    var titleDepth = 0;\n    if (ax._shiftPusher) {\n      axDepth = Math.max(outsideTickLen, llbbox.height > 0 ? s === 'l' ? pos - llbbox.left : llbbox.right - pos : 0);\n      if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {\n        titleDepth = (ax._titleStandoff || 0) + (ax._titleScoot || 0);\n        if (s === 'l') {\n          titleDepth += approxTitleDepth(ax);\n        }\n      }\n      ax._fullDepth = Math.max(axDepth, titleDepth);\n    }\n    if (ax.automargin) {\n      push = {\n        x: 0,\n        y: 0,\n        r: 0,\n        l: 0,\n        t: 0,\n        b: 0\n      };\n      var domainIndices = [0, 1];\n      var shift = typeof ax._shift === 'number' ? ax._shift : 0;\n      if (axLetter === 'x') {\n        if (s === 'b') {\n          push[s] = ax._depth;\n        } else {\n          push[s] = ax._depth = Math.max(llbbox.width > 0 ? pos - llbbox.top : 0, outsideTickLen);\n          domainIndices.reverse();\n        }\n        if (llbbox.width > 0) {\n          var rExtra = llbbox.right - (ax._offset + ax._length);\n          if (rExtra > 0) {\n            push.xr = 1;\n            push.r = rExtra;\n          }\n          var lExtra = ax._offset - llbbox.left;\n          if (lExtra > 0) {\n            push.xl = 0;\n            push.l = lExtra;\n          }\n        }\n      } else {\n        if (s === 'l') {\n          ax._depth = Math.max(llbbox.height > 0 ? pos - llbbox.left : 0, outsideTickLen);\n          push[s] = ax._depth - shift;\n        } else {\n          ax._depth = Math.max(llbbox.height > 0 ? llbbox.right - pos : 0, outsideTickLen);\n          push[s] = ax._depth + shift;\n          domainIndices.reverse();\n        }\n        if (llbbox.height > 0) {\n          var bExtra = llbbox.bottom - (ax._offset + ax._length);\n          if (bExtra > 0) {\n            push.yb = 0;\n            push.b = bExtra;\n          }\n          var tExtra = ax._offset - llbbox.top;\n          if (tExtra > 0) {\n            push.yt = 1;\n            push.t = tExtra;\n          }\n        }\n      }\n      push[counterLetter] = ax.anchor === 'free' ? ax.position : ax._anchorAxis.domain[domainIndices[0]];\n      if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {\n        push[s] += approxTitleDepth(ax) + (ax.title.standoff || 0);\n      }\n      if (ax.mirror && ax.anchor !== 'free') {\n        mirrorPush = {\n          x: 0,\n          y: 0,\n          r: 0,\n          l: 0,\n          t: 0,\n          b: 0\n        };\n        mirrorPush[sMirror] = ax.linewidth;\n        if (ax.mirror && ax.mirror !== true) mirrorPush[sMirror] += outsideTickLen;\n        if (ax.mirror === true || ax.mirror === 'ticks') {\n          mirrorPush[counterLetter] = ax._anchorAxis.domain[domainIndices[1]];\n        } else if (ax.mirror === 'all' || ax.mirror === 'allticks') {\n          mirrorPush[counterLetter] = [ax._counterDomainMin, ax._counterDomainMax][domainIndices[1]];\n        }\n      }\n    }\n    if (hasRangeSlider) {\n      rangeSliderPush = Registry.getComponentMethod('rangeslider', 'autoMarginOpts')(gd, ax);\n    }\n    if (typeof ax.automargin === 'string') {\n      filterPush(push, ax.automargin);\n      filterPush(mirrorPush, ax.automargin);\n    }\n    Plots.autoMargin(gd, axAutoMarginID(ax), push);\n    Plots.autoMargin(gd, axMirrorAutoMarginID(ax), mirrorPush);\n    Plots.autoMargin(gd, rangeSliderAutoMarginID(ax), rangeSliderPush);\n  });\n  return Lib.syncOrAsync(seq);\n};\nfunction filterPush(push, automargin) {\n  if (!push) return;\n  var keepMargin = Object.keys(MARGIN_MAPPING).reduce(function (data, nextKey) {\n    if (automargin.indexOf(nextKey) !== -1) {\n      MARGIN_MAPPING[nextKey].forEach(function (key) {\n        data[key] = 1;\n      });\n    }\n    return data;\n  }, {});\n  Object.keys(push).forEach(function (key) {\n    if (!keepMargin[key]) {\n      if (key.length === 1) push[key] = 0;else delete push[key];\n    }\n  });\n}\nfunction getBoundaryVals(ax, vals) {\n  var out = [];\n  var i;\n\n  // boundaryVals are never used for labels;\n  // no need to worry about the other tickTextObj keys\n  var _push = function (d, bndIndex) {\n    var xb = d.xbnd[bndIndex];\n    if (xb !== null) {\n      out.push(Lib.extendFlat({}, d, {\n        x: xb\n      }));\n    }\n  };\n  if (vals.length) {\n    for (i = 0; i < vals.length; i++) {\n      _push(vals[i], 0);\n    }\n    _push(vals[i - 1], 1);\n  }\n  return out;\n}\nfunction getSecondaryLabelVals(ax, vals) {\n  var out = [];\n  var lookup = {};\n  for (var i = 0; i < vals.length; i++) {\n    var d = vals[i];\n    if (lookup[d.text2]) {\n      lookup[d.text2].push(d.x);\n    } else {\n      lookup[d.text2] = [d.x];\n    }\n  }\n  for (var k in lookup) {\n    out.push(tickTextObj(ax, Lib.interp(lookup[k], 0.5), k));\n  }\n  return out;\n}\nfunction getDividerVals(ax, vals) {\n  var out = [];\n  var i, current;\n  var reversed = vals.length && vals[vals.length - 1].x < vals[0].x;\n\n  // never used for labels;\n  // no need to worry about the other tickTextObj keys\n  var _push = function (d, bndIndex) {\n    var xb = d.xbnd[bndIndex];\n    if (xb !== null) {\n      out.push(Lib.extendFlat({}, d, {\n        x: xb\n      }));\n    }\n  };\n  if (ax.showdividers && vals.length) {\n    for (i = 0; i < vals.length; i++) {\n      var d = vals[i];\n      if (d.text2 !== current) {\n        _push(d, reversed ? 1 : 0);\n      }\n      current = d.text2;\n    }\n    _push(vals[i - 1], reversed ? 0 : 1);\n  }\n  return out;\n}\nfunction calcLabelLevelBbox(ax, cls, mainLinePositionShift) {\n  var top, bottom;\n  var left, right;\n  if (ax._selections[cls].size()) {\n    top = Infinity;\n    bottom = -Infinity;\n    left = Infinity;\n    right = -Infinity;\n    ax._selections[cls].each(function () {\n      var thisLabel = selectTickLabel(this);\n      // Use parent node <g.(x|y)tick>, to make Drawing.bBox\n      // retrieve a bbox computed with transform info\n      //\n      // To improve perf, it would be nice to use `thisLabel.node()`\n      // (like in fixLabelOverlaps) instead and use Axes.getPxPosition\n      // together with the makeLabelFns outputs and `tickangle`\n      // to compute one bbox per (tick value x tick style)\n      var bb = Drawing.bBox(thisLabel.node().parentNode);\n      top = Math.min(top, bb.top);\n      bottom = Math.max(bottom, bb.bottom);\n      left = Math.min(left, bb.left);\n      right = Math.max(right, bb.right);\n    });\n  } else {\n    var dummyCalc = axes.makeLabelFns(ax, mainLinePositionShift);\n    top = bottom = dummyCalc.yFn({\n      dx: 0,\n      dy: 0,\n      fontSize: 0\n    });\n    left = right = dummyCalc.xFn({\n      dx: 0,\n      dy: 0,\n      fontSize: 0\n    });\n  }\n  return {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right,\n    height: bottom - top,\n    width: right - left\n  };\n}\n\n/**\n * Which direction do the 'ax.side' values, and free ticks go?\n *\n * @param {object} ax (full) axis object\n *  - {string} _id (starting with 'x' or 'y')\n *  - {string} side\n *  - {string} ticks\n * @return {array} all entries are either -1 or 1\n *  - [0]: sign for top/right ticks (i.e. negative SVG direction)\n *  - [1]: sign for bottom/left ticks (i.e. positive SVG direction)\n *  - [2]: sign for ticks corresponding to 'ax.side'\n *  - [3]: sign for ticks mirroring 'ax.side'\n *  - [4]: sign of arrow starting at axis pointing towards margin\n */\naxes.getTickSigns = function (ax, minor) {\n  var axLetter = ax._id.charAt(0);\n  var sideOpposite = {\n    x: 'top',\n    y: 'right'\n  }[axLetter];\n  var main = ax.side === sideOpposite ? 1 : -1;\n  var out = [-1, 1, main, -main];\n  // then we flip if outside XOR y axis\n\n  var ticks = minor ? (ax.minor || {}).ticks : ax.ticks;\n  if (ticks !== 'inside' === (axLetter === 'x')) {\n    out = out.map(function (v) {\n      return -v;\n    });\n  }\n  // independent of `ticks`; do not flip this one\n  if (ax.side) {\n    out.push({\n      l: -1,\n      t: -1,\n      r: 1,\n      b: 1\n    }[ax.side.charAt(0)]);\n  }\n  return out;\n};\n\n/**\n * Make axis translate transform function\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} _offset\n *  - {fn} l2p\n * @return {fn} function of calcTicks items\n */\naxes.makeTransTickFn = function (ax) {\n  return ax._id.charAt(0) === 'x' ? function (d) {\n    return strTranslate(ax._offset + ax.l2p(d.x), 0);\n  } : function (d) {\n    return strTranslate(0, ax._offset + ax.l2p(d.x));\n  };\n};\naxes.makeTransTickLabelFn = function (ax) {\n  var uv = getTickLabelUV(ax);\n  var u = uv[0];\n  var v = uv[1];\n  return ax._id.charAt(0) === 'x' ? function (d) {\n    return strTranslate(u + ax._offset + ax.l2p(getPosX(d)), v);\n  } : function (d) {\n    return strTranslate(v, u + ax._offset + ax.l2p(getPosX(d)));\n  };\n};\nfunction getPosX(d) {\n  return d.periodX !== undefined ? d.periodX : d.x;\n}\n\n// u is a shift along the axis,\n// v is a shift perpendicular to the axis\nfunction getTickLabelUV(ax) {\n  var ticklabelposition = ax.ticklabelposition || '';\n  var has = function (str) {\n    return ticklabelposition.indexOf(str) !== -1;\n  };\n  var isTop = has('top');\n  var isLeft = has('left');\n  var isRight = has('right');\n  var isBottom = has('bottom');\n  var isInside = has('inside');\n  var isAligned = isBottom || isLeft || isTop || isRight;\n\n  // early return\n  if (!isAligned && !isInside) return [0, 0];\n  var side = ax.side;\n  var u = isAligned ? (ax.tickwidth || 0) / 2 : 0;\n  var v = TEXTPAD;\n  var fontSize = ax.tickfont ? ax.tickfont.size : 12;\n  if (isBottom || isTop) {\n    u += fontSize * CAP_SHIFT;\n    v += (ax.linewidth || 0) / 2;\n  }\n  if (isLeft || isRight) {\n    u += (ax.linewidth || 0) / 2;\n    v += TEXTPAD;\n  }\n  if (isInside && side === 'top') {\n    v -= fontSize * (1 - CAP_SHIFT);\n  }\n  if (isLeft || isTop) u = -u;\n  if (side === 'bottom' || side === 'right') v = -v;\n  return [isAligned ? u : 0, isInside ? v : 0];\n}\n\n/**\n * Make axis tick path string\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} ticklen\n *  - {number} linewidth\n * @param {number} shift along direction of ticklen\n * @param {1 or -1} sgn tick sign\n * @param {object} opts\n * - {number (optional)} len tick length\n * @return {string}\n */\naxes.makeTickPath = function (ax, shift, sgn, opts) {\n  if (!opts) opts = {};\n  var minor = opts.minor;\n  if (minor && !ax.minor) return '';\n  var len = opts.len !== undefined ? opts.len : minor ? ax.minor.ticklen : ax.ticklen;\n  var axLetter = ax._id.charAt(0);\n  var pad = (ax.linewidth || 1) / 2;\n  return axLetter === 'x' ? 'M0,' + (shift + pad * sgn) + 'v' + len * sgn : 'M' + (shift + pad * sgn) + ',0h' + len * sgn;\n};\n\n/**\n * Make axis tick label x, y and anchor functions\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} ticklen\n *  - {string} side\n *  - {number} linewidth\n *  - {number} tickfont.size\n *  - {boolean} showline\n * @param {number} shift\n * @param {number} angle [in degrees] ...\n * @return {object}\n *  - {fn} xFn\n *  - {fn} yFn\n *  - {fn} anchorFn\n *  - {fn} heightFn\n *  - {number} labelStandoff (gap parallel to ticks)\n *  - {number} labelShift (gap perpendicular to ticks)\n */\naxes.makeLabelFns = function (ax, shift, angle) {\n  var ticklabelposition = ax.ticklabelposition || '';\n  var has = function (str) {\n    return ticklabelposition.indexOf(str) !== -1;\n  };\n  var isTop = has('top');\n  var isLeft = has('left');\n  var isRight = has('right');\n  var isBottom = has('bottom');\n  var isAligned = isBottom || isLeft || isTop || isRight;\n  var insideTickLabels = has('inside');\n  var labelsOverTicks = ticklabelposition === 'inside' && ax.ticks === 'inside' || !insideTickLabels && ax.ticks === 'outside' && ax.tickson !== 'boundaries';\n  var labelStandoff = 0;\n  var labelShift = 0;\n  var tickLen = labelsOverTicks ? ax.ticklen : 0;\n  if (insideTickLabels) {\n    tickLen *= -1;\n  } else if (isAligned) {\n    tickLen = 0;\n  }\n  if (labelsOverTicks) {\n    labelStandoff += tickLen;\n    if (angle) {\n      var rad = Lib.deg2rad(angle);\n      labelStandoff = tickLen * Math.cos(rad) + 1;\n      labelShift = tickLen * Math.sin(rad);\n    }\n  }\n  if (ax.showticklabels && (labelsOverTicks || ax.showline)) {\n    labelStandoff += 0.2 * ax.tickfont.size;\n  }\n  labelStandoff += (ax.linewidth || 1) / 2 * (insideTickLabels ? -1 : 1);\n  var out = {\n    labelStandoff: labelStandoff,\n    labelShift: labelShift\n  };\n  var x0, y0, ff, flipIt;\n  var xQ = 0;\n  var side = ax.side;\n  var axLetter = ax._id.charAt(0);\n  var tickangle = ax.tickangle;\n  var endSide;\n  if (axLetter === 'x') {\n    endSide = !insideTickLabels && side === 'bottom' || insideTickLabels && side === 'top';\n    flipIt = endSide ? 1 : -1;\n    if (insideTickLabels) flipIt *= -1;\n    x0 = labelShift * flipIt;\n    y0 = shift + labelStandoff * flipIt;\n    ff = endSide ? 1 : -0.2;\n    if (Math.abs(tickangle) === 90) {\n      if (insideTickLabels) {\n        ff += MID_SHIFT;\n      } else {\n        if (tickangle === -90 && side === 'bottom') {\n          ff = CAP_SHIFT;\n        } else if (tickangle === 90 && side === 'top') {\n          ff = MID_SHIFT;\n        } else {\n          ff = 0.5;\n        }\n      }\n      xQ = MID_SHIFT / 2 * (tickangle / 90);\n    }\n    out.xFn = function (d) {\n      return d.dx + x0 + xQ * d.fontSize;\n    };\n    out.yFn = function (d) {\n      return d.dy + y0 + d.fontSize * ff;\n    };\n    out.anchorFn = function (d, a) {\n      if (isAligned) {\n        if (isLeft) return 'end';\n        if (isRight) return 'start';\n      }\n      if (!isNumeric(a) || a === 0 || a === 180) {\n        return 'middle';\n      }\n      return a * flipIt < 0 !== insideTickLabels ? 'end' : 'start';\n    };\n    out.heightFn = function (d, a, h) {\n      return a < -60 || a > 60 ? -0.5 * h : ax.side === 'top' !== insideTickLabels ? -h : 0;\n    };\n  } else if (axLetter === 'y') {\n    endSide = !insideTickLabels && side === 'left' || insideTickLabels && side === 'right';\n    flipIt = endSide ? 1 : -1;\n    if (insideTickLabels) flipIt *= -1;\n    x0 = labelStandoff;\n    y0 = labelShift * flipIt;\n    ff = 0;\n    if (!insideTickLabels && Math.abs(tickangle) === 90) {\n      if (tickangle === -90 && side === 'left' || tickangle === 90 && side === 'right') {\n        ff = CAP_SHIFT;\n      } else {\n        ff = 0.5;\n      }\n    }\n    if (insideTickLabels) {\n      var ang = isNumeric(tickangle) ? +tickangle : 0;\n      if (ang !== 0) {\n        var rA = Lib.deg2rad(ang);\n        xQ = Math.abs(Math.sin(rA)) * CAP_SHIFT * flipIt;\n        ff = 0;\n      }\n    }\n    out.xFn = function (d) {\n      return d.dx + shift - (x0 + d.fontSize * ff) * flipIt + xQ * d.fontSize;\n    };\n    out.yFn = function (d) {\n      return d.dy + y0 + d.fontSize * MID_SHIFT;\n    };\n    out.anchorFn = function (d, a) {\n      if (isNumeric(a) && Math.abs(a) === 90) {\n        return 'middle';\n      }\n      return endSide ? 'end' : 'start';\n    };\n    out.heightFn = function (d, a, h) {\n      if (ax.side === 'right') a *= -1;\n      return a < -30 ? -h : a < 30 ? -0.5 * h : 0;\n    };\n  }\n  return out;\n};\nfunction tickDataFn(d) {\n  return [d.text, d.x, d.axInfo, d.font, d.fontSize, d.fontColor].join('_');\n}\n\n/**\n * Draw axis ticks\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} linewidth\n *  - {string} tickcolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawTicks = function (gd, ax, opts) {\n  opts = opts || {};\n  var cls = ax._id + 'tick';\n  var vals = [].concat(ax.minor && ax.minor.ticks ?\n  // minor vals\n  opts.vals.filter(function (d) {\n    return d.minor && !d.noTick;\n  }) : []).concat(ax.ticks ?\n  // major vals\n  opts.vals.filter(function (d) {\n    return !d.minor && !d.noTick;\n  }) : []);\n  var ticks = opts.layer.selectAll('path.' + cls).data(vals, tickDataFn);\n  ticks.exit().remove();\n  ticks.enter().append('path').classed(cls, 1).classed('ticks', 1).classed('crisp', opts.crisp !== false).each(function (d) {\n    return Color.stroke(d3.select(this), d.minor ? ax.minor.tickcolor : ax.tickcolor);\n  }).style('stroke-width', function (d) {\n    return Drawing.crispRound(gd, d.minor ? ax.minor.tickwidth : ax.tickwidth, 1) + 'px';\n  }).attr('d', opts.path).style('display', null); // visible\n\n  hideCounterAxisInsideTickLabels(ax, [TICK_PATH]);\n  ticks.attr('transform', opts.transFn);\n};\n\n/**\n * Draw axis grid\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showgrid\n *  - {string} gridcolor\n *  - {string} gridwidth\n *  - {string} griddash\n *  - {boolean} zeroline\n *  - {string} type\n *  - {string} dtick\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n *     optional - only required if this axis supports zero lines\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawGrid = function (gd, ax, opts) {\n  opts = opts || {};\n  if (ax.tickmode === 'sync') {\n    // for tickmode sync we use the overlaying axis grid\n    return;\n  }\n  var cls = ax._id + 'grid';\n  var hasMinor = ax.minor && ax.minor.showgrid;\n  var minorVals = hasMinor ? opts.vals.filter(function (d) {\n    return d.minor;\n  }) : [];\n  var majorVals = ax.showgrid ? opts.vals.filter(function (d) {\n    return !d.minor;\n  }) : [];\n  var counterAx = opts.counterAxis;\n  if (counterAx && axes.shouldShowZeroLine(gd, ax, counterAx)) {\n    var isArrayMode = ax.tickmode === 'array';\n    for (var i = 0; i < majorVals.length; i++) {\n      var xi = majorVals[i].x;\n      if (isArrayMode ? !xi : Math.abs(xi) < ax.dtick / 100) {\n        majorVals = majorVals.slice(0, i).concat(majorVals.slice(i + 1));\n        // In array mode you can in principle have multiple\n        // ticks at 0, so test them all. Otherwise once we found\n        // one we can stop.\n        if (isArrayMode) i--;else break;\n      }\n    }\n  }\n  ax._gw = Drawing.crispRound(gd, ax.gridwidth, 1);\n  var wMinor = !hasMinor ? 0 : Drawing.crispRound(gd, ax.minor.gridwidth, 1);\n  var majorLayer = opts.layer;\n  var minorLayer = opts.minorLayer;\n  for (var major = 1; major >= 0; major--) {\n    var layer = major ? majorLayer : minorLayer;\n    if (!layer) continue;\n    var grid = layer.selectAll('path.' + cls).data(major ? majorVals : minorVals, tickDataFn);\n    grid.exit().remove();\n    grid.enter().append('path').classed(cls, 1).classed('crisp', opts.crisp !== false);\n    grid.attr('transform', opts.transFn).attr('d', opts.path).each(function (d) {\n      return Color.stroke(d3.select(this), d.minor ? ax.minor.gridcolor : ax.gridcolor || '#ddd');\n    }).style('stroke-dasharray', function (d) {\n      return Drawing.dashStyle(d.minor ? ax.minor.griddash : ax.griddash, d.minor ? ax.minor.gridwidth : ax.gridwidth);\n    }).style('stroke-width', function (d) {\n      return (d.minor ? wMinor : ax._gw) + 'px';\n    }).style('display', null); // visible\n\n    if (typeof opts.path === 'function') grid.attr('d', opts.path);\n  }\n  hideCounterAxisInsideTickLabels(ax, [GRID_PATH, MINORGRID_PATH]);\n};\n\n/**\n * Draw axis zero-line\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} zeroline\n *  - {number} zerolinewidth\n *  - {string} zerolinecolor\n *  - {number (optional)} _gridWidthCrispRound\n * @param {object} opts\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawZeroLine = function (gd, ax, opts) {\n  opts = opts || opts;\n  var cls = ax._id + 'zl';\n  var show = axes.shouldShowZeroLine(gd, ax, opts.counterAxis);\n  var zl = opts.layer.selectAll('path.' + cls).data(show ? [{\n    x: 0,\n    id: ax._id\n  }] : []);\n  zl.exit().remove();\n  zl.enter().append('path').classed(cls, 1).classed('zl', 1).classed('crisp', opts.crisp !== false).each(function () {\n    // use the fact that only one element can enter to trigger a sort.\n    // If several zerolines enter at the same time we will sort once per,\n    // but generally this should be a minimal overhead.\n    opts.layer.selectAll('path').sort(function (da, db) {\n      return idSort(da.id, db.id);\n    });\n  });\n  zl.attr('transform', opts.transFn).attr('d', opts.path).call(Color.stroke, ax.zerolinecolor || Color.defaultLine).style('stroke-width', Drawing.crispRound(gd, ax.zerolinewidth, ax._gw || 1) + 'px').style('display', null); // visible\n\n  hideCounterAxisInsideTickLabels(ax, [ZERO_PATH]);\n};\n\n/**\n * Draw axis tick labels\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showticklabels\n *  - {number} tickangle\n *  - {object (optional)} _selections\n *  - {object} (optional)} _tickAngles\n *  - {object} (optional)} _prevTickAngles\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string (optional)} cls (node className)\n * - {boolean} repositionOnUpdate (set to true to reposition update selection)\n * - {boolean} secondary\n * - {fn} transFn\n * - {object} labelFns\n *  + {fn} xFn\n *  + {fn} yFn\n *  + {fn} anchorFn\n *  + {fn} heightFn\n */\naxes.drawLabels = function (gd, ax, opts) {\n  opts = opts || {};\n  var fullLayout = gd._fullLayout;\n  var axId = ax._id;\n  var cls = opts.cls || axId + 'tick';\n  var vals = opts.vals.filter(function (d) {\n    return d.text;\n  });\n  var labelFns = opts.labelFns;\n  var tickAngle = opts.secondary ? 0 : ax.tickangle;\n  var prevAngle = (ax._prevTickAngles || {})[cls];\n  var tickLabels = opts.layer.selectAll('g.' + cls).data(ax.showticklabels ? vals : [], tickDataFn);\n  var labelsReady = [];\n  tickLabels.enter().append('g').classed(cls, 1).append('text')\n  // only so tex has predictable alignment that we can\n  // alter later\n  .attr('text-anchor', 'middle').each(function (d) {\n    var thisLabel = d3.select(this);\n    var newPromise = gd._promises.length;\n    thisLabel.call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d)).call(Drawing.font, d.font, d.fontSize, d.fontColor).text(d.text).call(svgTextUtils.convertToTspans, gd);\n    if (gd._promises[newPromise]) {\n      // if we have an async label, we'll deal with that\n      // all here so take it out of gd._promises and\n      // instead position the label and promise this in\n      // labelsReady\n      labelsReady.push(gd._promises.pop().then(function () {\n        positionLabels(thisLabel, tickAngle);\n      }));\n    } else {\n      // sync label: just position it now.\n      positionLabels(thisLabel, tickAngle);\n    }\n  });\n  hideCounterAxisInsideTickLabels(ax, [TICK_TEXT]);\n  tickLabels.exit().remove();\n  if (opts.repositionOnUpdate) {\n    tickLabels.each(function (d) {\n      d3.select(this).select('text').call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d));\n    });\n  }\n  function positionLabels(s, angle) {\n    s.each(function (d) {\n      var thisLabel = d3.select(this);\n      var mathjaxGroup = thisLabel.select('.text-math-group');\n      var anchor = labelFns.anchorFn(d, angle);\n      var transform = opts.transFn.call(thisLabel.node(), d) + (isNumeric(angle) && +angle !== 0 ? ' rotate(' + angle + ',' + labelFns.xFn(d) + ',' + (labelFns.yFn(d) - d.fontSize / 2) + ')' : '');\n\n      // how much to shift a multi-line label to center it vertically.\n      var nLines = svgTextUtils.lineCount(thisLabel);\n      var lineHeight = LINE_SPACING * d.fontSize;\n      var anchorHeight = labelFns.heightFn(d, isNumeric(angle) ? +angle : 0, (nLines - 1) * lineHeight);\n      if (anchorHeight) {\n        transform += strTranslate(0, anchorHeight);\n      }\n      if (mathjaxGroup.empty()) {\n        var thisText = thisLabel.select('text');\n        thisText.attr({\n          transform: transform,\n          'text-anchor': anchor\n        });\n        thisText.style('opacity', 1); // visible\n\n        if (ax._adjustTickLabelsOverflow) {\n          ax._adjustTickLabelsOverflow();\n        }\n      } else {\n        var mjWidth = Drawing.bBox(mathjaxGroup.node()).width;\n        var mjShift = mjWidth * {\n          end: -0.5,\n          start: 0.5\n        }[anchor];\n        mathjaxGroup.attr('transform', transform + strTranslate(mjShift, 0));\n      }\n    });\n  }\n  ax._adjustTickLabelsOverflow = function () {\n    var ticklabeloverflow = ax.ticklabeloverflow;\n    if (!ticklabeloverflow || ticklabeloverflow === 'allow') return;\n    var hideOverflow = ticklabeloverflow.indexOf('hide') !== -1;\n    var isX = ax._id.charAt(0) === 'x';\n    // div positions\n    var p0 = 0;\n    var p1 = isX ? gd._fullLayout.width : gd._fullLayout.height;\n    if (ticklabeloverflow.indexOf('domain') !== -1) {\n      // domain positions\n      var rl = Lib.simpleMap(ax.range, ax.r2l);\n      p0 = ax.l2p(rl[0]) + ax._offset;\n      p1 = ax.l2p(rl[1]) + ax._offset;\n    }\n    var min = Math.min(p0, p1);\n    var max = Math.max(p0, p1);\n    var side = ax.side;\n    var visibleLabelMin = Infinity;\n    var visibleLabelMax = -Infinity;\n    tickLabels.each(function (d) {\n      var thisLabel = d3.select(this);\n      var mathjaxGroup = thisLabel.select('.text-math-group');\n      if (mathjaxGroup.empty()) {\n        var bb = Drawing.bBox(thisLabel.node());\n        var adjust = 0;\n        if (isX) {\n          if (bb.right > max) adjust = 1;else if (bb.left < min) adjust = 1;\n        } else {\n          if (bb.bottom > max) adjust = 1;else if (bb.top + (ax.tickangle ? 0 : d.fontSize / 4) < min) adjust = 1;\n        }\n        var t = thisLabel.select('text');\n        if (adjust) {\n          if (hideOverflow) t.style('opacity', 0); // hidden\n        } else {\n          t.style('opacity', 1); // visible\n\n          if (side === 'bottom' || side === 'right') {\n            visibleLabelMin = Math.min(visibleLabelMin, isX ? bb.top : bb.left);\n          } else {\n            visibleLabelMin = -Infinity;\n          }\n          if (side === 'top' || side === 'left') {\n            visibleLabelMax = Math.max(visibleLabelMax, isX ? bb.bottom : bb.right);\n          } else {\n            visibleLabelMax = Infinity;\n          }\n        }\n      } // TODO: hide mathjax?\n    });\n    for (var subplot in fullLayout._plots) {\n      var plotinfo = fullLayout._plots[subplot];\n      if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n      var anchorAx = isX ? plotinfo.yaxis : plotinfo.xaxis;\n      if (anchorAx) {\n        anchorAx['_visibleLabelMin_' + ax._id] = visibleLabelMin;\n        anchorAx['_visibleLabelMax_' + ax._id] = visibleLabelMax;\n      }\n    }\n  };\n  ax._hideCounterAxisInsideTickLabels = function (partialOpts) {\n    var isX = ax._id.charAt(0) === 'x';\n    var anchoredAxes = [];\n    for (var subplot in fullLayout._plots) {\n      var plotinfo = fullLayout._plots[subplot];\n      if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n      anchoredAxes.push(isX ? plotinfo.yaxis : plotinfo.xaxis);\n    }\n    anchoredAxes.forEach(function (anchorAx, idx) {\n      if (anchorAx && insideTicklabelposition(anchorAx)) {\n        (partialOpts || [ZERO_PATH, MINORGRID_PATH, GRID_PATH, TICK_PATH, TICK_TEXT]).forEach(function (e) {\n          var isPeriodLabel = e.K === 'tick' && e.L === 'text' && ax.ticklabelmode === 'period';\n          var mainPlotinfo = fullLayout._plots[ax._mainSubplot];\n          var sel;\n          if (e.K === ZERO_PATH.K) sel = mainPlotinfo.zerolinelayer.selectAll('.' + ax._id + 'zl');else if (e.K === MINORGRID_PATH.K) sel = mainPlotinfo.minorGridlayer.selectAll('.' + ax._id);else if (e.K === GRID_PATH.K) sel = mainPlotinfo.gridlayer.selectAll('.' + ax._id);else sel = mainPlotinfo[ax._id.charAt(0) + 'axislayer'];\n          sel.each(function () {\n            var w = d3.select(this);\n            if (e.L) w = w.selectAll(e.L);\n            w.each(function (d) {\n              var q = ax.l2p(isPeriodLabel ? getPosX(d) : d.x) + ax._offset;\n              var t = d3.select(this);\n              if (q < ax['_visibleLabelMax_' + anchorAx._id] && q > ax['_visibleLabelMin_' + anchorAx._id]) {\n                t.style('display', 'none'); // hidden\n              } else if (e.K === 'tick' && !idx) {\n                t.style('display', null); // visible\n              }\n            });\n          });\n        });\n      }\n    });\n  };\n\n  // make sure all labels are correctly positioned at their base angle\n  // the positionLabels call above is only for newly drawn labels.\n  // do this without waiting, using the last calculated angle to\n  // minimize flicker, then do it again when we know all labels are\n  // there, putting back the prescribed angle to check for overlaps.\n  positionLabels(tickLabels, prevAngle + 1 ? prevAngle : tickAngle);\n  function allLabelsReady() {\n    return labelsReady.length && Promise.all(labelsReady);\n  }\n  var autoangle = null;\n  function fixLabelOverlaps() {\n    positionLabels(tickLabels, tickAngle);\n\n    // check for auto-angling if x labels overlap\n    // don't auto-angle at all for log axes with\n    // base and digit format\n    if (vals.length && ax.autotickangles && (ax.type !== 'log' || String(ax.dtick).charAt(0) !== 'D')) {\n      autoangle = ax.autotickangles[0];\n      var maxFontSize = 0;\n      var lbbArray = [];\n      var i;\n      var maxLines = 1;\n      tickLabels.each(function (d) {\n        maxFontSize = Math.max(maxFontSize, d.fontSize);\n        var x = ax.l2p(d.x);\n        var thisLabel = selectTickLabel(this);\n        var bb = Drawing.bBox(thisLabel.node());\n        maxLines = Math.max(maxLines, svgTextUtils.lineCount(thisLabel));\n        lbbArray.push({\n          // ignore about y, just deal with x overlaps\n          top: 0,\n          bottom: 10,\n          height: 10,\n          left: x - bb.width / 2,\n          // impose a 2px gap\n          right: x + bb.width / 2 + 2,\n          width: bb.width + 2\n        });\n      });\n      if ((ax.tickson === 'boundaries' || ax.showdividers) && !opts.secondary) {\n        var gap = 2;\n        if (ax.ticks) gap += ax.tickwidth / 2;\n\n        // TODO should secondary labels also fall into this fix-overlap regime?\n\n        for (i = 0; i < lbbArray.length; i++) {\n          var xbnd = vals[i].xbnd;\n          var lbb = lbbArray[i];\n          if (xbnd[0] !== null && lbb.left - ax.l2p(xbnd[0]) < gap || xbnd[1] !== null && ax.l2p(xbnd[1]) - lbb.right < gap) {\n            autoangle = 90;\n            break;\n          }\n        }\n      } else {\n        var vLen = vals.length;\n        var tickSpacing = Math.abs((vals[vLen - 1].x - vals[0].x) * ax._m) / (vLen - 1);\n        var ticklabelposition = ax.ticklabelposition || '';\n        var has = function (str) {\n          return ticklabelposition.indexOf(str) !== -1;\n        };\n        var isTop = has('top');\n        var isLeft = has('left');\n        var isRight = has('right');\n        var isBottom = has('bottom');\n        var isAligned = isBottom || isLeft || isTop || isRight;\n        var pad = !isAligned ? 0 : (ax.tickwidth || 0) + 2 * TEXTPAD;\n\n        // autotickangles\n        var adjacent = tickSpacing;\n        var opposite = maxFontSize * 1.25 * maxLines;\n        var hypotenuse = Math.sqrt(Math.pow(adjacent, 2) + Math.pow(opposite, 2));\n        var maxCos = adjacent / hypotenuse;\n        var autoTickAnglesRadians = ax.autotickangles.map(function (degrees) {\n          return degrees * Math.PI / 180;\n        });\n        var angleRadians = autoTickAnglesRadians.find(function (angle) {\n          return Math.abs(Math.cos(angle)) <= maxCos;\n        });\n        if (angleRadians === undefined) {\n          // no angle with smaller cosine than maxCos, just pick the angle with smallest cosine\n          angleRadians = autoTickAnglesRadians.reduce(function (currentMax, nextAngle) {\n            return Math.abs(Math.cos(currentMax)) < Math.abs(Math.cos(nextAngle)) ? currentMax : nextAngle;\n          }, autoTickAnglesRadians[0]);\n        }\n        var newAngle = angleRadians * (180 / Math.PI /* to degrees */);\n        for (i = 0; i < lbbArray.length - 1; i++) {\n          if (Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1], pad)) {\n            autoangle = newAngle;\n            break;\n          }\n        }\n      }\n      if (autoangle) {\n        positionLabels(tickLabels, autoangle);\n      }\n    }\n  }\n  if (ax._selections) {\n    ax._selections[cls] = tickLabels;\n  }\n  var seq = [allLabelsReady];\n\n  // N.B. during auto-margin redraws, if the axis fixed its label overlaps\n  // by rotating 90 degrees, do not attempt to re-fix its label overlaps\n  // as this can lead to infinite redraw loops!\n  if (ax.automargin && fullLayout._redrawFromAutoMarginCount && prevAngle === 90) {\n    autoangle = prevAngle;\n    seq.push(function () {\n      positionLabels(tickLabels, prevAngle);\n    });\n  } else {\n    seq.push(fixLabelOverlaps);\n  }\n\n  // save current tick angle for future redraws\n  if (ax._tickAngles) {\n    seq.push(function () {\n      ax._tickAngles[cls] = autoangle === null ? isNumeric(tickAngle) ? tickAngle : 0 : autoangle;\n    });\n  }\n  var computeTickLabelBoundingBoxes = function () {\n    var labelsMaxW = 0;\n    var labelsMaxH = 0;\n    tickLabels.each(function (d, i) {\n      var thisLabel = selectTickLabel(this);\n      var mathjaxGroup = thisLabel.select('.text-math-group');\n      if (mathjaxGroup.empty()) {\n        var bb;\n        if (ax._vals[i]) {\n          bb = ax._vals[i].bb || Drawing.bBox(thisLabel.node());\n          ax._vals[i].bb = bb;\n        }\n        labelsMaxW = Math.max(labelsMaxW, bb.width);\n        labelsMaxH = Math.max(labelsMaxH, bb.height);\n      }\n    });\n    return {\n      labelsMaxW: labelsMaxW,\n      labelsMaxH: labelsMaxH\n    };\n  };\n  var anchorAx = ax._anchorAxis;\n  if (anchorAx && (anchorAx.autorange || anchorAx.insiderange) && insideTicklabelposition(ax) && !isLinked(fullLayout, ax._id)) {\n    if (!fullLayout._insideTickLabelsUpdaterange) {\n      fullLayout._insideTickLabelsUpdaterange = {};\n    }\n    if (anchorAx.autorange) {\n      fullLayout._insideTickLabelsUpdaterange[anchorAx._name + '.autorange'] = anchorAx.autorange;\n      seq.push(computeTickLabelBoundingBoxes);\n    }\n    if (anchorAx.insiderange) {\n      var BBs = computeTickLabelBoundingBoxes();\n      var move = ax._id.charAt(0) === 'y' ? BBs.labelsMaxW : BBs.labelsMaxH;\n      move += 2 * TEXTPAD;\n      if (ax.ticklabelposition === 'inside') {\n        move += ax.ticklen || 0;\n      }\n      var sgn = ax.side === 'right' || ax.side === 'top' ? 1 : -1;\n      var index = sgn === 1 ? 1 : 0;\n      var otherIndex = sgn === 1 ? 0 : 1;\n      var newRange = [];\n      newRange[otherIndex] = anchorAx.range[otherIndex];\n      var anchorAxRange = anchorAx.range;\n      var p0 = anchorAx.r2p(anchorAxRange[index]);\n      var p1 = anchorAx.r2p(anchorAxRange[otherIndex]);\n      var _tempNewRange = fullLayout._insideTickLabelsUpdaterange[anchorAx._name + '.range'];\n      if (_tempNewRange) {\n        // case of having multiple anchored axes having insideticklabel\n        var q0 = anchorAx.r2p(_tempNewRange[index]);\n        var q1 = anchorAx.r2p(_tempNewRange[otherIndex]);\n        var dir = sgn * (ax._id.charAt(0) === 'y' ? 1 : -1);\n        if (dir * p0 < dir * q0) {\n          p0 = q0;\n          newRange[index] = anchorAxRange[index] = _tempNewRange[index];\n        }\n        if (dir * p1 > dir * q1) {\n          p1 = q1;\n          newRange[otherIndex] = anchorAxRange[otherIndex] = _tempNewRange[otherIndex];\n        }\n      }\n      var dist = Math.abs(p1 - p0);\n      if (dist - move > 0) {\n        dist -= move;\n        move *= 1 + move / dist;\n      } else {\n        move = 0;\n      }\n      if (ax._id.charAt(0) !== 'y') move = -move;\n      newRange[index] = anchorAx.p2r(anchorAx.r2p(anchorAxRange[index]) + sgn * move);\n\n      // handle partial ranges in insiderange\n      if (anchorAx.autorange === 'min' || anchorAx.autorange === 'max reversed') {\n        newRange[0] = null;\n        anchorAx._rangeInitial0 = undefined;\n        anchorAx._rangeInitial1 = undefined;\n      } else if (anchorAx.autorange === 'max' || anchorAx.autorange === 'min reversed') {\n        newRange[1] = null;\n        anchorAx._rangeInitial0 = undefined;\n        anchorAx._rangeInitial1 = undefined;\n      }\n      fullLayout._insideTickLabelsUpdaterange[anchorAx._name + '.range'] = newRange;\n    }\n  }\n  var done = Lib.syncOrAsync(seq);\n  if (done && done.then) gd._promises.push(done);\n  return done;\n};\n\n/**\n * Draw axis dividers\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} showdividers\n *  - {number} dividerwidth\n *  - {string} dividercolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {fn} path\n * - {fn} transFn\n */\nfunction drawDividers(gd, ax, opts) {\n  var cls = ax._id + 'divider';\n  var vals = opts.vals;\n  var dividers = opts.layer.selectAll('path.' + cls).data(vals, tickDataFn);\n  dividers.exit().remove();\n  dividers.enter().insert('path', ':first-child').classed(cls, 1).classed('crisp', 1).call(Color.stroke, ax.dividercolor).style('stroke-width', Drawing.crispRound(gd, ax.dividerwidth, 1) + 'px');\n  dividers.attr('transform', opts.transFn).attr('d', opts.path);\n}\n\n/**\n * Get axis position in px, that is the distance for the graph's\n * top (left) edge for x (y) axes.\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} side\n *  if anchored:\n *  - {object} _anchorAxis\n *  Otherwise:\n *  - {number} position\n * @return {number}\n */\naxes.getPxPosition = function (gd, ax) {\n  var gs = gd._fullLayout._size;\n  var axLetter = ax._id.charAt(0);\n  var side = ax.side;\n  var anchorAxis;\n  if (ax.anchor !== 'free') {\n    anchorAxis = ax._anchorAxis;\n  } else if (axLetter === 'x') {\n    anchorAxis = {\n      _offset: gs.t + (1 - (ax.position || 0)) * gs.h,\n      _length: 0\n    };\n  } else if (axLetter === 'y') {\n    anchorAxis = {\n      _offset: gs.l + (ax.position || 0) * gs.w + ax._shift,\n      _length: 0\n    };\n  }\n  if (side === 'top' || side === 'left') {\n    return anchorAxis._offset;\n  } else if (side === 'bottom' || side === 'right') {\n    return anchorAxis._offset + anchorAxis._length;\n  }\n};\n\n/**\n * Approximate axis title depth (w/o computing its bounding box)\n *\n * @param {object} ax (full) axis object\n *  - {string} title.text\n *  - {number} title.font.size\n *  - {number} title.standoff\n * @return {number} (in px)\n */\nfunction approxTitleDepth(ax) {\n  var fontSize = ax.title.font.size;\n  var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;\n  if (ax.title.hasOwnProperty('standoff')) {\n    return extraLines ? fontSize * (CAP_SHIFT + extraLines * LINE_SPACING) : fontSize * CAP_SHIFT;\n  } else {\n    return extraLines ? fontSize * (extraLines + 1) * LINE_SPACING : fontSize;\n  }\n}\n\n/**\n * Draw axis title, compute default standoff if necessary\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} _name\n *  - {string} side\n *  - {number} title.font.size\n *  - {object} _selections\n *\n *  - {number} _depth\n *  - {number} title.standoff\n *  OR\n *  - {number} linewidth\n *  - {boolean} showticklabels\n */\nfunction drawTitle(gd, ax) {\n  var fullLayout = gd._fullLayout;\n  var axId = ax._id;\n  var axLetter = axId.charAt(0);\n  var fontSize = ax.title.font.size;\n  var titleStandoff;\n  if (ax.title.hasOwnProperty('standoff')) {\n    titleStandoff = ax._depth + ax.title.standoff + approxTitleDepth(ax);\n  } else {\n    var isInside = insideTicklabelposition(ax);\n    if (ax.type === 'multicategory') {\n      titleStandoff = ax._depth;\n    } else {\n      var offsetBase = 1.5 * fontSize;\n      if (isInside) {\n        offsetBase = 0.5 * fontSize;\n        if (ax.ticks === 'outside') {\n          offsetBase += ax.ticklen;\n        }\n      }\n      titleStandoff = 10 + offsetBase + (ax.linewidth ? ax.linewidth - 1 : 0);\n    }\n    if (!isInside) {\n      if (axLetter === 'x') {\n        titleStandoff += ax.side === 'top' ? fontSize * (ax.showticklabels ? 1 : 0) : fontSize * (ax.showticklabels ? 1.5 : 0.5);\n      } else {\n        titleStandoff += ax.side === 'right' ? fontSize * (ax.showticklabels ? 1 : 0.5) : fontSize * (ax.showticklabels ? 0.5 : 0);\n      }\n    }\n  }\n  var pos = axes.getPxPosition(gd, ax);\n  var transform, x, y;\n  if (axLetter === 'x') {\n    x = ax._offset + ax._length / 2;\n    y = ax.side === 'top' ? pos - titleStandoff : pos + titleStandoff;\n  } else {\n    y = ax._offset + ax._length / 2;\n    x = ax.side === 'right' ? pos + titleStandoff : pos - titleStandoff;\n    transform = {\n      rotate: '-90',\n      offset: 0\n    };\n  }\n  var avoid;\n  if (ax.type !== 'multicategory') {\n    var tickLabels = ax._selections[ax._id + 'tick'];\n    avoid = {\n      selection: tickLabels,\n      side: ax.side\n    };\n    if (tickLabels && tickLabels.node() && tickLabels.node().parentNode) {\n      var translation = Drawing.getTranslate(tickLabels.node().parentNode);\n      avoid.offsetLeft = translation.x;\n      avoid.offsetTop = translation.y;\n    }\n    if (ax.title.hasOwnProperty('standoff')) {\n      avoid.pad = 0;\n    }\n  }\n  ax._titleStandoff = titleStandoff;\n  return Titles.draw(gd, axId + 'title', {\n    propContainer: ax,\n    propName: ax._name + '.title.text',\n    placeholder: fullLayout._dfltTitle[axLetter],\n    avoid: avoid,\n    transform: transform,\n    attributes: {\n      x: x,\n      y: y,\n      'text-anchor': 'middle'\n    }\n  });\n}\naxes.shouldShowZeroLine = function (gd, ax, counterAxis) {\n  var rng = Lib.simpleMap(ax.range, ax.r2l);\n  return rng[0] * rng[1] <= 0 && ax.zeroline && (ax.type === 'linear' || ax.type === '-') && !(ax.rangebreaks && ax.maskBreaks(0) === BADNUM) && (clipEnds(ax, 0) || !anyCounterAxLineAtZero(gd, ax, counterAxis, rng) || hasBarsOrFill(gd, ax));\n};\naxes.clipEnds = function (ax, vals) {\n  return vals.filter(function (d) {\n    return clipEnds(ax, d.x);\n  });\n};\nfunction clipEnds(ax, l) {\n  var p = ax.l2p(l);\n  return p > 1 && p < ax._length - 1;\n}\nfunction anyCounterAxLineAtZero(gd, ax, counterAxis, rng) {\n  var mainCounterAxis = counterAxis._mainAxis;\n  if (!mainCounterAxis) return;\n  var fullLayout = gd._fullLayout;\n  var axLetter = ax._id.charAt(0);\n  var counterLetter = axes.counterLetter(ax._id);\n  var zeroPosition = ax._offset + (Math.abs(rng[0]) < Math.abs(rng[1]) === (axLetter === 'x') ? 0 : ax._length);\n  function lineNearZero(ax2) {\n    if (!ax2.showline || !ax2.linewidth) return false;\n    var tolerance = Math.max((ax2.linewidth + ax.zerolinewidth) / 2, 1);\n    function closeEnough(pos2) {\n      return typeof pos2 === 'number' && Math.abs(pos2 - zeroPosition) < tolerance;\n    }\n    if (closeEnough(ax2._mainLinePosition) || closeEnough(ax2._mainMirrorPosition)) {\n      return true;\n    }\n    var linePositions = ax2._linepositions || {};\n    for (var k in linePositions) {\n      if (closeEnough(linePositions[k][0]) || closeEnough(linePositions[k][1])) {\n        return true;\n      }\n    }\n  }\n  var plotinfo = fullLayout._plots[counterAxis._mainSubplot];\n  if (!(plotinfo.mainplotinfo || plotinfo).overlays.length) {\n    return lineNearZero(counterAxis, zeroPosition);\n  }\n  var counterLetterAxes = axes.list(gd, counterLetter);\n  for (var i = 0; i < counterLetterAxes.length; i++) {\n    var counterAxis2 = counterLetterAxes[i];\n    if (counterAxis2._mainAxis === mainCounterAxis && lineNearZero(counterAxis2, zeroPosition)) {\n      return true;\n    }\n  }\n}\nfunction hasBarsOrFill(gd, ax) {\n  var fullData = gd._fullData;\n  var subplot = ax._mainSubplot;\n  var axLetter = ax._id.charAt(0);\n  for (var i = 0; i < fullData.length; i++) {\n    var trace = fullData[i];\n    if (trace.visible === true && trace.xaxis + trace.yaxis === subplot) {\n      if (Registry.traceIs(trace, 'bar-like') && trace.orientation === {\n        x: 'h',\n        y: 'v'\n      }[axLetter]) return true;\n      if (trace.fill && trace.fill.charAt(trace.fill.length - 1) === axLetter) return true;\n    }\n  }\n  return false;\n}\nfunction selectTickLabel(gTick) {\n  var s = d3.select(gTick);\n  var mj = s.select('.text-math-group');\n  return mj.empty() ? s.select('text') : mj;\n}\n\n/**\n * Find all margin pushers for 2D axes and reserve them for later use\n * Both label and rangeslider automargin calculations happen later so\n * we need to explicitly allow their ids in order to not delete them.\n *\n * TODO: can we pull the actual automargin calls forward to avoid this hack?\n * We're probably also doing multiple redraws in this case, would be faster\n * if we can just do the whole calculation ahead of time and draw once.\n */\naxes.allowAutoMargin = function (gd) {\n  var axList = axes.list(gd, '', true);\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    if (ax.automargin) {\n      Plots.allowAutoMargin(gd, axAutoMarginID(ax));\n      if (ax.mirror) {\n        Plots.allowAutoMargin(gd, axMirrorAutoMarginID(ax));\n      }\n    }\n    if (Registry.getComponentMethod('rangeslider', 'isVisible')(ax)) {\n      Plots.allowAutoMargin(gd, rangeSliderAutoMarginID(ax));\n    }\n  }\n};\nfunction axAutoMarginID(ax) {\n  return ax._id + '.automargin';\n}\nfunction axMirrorAutoMarginID(ax) {\n  return axAutoMarginID(ax) + '.mirror';\n}\nfunction rangeSliderAutoMarginID(ax) {\n  return ax._id + '.rangeslider';\n}\n\n// swap all the presentation attributes of the axes showing these traces\naxes.swap = function (gd, traces) {\n  var axGroups = makeAxisGroups(gd, traces);\n  for (var i = 0; i < axGroups.length; i++) {\n    swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);\n  }\n};\nfunction makeAxisGroups(gd, traces) {\n  var groups = [];\n  var i, j;\n  for (i = 0; i < traces.length; i++) {\n    var groupsi = [];\n    var xi = gd._fullData[traces[i]].xaxis;\n    var yi = gd._fullData[traces[i]].yaxis;\n    if (!xi || !yi) continue; // not a 2D cartesian trace?\n\n    for (j = 0; j < groups.length; j++) {\n      if (groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {\n        groupsi.push(j);\n      }\n    }\n    if (!groupsi.length) {\n      groups.push({\n        x: [xi],\n        y: [yi]\n      });\n      continue;\n    }\n    var group0 = groups[groupsi[0]];\n    var groupj;\n    if (groupsi.length > 1) {\n      for (j = 1; j < groupsi.length; j++) {\n        groupj = groups[groupsi[j]];\n        mergeAxisGroups(group0.x, groupj.x);\n        mergeAxisGroups(group0.y, groupj.y);\n      }\n    }\n    mergeAxisGroups(group0.x, [xi]);\n    mergeAxisGroups(group0.y, [yi]);\n  }\n  return groups;\n}\nfunction mergeAxisGroups(intoSet, fromSet) {\n  for (var i = 0; i < fromSet.length; i++) {\n    if (intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);\n  }\n}\nfunction swapAxisGroup(gd, xIds, yIds) {\n  var xFullAxes = [];\n  var yFullAxes = [];\n  var layout = gd.layout;\n  var i, j;\n  for (i = 0; i < xIds.length; i++) xFullAxes.push(axes.getFromId(gd, xIds[i]));\n  for (i = 0; i < yIds.length; i++) yFullAxes.push(axes.getFromId(gd, yIds[i]));\n  var allAxKeys = Object.keys(axAttrs);\n  var noSwapAttrs = ['anchor', 'domain', 'overlaying', 'position', 'side', 'tickangle', 'editType'];\n  var numericTypes = ['linear', 'log'];\n  for (i = 0; i < allAxKeys.length; i++) {\n    var keyi = allAxKeys[i];\n    var xVal = xFullAxes[0][keyi];\n    var yVal = yFullAxes[0][keyi];\n    var allEqual = true;\n    var coerceLinearX = false;\n    var coerceLinearY = false;\n    if (keyi.charAt(0) === '_' || typeof xVal === 'function' || noSwapAttrs.indexOf(keyi) !== -1) {\n      continue;\n    }\n    for (j = 1; j < xFullAxes.length && allEqual; j++) {\n      var xVali = xFullAxes[j][keyi];\n      if (keyi === 'type' && numericTypes.indexOf(xVal) !== -1 && numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {\n        // type is special - if we find a mixture of linear and log,\n        // coerce them all to linear on flipping\n        coerceLinearX = true;\n      } else if (xVali !== xVal) allEqual = false;\n    }\n    for (j = 1; j < yFullAxes.length && allEqual; j++) {\n      var yVali = yFullAxes[j][keyi];\n      if (keyi === 'type' && numericTypes.indexOf(yVal) !== -1 && numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {\n        // type is special - if we find a mixture of linear and log,\n        // coerce them all to linear on flipping\n        coerceLinearY = true;\n      } else if (yFullAxes[j][keyi] !== yVal) allEqual = false;\n    }\n    if (allEqual) {\n      if (coerceLinearX) layout[xFullAxes[0]._name].type = 'linear';\n      if (coerceLinearY) layout[yFullAxes[0]._name].type = 'linear';\n      swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes, gd._fullLayout._dfltTitle);\n    }\n  }\n\n  // now swap x&y for any annotations anchored to these x & y\n  for (i = 0; i < gd._fullLayout.annotations.length; i++) {\n    var ann = gd._fullLayout.annotations[i];\n    if (xIds.indexOf(ann.xref) !== -1 && yIds.indexOf(ann.yref) !== -1) {\n      Lib.swapAttrs(layout.annotations[i], ['?']);\n    }\n  }\n}\nfunction swapAxisAttrs(layout, key, xFullAxes, yFullAxes, dfltTitle) {\n  // in case the value is the default for either axis,\n  // look at the first axis in each list and see if\n  // this key's value is undefined\n  var np = Lib.nestedProperty;\n  var xVal = np(layout[xFullAxes[0]._name], key).get();\n  var yVal = np(layout[yFullAxes[0]._name], key).get();\n  var i;\n  if (key === 'title') {\n    // special handling of placeholder titles\n    if (xVal && xVal.text === dfltTitle.x) {\n      xVal.text = dfltTitle.y;\n    }\n    if (yVal && yVal.text === dfltTitle.y) {\n      yVal.text = dfltTitle.x;\n    }\n  }\n  for (i = 0; i < xFullAxes.length; i++) {\n    np(layout, xFullAxes[i]._name + '.' + key).set(yVal);\n  }\n  for (i = 0; i < yFullAxes.length; i++) {\n    np(layout, yFullAxes[i]._name + '.' + key).set(xVal);\n  }\n}\nfunction isAngular(ax) {\n  return ax._id === 'angularaxis';\n}\nfunction moveOutsideBreak(v, ax) {\n  var len = ax._rangebreaks.length;\n  for (var k = 0; k < len; k++) {\n    var brk = ax._rangebreaks[k];\n    if (v >= brk.min && v < brk.max) {\n      return brk.max;\n    }\n  }\n  return v;\n}\nfunction insideTicklabelposition(ax) {\n  return (ax.ticklabelposition || '').indexOf('inside') !== -1;\n}\nfunction hideCounterAxisInsideTickLabels(ax, opts) {\n  if (insideTicklabelposition(ax._anchorAxis || {})) {\n    if (ax._hideCounterAxisInsideTickLabels) {\n      ax._hideCounterAxisInsideTickLabels(opts);\n    }\n  }\n}\nfunction incrementShift(ax, shiftVal, axShifts, normalize) {\n  // Need to set 'overlay' for anchored axis\n  var overlay = ax.anchor !== 'free' && (ax.overlaying === undefined || ax.overlaying === false) ? ax._id : ax.overlaying;\n  var shiftValAdj;\n  if (normalize) {\n    shiftValAdj = ax.side === 'right' ? shiftVal : -shiftVal;\n  } else {\n    shiftValAdj = shiftVal;\n  }\n  if (!(overlay in axShifts)) {\n    axShifts[overlay] = {};\n  }\n  if (!(ax.side in axShifts[overlay])) {\n    axShifts[overlay][ax.side] = 0;\n  }\n  axShifts[overlay][ax.side] += shiftValAdj;\n}\nfunction setShiftVal(ax, axShifts) {\n  return ax.autoshift ? axShifts[ax.overlaying][ax.side] : ax.shift || 0;\n}","map":{"version":3,"names":["require","d3","isNumeric","Plots","Registry","Lib","strTranslate","svgTextUtils","Titles","Color","Drawing","axAttrs","cleanTicks","constants","ONEMAXYEAR","ONEAVGYEAR","ONEMINYEAR","ONEMAXQUARTER","ONEAVGQUARTER","ONEMINQUARTER","ONEMAXMONTH","ONEAVGMONTH","ONEMINMONTH","ONEWEEK","ONEDAY","HALFDAY","ONEHOUR","ONEMIN","ONESEC","MINUS_SIGN","BADNUM","ZERO_PATH","K","GRID_PATH","L","MINORGRID_PATH","TICK_PATH","TICK_TEXT","MARGIN_MAPPING","width","height","right","left","top","bottom","alignmentConstants","MID_SHIFT","CAP_SHIFT","LINE_SPACING","OPPOSITE_SIDE","TEXTPAD","axes","module","exports","setConvert","autoType","axisIds","idSort","isLinked","id2name","name2id","cleanId","list","listIds","getFromId","getFromTrace","autorange","getAutoRange","findExtremes","epsilon","expandRange","range","delta","coerceRef","containerIn","containerOut","gd","attr","dflt","extraOption","axLetter","charAt","length","axlist","_fullLayout","_subplots","refAttr","attrDef","concat","map","x","valType","values","coerce","getRefType","ar","undefined","test","coercePosition","axRef","cleanPos","pos","axRefType","ensureNumber","ax","fraction2r","cleanPosition","redrawComponents","axIds","fullLayout","_redrawOneComp","moduleName","methodName","stashName","shortCircuit","method","getComponentMethod","stash","i","indices","j","ind","getDataConversions","trace","target","targetArray","d2cTarget","isArrayOrTypedArray","type","autotypenumbers","_categories","d2c","c2d","toString","toNum","v","String","getDataToCoordFunc","counterLetter","id","minDtick","newDiff","newFirst","allow","indexOf","_minDtick","_forceTick0","saveRangeInitial","overwrite","axList","hasOneAxisChanged","isNew","_rangeInitial0","_rangeInitial1","hasChanged","_autorangeInitial","saveShowSpikeInitial","allSpikesEnabled","_showSpikeInitial","showspikes","_showspikes","_cartesianSpikesEnabled","autoBin","data","nbins","is2d","calendar","size","dataMin","aggNums","Math","min","dataMax","max","start","end","round","_dataSpan","dummyAx","simpleMap","c2r","dtick","tick0","size0","distinctData","distinctVals","msexp","pow","floor","log","minDiff","LN10","minSize","roundUp","stdev","autoTicks","finalSize","binStart","tickIncrement","tickFirst","binEnd","bincount","autoShiftNumericBins","autoShiftMonthBins","edgecount","midcount","intcount","blankCount","nearEdge","dataCount","binshift","stats","findExactDates","threshold","exactDays","numMonths","Number","substr","exactYears","exactMonths","nextBinStart","prepMinorTicks","mockAx","opts","minor","hasMajor","_tmin","mockMinorRange","tick2","rl","r2l","l2r","_isMinor","prepTicks","numericMajor","numericMinor","majorNum","substring","minorNum","isMultiple","_input","nticks","isClose","_tick0Init","bigger","smaller","abs","a","b","rng","tickmode","nt","minPx","tickfont","bigFont","_length","_id","constrain","_name","_roughDTick","ticklabelmode","adjustPeriodDelta","autoTickRound","nMonths","definedDelta","mDate","isMDate","tickformat","getTickFormat","noDtick","_dtickInit","_dowTick0","_rawTick0","_definedDelta","positionPeriodTicks","tickVals","value","A","B","actualDelta","periodLength","inBetween","endPeriod","rangebreaks","nAll","n","c","r","maskBreaks","drop","periodX","calcTicks","ticklabelstep","isPeriod","axrev","minRange","maxRange","maxTicks","ticksOut","minorTicks","minorTickVals","hasMinor","ticks","showgrid","major","isMinor","extendFlat","arrayTicks","syncTicks","exRng","startTick","endTick","numDtick","isDLog","x0","prevX","majorId","_dTick","moveOutsideBreak","obj","simpleLabel","skipLabel","push","canOverlap","majorValues","d","k","T","found","q","flip","fontSize","prevL","NaN","splice","l","c2p","isAngular","pop","_tmax","_prevDateHead","_inCalcTicks","lastVisibleHead","hideLabel","tick","text","t","p","_minor","_value","tickText","noTick","filterRangeBreaks","filter","baseAxis","_mainAxis","_vals","l2p","vali","p2l","majorOnly","tickMin","tickMax","tickVal2l","d2l_noadd","d2l","vals","tickvals","ticktext","roundBase10","roundBase24","roundBase60","roundDays","roundLog1","roundLog2","roundAngles","roundDTick","roughDTick","base","roundingSet","getBase","dateTick0","roughX2","_hasDayOfWeekBreaks","ceil","olddtick","_tickexponent","_tickround","tick0ms","tick0str","replace","tick0len","tick1len","r2d","maxend","rangeexp","minexponent","isSIFormat","exponentformat","beyondSI","axSign","increment","tType","dtSigned","incrementMonth","tickset","x2","frac","mod","sRound","r0","tmin","dtNum","cnt","t0","t1","mult","newDTick","error","hover","noSuffixPrefix","out","tickTextObj","arrayMode","extraPrecision","axType","inbounds","_lBreaks","xbnd","isHidden","showAttr","firstOrLast","first","last","hideexp","showexponent","formatDate","formatLog","formatCategory","formatMultiCategory","formatAngle","formatLinear","tickprefix","showtickprefix","ticksuffix","showticksuffix","labelalias","hasOwnProperty","tickson","showdividers","hoverLabelText","hoverformat","val","val2","logOffScale","tx","c2l","tf","dx","dy","font","family","fontColor","color","tr","fmt","y","m","M","S","dateStr","_dateFormat","_extraFormat","headStr","splitIndex","isInside","insideTicklabelposition","side","_trueSide","dtChar0","numFormat","absP","exponentFormat","firstChar","tt","cats","tt2","text2","thetaunit","num","num2frac","deg2rad","isNeg","join","almostEq","findGCD","findPrecision","e","precision","number","gcd","SIPREFIXES","exponent","fmtoverride","tickRound","separatethousands","ah","_numFormat","dp","numSeparate","_separators","signedExponent","convertToMs","compareLogTicks","priority","leftPriority","rightPriority","isProperStop","convert","convertFn","leftDtick","rightDtick","isProperLogStop","isLeftDtickNull","isRightDtickNull","isDtickInRangeLeft","isDtickInRangeRight","tickstop","stopi","tickformatstops","enabled","dtickrange","getSubplots","subplotObj","allSubplots","cartesian","gl2d","findSubplotsWithAxis","sort","aParts","split","bParts","subplots","axMatch","RegExp","subplotsWithAx","sp","makeClipPaths","_hasOnlyLargeSploms","fullWidth","_offset","fullHeight","xaList","yaList","clipList","axClips","_clips","selectAll","enter","append","classed","_uid","exit","remove","each","select","draw","arg","_paper","plotinfo","_plots","xa","xaxis","ya","yaxis","xaxislayer","yaxislayer","minorGridlayer","gridlayer","zerolinelayer","_infolayer","fullAxList","overlayingShiftedAx","autoshift","overlaying","axId","overlayingIndex","findIndex","axis","unshift","shift","axShifts","false","syncOrAsync","axDone","drawOne","_shiftPusher","incrementShift","_fullDepth","_r","slice","_rl","setScale","mainPlotinfo","_mainSubplot","anchor","selfPush","linewidth","ticklen","skipTitle","_shift","setShiftVal","mainAxLayer","mainLinePosition","_mainLinePosition","mainLinePositionShift","mainMirrorPosition","_mainMirrorPosition","axInfo","mirror","_selections","_tickAngles","_prevTickAngles","_depth","llbboxes","getLabelLevelBbox","suffix","cls","calcLabelLevelBbox","visible","transTickFn","makeTransTickFn","transTickLabelFn","makeTransTickLabelFn","valsClipped","insideTicks","outsideTicks","boundaryVals","getBoundaryVals","clipEnds","gridVals","_gridVals","dividerVals","getDividerVals","_subplotsWith","finishedGrids","counterAxis","mainCounterID","gridPath","drawGrid","layer","minorLayer","path","transFn","drawZeroLine","tickPath","majorTickSigns","getTickSigns","minorTickSigns","majorTickPath","makeTickPath","minorTickPath","mirrorMajorTickPath","mirrorMinorTickPath","fullMajorTickPath","fullMinorTickPath","_anchorAxis","dividerLookup","drawTicks","tickSubplots","Object","keys","_linepositions","linepositions","p0","p1","spTickPath","seq","drawLabels","labelFns","makeLabelFns","pad","bboxKey","standoff","getSecondaryLabelVals","repositionOnUpdate","secondary","drawDividers","len","title","hasRangeSlider","drawTitle","s","sMirror","getPxPosition","outsideTickLen","llbbox","mirrorPush","rangeSliderPush","automargin","axDepth","titleDepth","_dfltTitle","_titleStandoff","_titleScoot","approxTitleDepth","domainIndices","reverse","rExtra","xr","lExtra","xl","bExtra","yb","tExtra","yt","position","domain","_counterDomainMin","_counterDomainMax","filterPush","autoMargin","axAutoMarginID","axMirrorAutoMarginID","rangeSliderAutoMarginID","keepMargin","reduce","nextKey","forEach","key","_push","bndIndex","xb","lookup","interp","current","reversed","Infinity","thisLabel","selectTickLabel","bb","bBox","node","parentNode","dummyCalc","yFn","xFn","sideOpposite","main","uv","getTickLabelUV","u","getPosX","ticklabelposition","has","str","isTop","isLeft","isRight","isBottom","isAligned","tickwidth","sgn","angle","insideTickLabels","labelsOverTicks","labelStandoff","labelShift","tickLen","rad","cos","sin","showticklabels","showline","y0","ff","flipIt","xQ","tickangle","endSide","anchorFn","heightFn","h","ang","rA","tickDataFn","crisp","stroke","tickcolor","style","crispRound","hideCounterAxisInsideTickLabels","minorVals","majorVals","counterAx","shouldShowZeroLine","isArrayMode","xi","_gw","gridwidth","wMinor","majorLayer","grid","gridcolor","dashStyle","griddash","show","zl","da","db","call","zerolinecolor","defaultLine","zerolinewidth","tickAngle","prevAngle","tickLabels","labelsReady","newPromise","_promises","positionText","convertToTspans","then","positionLabels","mathjaxGroup","transform","nLines","lineCount","lineHeight","anchorHeight","empty","thisText","_adjustTickLabelsOverflow","mjWidth","mjShift","ticklabeloverflow","hideOverflow","isX","visibleLabelMin","visibleLabelMax","adjust","subplot","anchorAx","_hideCounterAxisInsideTickLabels","partialOpts","anchoredAxes","idx","isPeriodLabel","sel","w","allLabelsReady","Promise","all","autoangle","fixLabelOverlaps","autotickangles","maxFontSize","lbbArray","maxLines","gap","lbb","vLen","tickSpacing","_m","adjacent","opposite","hypotenuse","sqrt","maxCos","autoTickAnglesRadians","degrees","PI","angleRadians","find","currentMax","nextAngle","newAngle","bBoxIntersect","_redrawFromAutoMarginCount","computeTickLabelBoundingBoxes","labelsMaxW","labelsMaxH","insiderange","_insideTickLabelsUpdaterange","BBs","move","index","otherIndex","newRange","anchorAxRange","r2p","_tempNewRange","q0","q1","dir","dist","p2r","done","dividers","insert","dividercolor","dividerwidth","gs","_size","anchorAxis","extraLines","match","BR_TAG_ALL","titleStandoff","offsetBase","rotate","offset","avoid","selection","translation","getTranslate","offsetLeft","offsetTop","propContainer","propName","placeholder","attributes","zeroline","anyCounterAxLineAtZero","hasBarsOrFill","mainCounterAxis","zeroPosition","lineNearZero","ax2","tolerance","closeEnough","pos2","linePositions","mainplotinfo","overlays","counterLetterAxes","counterAxis2","fullData","_fullData","traceIs","orientation","fill","gTick","mj","allowAutoMargin","swap","traces","axGroups","makeAxisGroups","swapAxisGroup","groups","groupsi","yi","group0","groupj","mergeAxisGroups","intoSet","fromSet","xIds","yIds","xFullAxes","yFullAxes","layout","allAxKeys","noSwapAttrs","numericTypes","keyi","xVal","yVal","allEqual","coerceLinearX","coerceLinearY","xVali","yVali","swapAxisAttrs","annotations","ann","xref","yref","swapAttrs","dfltTitle","np","nestedProperty","get","set","_rangebreaks","brk","shiftVal","normalize","overlay","shiftValAdj"],"sources":["/home/zhu/Documents/github/explorer_front/explorer_front_app/node_modules/plotly.js/src/plots/cartesian/axes.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\nvar Plots = require('../../plots/plots');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Titles = require('../../components/titles');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\n\nvar axAttrs = require('./layout_attributes');\nvar cleanTicks = require('./clean_ticks');\n\nvar constants = require('../../constants/numerical');\nvar ONEMAXYEAR = constants.ONEMAXYEAR;\nvar ONEAVGYEAR = constants.ONEAVGYEAR;\nvar ONEMINYEAR = constants.ONEMINYEAR;\nvar ONEMAXQUARTER = constants.ONEMAXQUARTER;\nvar ONEAVGQUARTER = constants.ONEAVGQUARTER;\nvar ONEMINQUARTER = constants.ONEMINQUARTER;\nvar ONEMAXMONTH = constants.ONEMAXMONTH;\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\nvar ONEMINMONTH = constants.ONEMINMONTH;\nvar ONEWEEK = constants.ONEWEEK;\nvar ONEDAY = constants.ONEDAY;\nvar HALFDAY = ONEDAY / 2;\nvar ONEHOUR = constants.ONEHOUR;\nvar ONEMIN = constants.ONEMIN;\nvar ONESEC = constants.ONESEC;\nvar MINUS_SIGN = constants.MINUS_SIGN;\nvar BADNUM = constants.BADNUM;\n\nvar ZERO_PATH = { K: 'zeroline' };\nvar GRID_PATH = { K: 'gridline', L: 'path' };\nvar MINORGRID_PATH = { K: 'minor-gridline', L: 'path' };\nvar TICK_PATH = { K: 'tick', L: 'path' };\nvar TICK_TEXT = { K: 'tick', L: 'text' };\nvar MARGIN_MAPPING = {\n    width: ['x', 'r', 'l', 'xl', 'xr'],\n    height: ['y', 't', 'b', 'yt', 'yb'],\n    right: ['r', 'xr'],\n    left: ['l', 'xl'],\n    top: ['t', 'yt'],\n    bottom: ['b', 'yb']\n};\n\nvar alignmentConstants = require('../../constants/alignment');\nvar MID_SHIFT = alignmentConstants.MID_SHIFT;\nvar CAP_SHIFT = alignmentConstants.CAP_SHIFT;\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar OPPOSITE_SIDE = alignmentConstants.OPPOSITE_SIDE;\n\nvar TEXTPAD = 3;\n\nvar axes = module.exports = {};\n\naxes.setConvert = require('./set_convert');\nvar autoType = require('./axis_autotype');\n\nvar axisIds = require('./axis_ids');\nvar idSort = axisIds.idSort;\nvar isLinked = axisIds.isLinked;\n\n// tight coupling to chart studio\naxes.id2name = axisIds.id2name;\naxes.name2id = axisIds.name2id;\naxes.cleanId = axisIds.cleanId;\naxes.list = axisIds.list;\naxes.listIds = axisIds.listIds;\naxes.getFromId = axisIds.getFromId;\naxes.getFromTrace = axisIds.getFromTrace;\n\nvar autorange = require('./autorange');\naxes.getAutoRange = autorange.getAutoRange;\naxes.findExtremes = autorange.findExtremes;\n\nvar epsilon = 0.0001;\nfunction expandRange(range) {\n    var delta = (range[1] - range[0]) * epsilon;\n    return [\n        range[0] - delta,\n        range[1] + delta\n    ];\n}\n\n/*\n * find the list of possible axes to reference with an xref or yref attribute\n * and coerce it to that list\n *\n * attr: the attribute we're generating a reference for. Should end in 'x' or 'y'\n *     but can be prefixed, like 'ax' for annotation's arrow x\n * dflt: the default to coerce to, or blank to use the first axis (falling back on\n *     extraOption if there is no axis)\n * extraOption: aside from existing axes with this letter, what non-axis value is allowed?\n *     Only required if it's different from `dflt`\n */\naxes.coerceRef = function(containerIn, containerOut, gd, attr, dflt, extraOption) {\n    var axLetter = attr.charAt(attr.length - 1);\n    var axlist = gd._fullLayout._subplots[axLetter + 'axis'];\n    var refAttr = attr + 'ref';\n    var attrDef = {};\n\n    if(!dflt) dflt = axlist[0] || (typeof extraOption === 'string' ? extraOption : extraOption[0]);\n    if(!extraOption) extraOption = dflt;\n    axlist = axlist.concat(axlist.map(function(x) { return x + ' domain'; }));\n\n    // data-ref annotations are not supported in gl2d yet\n\n    attrDef[refAttr] = {\n        valType: 'enumerated',\n        values: axlist.concat(extraOption ?\n            (typeof extraOption === 'string' ? [extraOption] : extraOption) :\n            []),\n        dflt: dflt\n    };\n\n    // xref, yref\n    return Lib.coerce(containerIn, containerOut, attrDef, refAttr);\n};\n\n/*\n * Get the type of an axis reference. This can be 'range', 'domain', or 'paper'.\n * This assumes ar is a valid axis reference and returns 'range' if it doesn't\n * match the patterns for 'paper' or 'domain'.\n *\n * ar: the axis reference string\n *\n */\naxes.getRefType = function(ar) {\n    if(ar === undefined) { return ar; }\n    if(ar === 'paper') { return 'paper'; }\n    if(ar === 'pixel') { return 'pixel'; }\n    if(/( domain)$/.test(ar)) { return 'domain'; } else { return 'range'; }\n};\n\n/*\n * coerce position attributes (range-type) that can be either on axes or absolute\n * (paper or pixel) referenced. The biggest complication here is that we don't know\n * before looking at the axis whether the value must be a number or not (it may be\n * a date string), so we can't use the regular valType='number' machinery\n *\n * axRef (string): the axis this position is referenced to, or:\n *     paper: fraction of the plot area\n *     pixel: pixels relative to some starting position\n * attr (string): the attribute in containerOut we are coercing\n * dflt (number): the default position, as a fraction or pixels. If the attribute\n *     is to be axis-referenced, this will be converted to an axis data value\n *\n * Also cleans the values, since the attribute definition itself has to say\n * valType: 'any' to handle date axes. This allows us to accept:\n * - for category axes: category names, and convert them here into serial numbers.\n *   Note that this will NOT work for axis range endpoints, because we don't know\n *   the category list yet (it's set by ax.makeCalcdata during calc)\n *   but it works for component (note, shape, images) positions.\n * - for date axes: JS Dates or milliseconds, and convert to date strings\n * - for other types: coerce them to numbers\n */\naxes.coercePosition = function(containerOut, gd, coerce, axRef, attr, dflt) {\n    var cleanPos, pos;\n    var axRefType = axes.getRefType(axRef);\n    if(axRefType !== 'range') {\n        cleanPos = Lib.ensureNumber;\n        pos = coerce(attr, dflt);\n    } else {\n        var ax = axes.getFromId(gd, axRef);\n        dflt = ax.fraction2r(dflt);\n        pos = coerce(attr, dflt);\n        cleanPos = ax.cleanPos;\n    }\n    containerOut[attr] = cleanPos(pos);\n};\n\naxes.cleanPosition = function(pos, gd, axRef) {\n    var cleanPos = (axRef === 'paper' || axRef === 'pixel') ?\n        Lib.ensureNumber :\n        axes.getFromId(gd, axRef).cleanPos;\n\n    return cleanPos(pos);\n};\n\naxes.redrawComponents = function(gd, axIds) {\n    axIds = axIds ? axIds : axes.listIds(gd);\n\n    var fullLayout = gd._fullLayout;\n\n    function _redrawOneComp(moduleName, methodName, stashName, shortCircuit) {\n        var method = Registry.getComponentMethod(moduleName, methodName);\n        var stash = {};\n\n        for(var i = 0; i < axIds.length; i++) {\n            var ax = fullLayout[axes.id2name(axIds[i])];\n            var indices = ax[stashName];\n\n            for(var j = 0; j < indices.length; j++) {\n                var ind = indices[j];\n\n                if(!stash[ind]) {\n                    method(gd, ind);\n                    stash[ind] = 1;\n                    // once is enough for images (which doesn't use the `i` arg anyway)\n                    if(shortCircuit) return;\n                }\n            }\n        }\n    }\n\n    // annotations and shapes 'draw' method is slow,\n    // use the finer-grained 'drawOne' method instead\n    _redrawOneComp('annotations', 'drawOne', '_annIndices');\n    _redrawOneComp('shapes', 'drawOne', '_shapeIndices');\n    _redrawOneComp('images', 'draw', '_imgIndices', true);\n    _redrawOneComp('selections', 'drawOne', '_selectionIndices');\n};\n\nvar getDataConversions = axes.getDataConversions = function(gd, trace, target, targetArray) {\n    var ax;\n\n    // If target points to an axis, use the type we already have for that\n    // axis to find the data type. Otherwise use the values to autotype.\n    var d2cTarget = (target === 'x' || target === 'y' || target === 'z') ?\n        target :\n        targetArray;\n\n    // In the case of an array target, make a mock data array\n    // and call supplyDefaults to the data type and\n    // setup the data-to-calc method.\n    if(Lib.isArrayOrTypedArray(d2cTarget)) {\n        ax = {\n            type: autoType(targetArray, undefined, {\n                autotypenumbers: gd._fullLayout.autotypenumbers\n            }),\n            _categories: []\n        };\n        axes.setConvert(ax);\n\n        // build up ax._categories (usually done during ax.makeCalcdata()\n        if(ax.type === 'category') {\n            for(var i = 0; i < targetArray.length; i++) {\n                ax.d2c(targetArray[i]);\n            }\n        }\n        // TODO what to do for transforms?\n    } else {\n        ax = axes.getFromTrace(gd, trace, d2cTarget);\n    }\n\n    // if 'target' has corresponding axis\n    // -> use setConvert method\n    if(ax) return {d2c: ax.d2c, c2d: ax.c2d};\n\n    // special case for 'ids'\n    // -> cast to String\n    if(d2cTarget === 'ids') return {d2c: toString, c2d: toString};\n\n    // otherwise (e.g. numeric-array of 'marker.color' or 'marker.size')\n    // -> cast to Number\n\n    return {d2c: toNum, c2d: toNum};\n};\n\nfunction toNum(v) { return +v; }\nfunction toString(v) { return String(v); }\n\naxes.getDataToCoordFunc = function(gd, trace, target, targetArray) {\n    return getDataConversions(gd, trace, target, targetArray).d2c;\n};\n\n// get counteraxis letter for this axis (name or id)\n// this can also be used as the id for default counter axis\naxes.counterLetter = function(id) {\n    var axLetter = id.charAt(0);\n    if(axLetter === 'x') return 'y';\n    if(axLetter === 'y') return 'x';\n};\n\n// incorporate a new minimum difference and first tick into\n// forced\n// note that _forceTick0 is linearized, so needs to be turned into\n// a range value for setting tick0\naxes.minDtick = function(ax, newDiff, newFirst, allow) {\n    // doesn't make sense to do forced min dTick on log or category axes,\n    // and the plot itself may decide to cancel (ie non-grouped bars)\n    if(['log', 'category', 'multicategory'].indexOf(ax.type) !== -1 || !allow) {\n        ax._minDtick = 0;\n    } else if(ax._minDtick === undefined) {\n        // undefined means there's nothing there yet\n\n        ax._minDtick = newDiff;\n        ax._forceTick0 = newFirst;\n    } else if(ax._minDtick) {\n        if((ax._minDtick / newDiff + 1e-6) % 1 < 2e-6 &&\n            // existing minDtick is an integer multiple of newDiff\n            // (within rounding err)\n            // and forceTick0 can be shifted to newFirst\n\n                (((newFirst - ax._forceTick0) / newDiff % 1) +\n                    1.000001) % 1 < 2e-6) {\n            ax._minDtick = newDiff;\n            ax._forceTick0 = newFirst;\n        } else if((newDiff / ax._minDtick + 1e-6) % 1 > 2e-6 ||\n            // if the converse is true (newDiff is a multiple of minDtick and\n            // newFirst can be shifted to forceTick0) then do nothing - same\n            // forcing stands. Otherwise, cancel forced minimum\n\n                (((newFirst - ax._forceTick0) / ax._minDtick % 1) +\n                    1.000001) % 1 > 2e-6) {\n            ax._minDtick = 0;\n        }\n    }\n};\n\n// save a copy of the initial axis ranges in fullLayout\n// use them in mode bar and dblclick events\naxes.saveRangeInitial = function(gd, overwrite) {\n    var axList = axes.list(gd, '', true);\n    var hasOneAxisChanged = false;\n\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        var isNew =\n            ax._rangeInitial0 === undefined &&\n            ax._rangeInitial1 === undefined;\n\n        var hasChanged = isNew || (\n            ax.range[0] !== ax._rangeInitial0 ||\n            ax.range[1] !== ax._rangeInitial1\n        );\n\n        var autorange = ax.autorange;\n        if((isNew && autorange !== true) || (overwrite && hasChanged)) {\n            ax._rangeInitial0 = (autorange === 'min' || autorange === 'max reversed') ? undefined : ax.range[0];\n            ax._rangeInitial1 = (autorange === 'max' || autorange === 'min reversed') ? undefined : ax.range[1];\n            ax._autorangeInitial = autorange;\n            hasOneAxisChanged = true;\n        }\n    }\n\n    return hasOneAxisChanged;\n};\n\n// save a copy of the initial spike visibility\naxes.saveShowSpikeInitial = function(gd, overwrite) {\n    var axList = axes.list(gd, '', true);\n    var hasOneAxisChanged = false;\n    var allSpikesEnabled = 'on';\n\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        var isNew = (ax._showSpikeInitial === undefined);\n        var hasChanged = isNew || !(ax.showspikes === ax._showspikes);\n\n        if(isNew || (overwrite && hasChanged)) {\n            ax._showSpikeInitial = ax.showspikes;\n            hasOneAxisChanged = true;\n        }\n\n        if(allSpikesEnabled === 'on' && !ax.showspikes) {\n            allSpikesEnabled = 'off';\n        }\n    }\n    gd._fullLayout._cartesianSpikesEnabled = allSpikesEnabled;\n    return hasOneAxisChanged;\n};\n\naxes.autoBin = function(data, ax, nbins, is2d, calendar, size) {\n    var dataMin = Lib.aggNums(Math.min, null, data);\n    var dataMax = Lib.aggNums(Math.max, null, data);\n\n    if(ax.type === 'category' || ax.type === 'multicategory') {\n        return {\n            start: dataMin - 0.5,\n            end: dataMax + 0.5,\n            size: Math.max(1, Math.round(size) || 1),\n            _dataSpan: dataMax - dataMin,\n        };\n    }\n\n    if(!calendar) calendar = ax.calendar;\n\n    // piggyback off tick code to make \"nice\" bin sizes and edges\n    var dummyAx;\n    if(ax.type === 'log') {\n        dummyAx = {\n            type: 'linear',\n            range: [dataMin, dataMax]\n        };\n    } else {\n        dummyAx = {\n            type: ax.type,\n            range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),\n            calendar: calendar\n        };\n    }\n    axes.setConvert(dummyAx);\n\n    size = size && cleanTicks.dtick(size, dummyAx.type);\n\n    if(size) {\n        dummyAx.dtick = size;\n        dummyAx.tick0 = cleanTicks.tick0(undefined, dummyAx.type, calendar);\n    } else {\n        var size0;\n        if(nbins) size0 = ((dataMax - dataMin) / nbins);\n        else {\n            // totally auto: scale off std deviation so the highest bin is\n            // somewhat taller than the total number of bins, but don't let\n            // the size get smaller than the 'nice' rounded down minimum\n            // difference between values\n            var distinctData = Lib.distinctVals(data);\n            var msexp = Math.pow(10, Math.floor(\n                Math.log(distinctData.minDiff) / Math.LN10));\n            var minSize = msexp * Lib.roundUp(\n                distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);\n            size0 = Math.max(minSize, 2 * Lib.stdev(data) /\n                Math.pow(data.length, is2d ? 0.25 : 0.4));\n\n            // fallback if ax.d2c output BADNUMs\n            // e.g. when user try to plot categorical bins\n            // on a layout.xaxis.type: 'linear'\n            if(!isNumeric(size0)) size0 = 1;\n        }\n\n        axes.autoTicks(dummyAx, size0);\n    }\n\n    var finalSize = dummyAx.dtick;\n    var binStart = axes.tickIncrement(\n            axes.tickFirst(dummyAx), finalSize, 'reverse', calendar);\n    var binEnd, bincount;\n\n    // check for too many data points right at the edges of bins\n    // (>50% within 1% of bin edges) or all data points integral\n    // and offset the bins accordingly\n    if(typeof finalSize === 'number') {\n        binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);\n\n        bincount = 1 + Math.floor((dataMax - binStart) / finalSize);\n        binEnd = binStart + bincount * finalSize;\n    } else {\n        // month ticks - should be the only nonlinear kind we have at this point.\n        // dtick (as supplied by axes.autoTick) only has nonlinear values on\n        // date and log axes, but even if you display a histogram on a log axis\n        // we bin it on a linear axis (which one could argue against, but that's\n        // a separate issue)\n        if(dummyAx.dtick.charAt(0) === 'M') {\n            binStart = autoShiftMonthBins(binStart, data, finalSize, dataMin, calendar);\n        }\n\n        // calculate the endpoint for nonlinear ticks - you have to\n        // just increment until you're done\n        binEnd = binStart;\n        bincount = 0;\n        while(binEnd <= dataMax) {\n            binEnd = axes.tickIncrement(binEnd, finalSize, false, calendar);\n            bincount++;\n        }\n    }\n\n    return {\n        start: ax.c2r(binStart, 0, calendar),\n        end: ax.c2r(binEnd, 0, calendar),\n        size: finalSize,\n        _dataSpan: dataMax - dataMin\n    };\n};\n\n\nfunction autoShiftNumericBins(binStart, data, ax, dataMin, dataMax) {\n    var edgecount = 0;\n    var midcount = 0;\n    var intcount = 0;\n    var blankCount = 0;\n\n    function nearEdge(v) {\n        // is a value within 1% of a bin edge?\n        return (1 + (v - binStart) * 100 / ax.dtick) % 100 < 2;\n    }\n\n    for(var i = 0; i < data.length; i++) {\n        if(data[i] % 1 === 0) intcount++;\n        else if(!isNumeric(data[i])) blankCount++;\n\n        if(nearEdge(data[i])) edgecount++;\n        if(nearEdge(data[i] + ax.dtick / 2)) midcount++;\n    }\n    var dataCount = data.length - blankCount;\n\n    if(intcount === dataCount && ax.type !== 'date') {\n        if(ax.dtick < 1) {\n            // all integers: if bin size is <1, it's because\n            // that was specifically requested (large nbins)\n            // so respect that... but center the bins containing\n            // integers on those integers\n\n            binStart = dataMin - 0.5 * ax.dtick;\n        } else {\n            // otherwise start half an integer down regardless of\n            // the bin size, just enough to clear up endpoint\n            // ambiguity about which integers are in which bins.\n\n            binStart -= 0.5;\n            if(binStart + ax.dtick < dataMin) binStart += ax.dtick;\n        }\n    } else if(midcount < dataCount * 0.1) {\n        if(edgecount > dataCount * 0.3 ||\n                nearEdge(dataMin) || nearEdge(dataMax)) {\n            // lots of points at the edge, not many in the middle\n            // shift half a bin\n            var binshift = ax.dtick / 2;\n            binStart += (binStart + binshift < dataMin) ? binshift : -binshift;\n        }\n    }\n    return binStart;\n}\n\n\nfunction autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {\n    var stats = Lib.findExactDates(data, calendar);\n    // number of data points that needs to be an exact value\n    // to shift that increment to (near) the bin center\n    var threshold = 0.8;\n\n    if(stats.exactDays > threshold) {\n        var numMonths = Number(dtick.substr(1));\n\n        if((stats.exactYears > threshold) && (numMonths % 12 === 0)) {\n            // The exact middle of a non-leap-year is 1.5 days into July\n            // so if we start the bins here, all but leap years will\n            // get hover-labeled as exact years.\n            binStart = axes.tickIncrement(binStart, 'M6', 'reverse') + ONEDAY * 1.5;\n        } else if(stats.exactMonths > threshold) {\n            // Months are not as clean, but if we shift half the *longest*\n            // month (31/2 days) then 31-day months will get labeled exactly\n            // and shorter months will get labeled with the correct month\n            // but shifted 12-36 hours into it.\n            binStart = axes.tickIncrement(binStart, 'M1', 'reverse') + ONEDAY * 15.5;\n        } else {\n            // Shifting half a day is exact, but since these are month bins it\n            // will always give a somewhat odd-looking label, until we do something\n            // smarter like showing the bin boundaries (or the bounds of the actual\n            // data in each bin)\n            binStart -= HALFDAY;\n        }\n        var nextBinStart = axes.tickIncrement(binStart, dtick);\n\n        if(nextBinStart <= dataMin) return nextBinStart;\n    }\n    return binStart;\n}\n\n// ----------------------------------------------------\n// Ticks and grids\n// ----------------------------------------------------\n\n// ensure we have minor tick0 and dtick calculated\naxes.prepMinorTicks = function(mockAx, ax, opts) {\n    if(!ax.minor.dtick) {\n        delete mockAx.dtick;\n        var hasMajor = ax.dtick && isNumeric(ax._tmin);\n        var mockMinorRange;\n        if(hasMajor) {\n            var tick2 = axes.tickIncrement(ax._tmin, ax.dtick, true);\n            // mock range a tiny bit smaller than one major tick interval\n            mockMinorRange = [ax._tmin, tick2 * 0.99 + ax._tmin * 0.01];\n        } else {\n            var rl = Lib.simpleMap(ax.range, ax.r2l);\n            // If we don't have a major dtick, the concept of minor ticks is a little\n            // ambiguous - just take a stab and say minor.nticks should span 1/5 the axis\n            mockMinorRange = [rl[0], 0.8 * rl[0] + 0.2 * rl[1]];\n        }\n        mockAx.range = Lib.simpleMap(mockMinorRange, ax.l2r);\n        mockAx._isMinor = true;\n\n        axes.prepTicks(mockAx, opts);\n\n        if(hasMajor) {\n            var numericMajor = isNumeric(ax.dtick);\n            var numericMinor = isNumeric(mockAx.dtick);\n            var majorNum = numericMajor ? ax.dtick : +ax.dtick.substring(1);\n            var minorNum = numericMinor ? mockAx.dtick : +mockAx.dtick.substring(1);\n            if(numericMajor && numericMinor) {\n                if(!isMultiple(majorNum, minorNum)) {\n                    // give up on minor ticks - outside the below exceptions,\n                    // this can only happen if minor.nticks is smaller than two jumps\n                    // in the auto-tick scale and the first jump is not an even multiple\n                    // (5 -> 2 or for dates 3 ->2, 15 -> 10 etc)  or if you provided\n                    // an explicit dtick, in which case it's fine to give up,\n                    // you can provide an explicit minor.dtick.\n                    if((majorNum === 2 * ONEWEEK) && (minorNum === 3 * ONEDAY)) {\n                        mockAx.dtick = ONEWEEK;\n                    } else if(majorNum === ONEWEEK && !(ax._input.minor || {}).nticks) {\n                        // minor.nticks defaults to 5, but in this one case we want 7,\n                        // so the minor ticks show on all days of the week\n                        mockAx.dtick = ONEDAY;\n                    } else if(isClose(majorNum / minorNum, 2.5)) {\n                        // 5*10^n -> 2*10^n and you've set nticks < 5\n                        // quarters are pretty common, we don't do this by default as it\n                        // would add an extra digit to display, but minor has no labels\n                        mockAx.dtick = majorNum / 2;\n                    } else {\n                        mockAx.dtick = majorNum;\n                    }\n                } else if(majorNum === 2 * ONEWEEK && minorNum === 2 * ONEDAY) {\n                    // this is a weird one: we don't want to automatically choose\n                    // 2-day minor ticks for 2-week major, even though it IS an even multiple,\n                    // because people would expect to see the weeks clearly\n                    mockAx.dtick = ONEWEEK;\n                }\n            } else if(String(ax.dtick).charAt(0) === 'M') {\n                if(numericMinor) {\n                    mockAx.dtick = 'M1';\n                } else {\n                    if(!isMultiple(majorNum, minorNum)) {\n                        // unless you provided an explicit ax.dtick (in which case\n                        // it's OK for us to give up, you can provide an explicit\n                        // minor.dtick too), this can only happen with:\n                        // minor.nticks < 3 and dtick === M3, or\n                        // minor.nticks < 5 and dtick === 5 * 10^n years\n                        // so in all cases we just give up.\n                        mockAx.dtick = ax.dtick;\n                    } else if((majorNum >= 12) && (minorNum === 2)) {\n                        // another special carve-out: for year major ticks, don't show\n                        // 2-month minor ticks, bump to quarters\n                        mockAx.dtick = 'M3';\n                    }\n                }\n            } else if(String(mockAx.dtick).charAt(0) === 'L') {\n                if(String(ax.dtick).charAt(0) === 'L') {\n                    if(!isMultiple(majorNum, minorNum)) {\n                        mockAx.dtick = isClose(majorNum / minorNum, 2.5) ? (ax.dtick / 2) : ax.dtick;\n                    }\n                } else {\n                    mockAx.dtick = 'D1';\n                }\n            } else if(mockAx.dtick === 'D2' && +ax.dtick > 1) {\n                // the D2 log axis tick spacing is confusing for unlabeled minor ticks if\n                // the major dtick is more than one order of magnitude.\n                mockAx.dtick = 1;\n            }\n        }\n        // put back the original range, to use to find the full set of minor ticks\n        mockAx.range = ax.range;\n    }\n    if(ax.minor._tick0Init === undefined) {\n        // ensure identical tick0\n        mockAx.tick0 = ax.tick0;\n    }\n};\n\nfunction isMultiple(bigger, smaller) {\n    return Math.abs((bigger / smaller + 0.5) % 1 - 0.5) < 0.001;\n}\n\nfunction isClose(a, b) {\n    return Math.abs((a / b) - 1) < 0.001;\n}\n\n// ensure we have tick0, dtick, and tick rounding calculated\naxes.prepTicks = function(ax, opts) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts);\n\n    // calculate max number of (auto) ticks to display based on plot size\n    if(ax.tickmode === 'auto' || !ax.dtick) {\n        var nt = ax.nticks;\n        var minPx;\n\n        if(!nt) {\n            if(ax.type === 'category' || ax.type === 'multicategory') {\n                minPx = ax.tickfont ? Lib.bigFont(ax.tickfont.size || 12) : 15;\n                nt = ax._length / minPx;\n            } else {\n                minPx = ax._id.charAt(0) === 'y' ? 40 : 80;\n                nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;\n            }\n\n            // radial axes span half their domain,\n            // multiply nticks value by two to get correct number of auto ticks.\n            if(ax._name === 'radialaxis') nt *= 2;\n        }\n\n        if(!(ax.minor && ax.minor.tickmode !== 'array')) {\n            // add a couple of extra digits for filling in ticks when we\n            // have explicit tickvals without tick text\n            if(ax.tickmode === 'array') nt *= 100;\n        }\n\n        ax._roughDTick = Math.abs(rng[1] - rng[0]) / nt;\n        axes.autoTicks(ax, ax._roughDTick);\n\n        // check for a forced minimum dtick\n        if(ax._minDtick > 0 && ax.dtick < ax._minDtick * 2) {\n            ax.dtick = ax._minDtick;\n            ax.tick0 = ax.l2r(ax._forceTick0);\n        }\n    }\n\n    if(ax.ticklabelmode === 'period') {\n        adjustPeriodDelta(ax);\n    }\n\n    // check for missing tick0\n    if(!ax.tick0) {\n        ax.tick0 = (ax.type === 'date') ? '2000-01-01' : 0;\n    }\n\n    // ensure we don't try to make ticks below our minimum precision\n    // see https://github.com/plotly/plotly.js/issues/2892\n    if(ax.type === 'date' && ax.dtick < 0.1) ax.dtick = 0.1;\n\n    // now figure out rounding of tick values\n    autoTickRound(ax);\n};\n\nfunction nMonths(dtick) {\n    return +(dtick.substring(1));\n}\n\nfunction adjustPeriodDelta(ax) { // adjusts ax.dtick and sets ax._definedDelta\n    var definedDelta;\n\n    function mDate() {\n        return !(\n            isNumeric(ax.dtick) ||\n            ax.dtick.charAt(0) !== 'M'\n        );\n    }\n    var isMDate = mDate();\n    var tickformat = axes.getTickFormat(ax);\n    if(tickformat) {\n        var noDtick = ax._dtickInit !== ax.dtick;\n        if(\n            !(/%[fLQsSMX]/.test(tickformat))\n            // %f: microseconds as a decimal number [000000, 999999]\n            // %L: milliseconds as a decimal number [000, 999]\n            // %Q: milliseconds since UNIX epoch\n            // %s: seconds since UNIX epoch\n            // %S: second as a decimal number [00,61]\n            // %M: minute as a decimal number [00,59]\n            // %X: the locale’s time, such as %-I:%M:%S %p\n        ) {\n            if(\n                /%[HI]/.test(tickformat)\n                // %H: hour (24-hour clock) as a decimal number [00,23]\n                // %I: hour (12-hour clock) as a decimal number [01,12]\n            ) {\n                definedDelta = ONEHOUR;\n                if(noDtick && !isMDate && ax.dtick < ONEHOUR) ax.dtick = ONEHOUR;\n            } else if(\n                /%p/.test(tickformat) // %p: either AM or PM\n            ) {\n                definedDelta = HALFDAY;\n                if(noDtick && !isMDate && ax.dtick < HALFDAY) ax.dtick = HALFDAY;\n            } else if(\n                /%[Aadejuwx]/.test(tickformat)\n                // %A: full weekday name\n                // %a: abbreviated weekday name\n                // %d: zero-padded day of the month as a decimal number [01,31]\n                // %e: space-padded day of the month as a decimal number [ 1,31]\n                // %j: day of the year as a decimal number [001,366]\n                // %u: Monday-based (ISO 8601) weekday as a decimal number [1,7]\n                // %w: Sunday-based weekday as a decimal number [0,6]\n                // %x: the locale’s date, such as %-m/%-d/%Y\n            ) {\n                definedDelta = ONEDAY;\n                if(noDtick && !isMDate && ax.dtick < ONEDAY) ax.dtick = ONEDAY;\n            } else if(\n                /%[UVW]/.test(tickformat)\n                // %U: Sunday-based week of the year as a decimal number [00,53]\n                // %V: ISO 8601 week of the year as a decimal number [01, 53]\n                // %W: Monday-based week of the year as a decimal number [00,53]\n            ) {\n                definedDelta = ONEWEEK;\n                if(noDtick && !isMDate && ax.dtick < ONEWEEK) ax.dtick = ONEWEEK;\n            } else if(\n                /%[Bbm]/.test(tickformat)\n                // %B: full month name\n                // %b: abbreviated month name\n                // %m: month as a decimal number [01,12]\n            ) {\n                definedDelta = ONEAVGMONTH;\n                if(noDtick && (\n                    isMDate ? nMonths(ax.dtick) < 1 : ax.dtick < ONEMINMONTH)\n                ) ax.dtick = 'M1';\n            } else if(\n                /%[q]/.test(tickformat)\n                // %q: quarter of the year as a decimal number [1,4]\n            ) {\n                definedDelta = ONEAVGQUARTER;\n                if(noDtick && (\n                    isMDate ? nMonths(ax.dtick) < 3 : ax.dtick < ONEMINQUARTER)\n                ) ax.dtick = 'M3';\n            } else if(\n                /%[Yy]/.test(tickformat)\n                // %Y: year with century as a decimal number, such as 1999\n                // %y: year without century as a decimal number [00,99]\n            ) {\n                definedDelta = ONEAVGYEAR;\n                if(noDtick && (\n                    isMDate ? nMonths(ax.dtick) < 12 : ax.dtick < ONEMINYEAR)\n                ) ax.dtick = 'M12';\n            }\n        }\n    }\n\n    isMDate = mDate();\n    if(isMDate && ax.tick0 === ax._dowTick0) {\n        // discard Sunday/Monday tweaks\n        ax.tick0 = ax._rawTick0;\n    }\n\n    ax._definedDelta = definedDelta;\n}\n\nfunction positionPeriodTicks(tickVals, ax, definedDelta) {\n    for(var i = 0; i < tickVals.length; i++) {\n        var v = tickVals[i].value;\n\n        var a = i;\n        var b = i + 1;\n        if(i < tickVals.length - 1) {\n            a = i;\n            b = i + 1;\n        } else if(i > 0) {\n            a = i - 1;\n            b = i;\n        } else {\n            a = i;\n            b = i;\n        }\n\n        var A = tickVals[a].value;\n        var B = tickVals[b].value;\n        var actualDelta = Math.abs(B - A);\n        var delta = definedDelta || actualDelta;\n        var periodLength = 0;\n\n        if(delta >= ONEMINYEAR) {\n            if(actualDelta >= ONEMINYEAR && actualDelta <= ONEMAXYEAR) {\n                periodLength = actualDelta;\n            } else {\n                periodLength = ONEAVGYEAR;\n            }\n        } else if(definedDelta === ONEAVGQUARTER && delta >= ONEMINQUARTER) {\n            if(actualDelta >= ONEMINQUARTER && actualDelta <= ONEMAXQUARTER) {\n                periodLength = actualDelta;\n            } else {\n                periodLength = ONEAVGQUARTER;\n            }\n        } else if(delta >= ONEMINMONTH) {\n            if(actualDelta >= ONEMINMONTH && actualDelta <= ONEMAXMONTH) {\n                periodLength = actualDelta;\n            } else {\n                periodLength = ONEAVGMONTH;\n            }\n        } else if(definedDelta === ONEWEEK && delta >= ONEWEEK) {\n            periodLength = ONEWEEK;\n        } else if(delta >= ONEDAY) {\n            periodLength = ONEDAY;\n        } else if(definedDelta === HALFDAY && delta >= HALFDAY) {\n            periodLength = HALFDAY;\n        } else if(definedDelta === ONEHOUR && delta >= ONEHOUR) {\n            periodLength = ONEHOUR;\n        }\n\n        var inBetween;\n        if(periodLength >= actualDelta) {\n            // ensure new label positions remain between ticks\n            periodLength = actualDelta;\n            inBetween = true;\n        }\n\n        var endPeriod = v + periodLength;\n        if(ax.rangebreaks && periodLength > 0) {\n            var nAll = 84; // highly divisible 7 * 12\n            var n = 0;\n            for(var c = 0; c < nAll; c++) {\n                var r = (c + 0.5) / nAll;\n                if(ax.maskBreaks(v * (1 - r) + r * endPeriod) !== BADNUM) n++;\n            }\n            periodLength *= n / nAll;\n\n            if(!periodLength) {\n                tickVals[i].drop = true;\n            }\n\n            if(inBetween && actualDelta > ONEWEEK) periodLength = actualDelta; // center monthly & longer periods\n        }\n\n        if(\n            periodLength > 0 || // not instant\n            i === 0 // taking care first tick added\n        ) {\n            tickVals[i].periodX = v + periodLength / 2;\n        }\n    }\n}\n\n// calculate the ticks: text, values, positioning\n// if ticks are set to automatic, determine the right values (tick0,dtick)\n// in any case, set tickround to # of digits to round tick labels to,\n// or codes to this effect for log and date scales\naxes.calcTicks = function calcTicks(ax, opts) {\n    var type = ax.type;\n    var calendar = ax.calendar;\n    var ticklabelstep = ax.ticklabelstep;\n    var isPeriod = ax.ticklabelmode === 'period';\n\n    var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts);\n    var axrev = (rng[1] < rng[0]);\n    var minRange = Math.min(rng[0], rng[1]);\n    var maxRange = Math.max(rng[0], rng[1]);\n\n    var maxTicks = Math.max(1000, ax._length || 0);\n\n    var ticksOut = [];\n    var minorTicks = [];\n\n    var tickVals = [];\n    var minorTickVals = [];\n\n    var hasMinor = ax.minor && (ax.minor.ticks || ax.minor.showgrid);\n\n    // calc major first\n    for(var major = 1; major >= (hasMinor ? 0 : 1); major--) {\n        var isMinor = !major;\n\n        if(major) {\n            ax._dtickInit = ax.dtick;\n            ax._tick0Init = ax.tick0;\n        } else {\n            ax.minor._dtickInit = ax.minor.dtick;\n            ax.minor._tick0Init = ax.minor.tick0;\n        }\n\n        var mockAx = major ? ax : Lib.extendFlat({}, ax, ax.minor);\n\n        if(isMinor) {\n            axes.prepMinorTicks(mockAx, ax, opts);\n        } else {\n            axes.prepTicks(mockAx, opts);\n        }\n\n        // now that we've figured out the auto values for formatting\n        // in case we're missing some ticktext, we can break out for array ticks\n        if(mockAx.tickmode === 'array') {\n            if(major) {\n                tickVals = [];\n                ticksOut = arrayTicks(ax, !isMinor);\n            } else {\n                minorTickVals = [];\n                minorTicks = arrayTicks(ax, !isMinor);\n            }\n            continue;\n        }\n\n        // fill tickVals based on overlaying axis\n        if(mockAx.tickmode === 'sync') {\n            tickVals = [];\n            ticksOut = syncTicks(ax);\n            continue;\n        }\n\n        // add a tiny bit so we get ticks which may have rounded out\n        var exRng = expandRange(rng);\n        var startTick = exRng[0];\n        var endTick = exRng[1];\n\n        var numDtick = isNumeric(mockAx.dtick);\n        var isDLog = (type === 'log') && !(numDtick || mockAx.dtick.charAt(0) === 'L');\n\n        // find the first tick\n        var x0 = axes.tickFirst(mockAx, opts);\n\n        if(major) {\n            ax._tmin = x0;\n\n            // No visible ticks? Quit.\n            // I've only seen this on category axes with all categories off the edge.\n            if((x0 < startTick) !== axrev) break;\n\n            // return the full set of tick vals\n            if(type === 'category' || type === 'multicategory') {\n                endTick = (axrev) ? Math.max(-0.5, endTick) :\n                    Math.min(ax._categories.length - 0.5, endTick);\n            }\n        }\n\n        var prevX = null;\n        var x = x0;\n        var majorId;\n\n        if(major) {\n            // ids for ticklabelstep\n            var _dTick;\n            if(numDtick) {\n                _dTick = ax.dtick;\n            } else {\n                if(type === 'date') {\n                    if(typeof ax.dtick === 'string' && ax.dtick.charAt(0) === 'M') {\n                        _dTick = ONEAVGMONTH * ax.dtick.substring(1);\n                    }\n                } else {\n                    _dTick = ax._roughDTick;\n                }\n            }\n\n            majorId = Math.round((\n                ax.r2l(x) -\n                ax.r2l(ax.tick0)\n            ) / _dTick) - 1;\n        }\n\n        var dtick = mockAx.dtick;\n\n        if(mockAx.rangebreaks && mockAx._tick0Init !== mockAx.tick0) {\n            // adjust tick0\n            x = moveOutsideBreak(x, ax);\n            if(!axrev) {\n                x = axes.tickIncrement(x, dtick, !axrev, calendar);\n            }\n        }\n\n        if(major && isPeriod) {\n            // add one item to label period before tick0\n            x = axes.tickIncrement(x, dtick, !axrev, calendar);\n            majorId--;\n        }\n\n        for(;\n            axrev ?\n                (x >= endTick) :\n                (x <= endTick);\n            x = axes.tickIncrement(\n                x,\n                dtick,\n                axrev,\n                calendar\n            )\n        ) {\n            if(major) majorId++;\n\n            if(mockAx.rangebreaks) {\n                if(!axrev) {\n                    if(x < startTick) continue;\n                    if(mockAx.maskBreaks(x) === BADNUM && moveOutsideBreak(x, mockAx) >= maxRange) break;\n                }\n            }\n\n            // prevent infinite loops - no more than one tick per pixel,\n            // and make sure each value is different from the previous\n            if(tickVals.length > maxTicks || x === prevX) break;\n            prevX = x;\n\n            var obj = { value: x };\n\n            if(major) {\n                if(isDLog && (x !== (x | 0))) {\n                    obj.simpleLabel = true;\n                }\n\n                if(ticklabelstep > 1 && majorId % ticklabelstep) {\n                    obj.skipLabel = true;\n                }\n\n                tickVals.push(obj);\n            } else {\n                obj.minor = true;\n\n                minorTickVals.push(obj);\n            }\n        }\n    }\n\n    if(hasMinor) {\n        var canOverlap =\n            (ax.minor.ticks === 'inside' && ax.ticks === 'outside') ||\n            (ax.minor.ticks === 'outside' && ax.ticks === 'inside');\n\n        if(!canOverlap) {\n            // remove duplicate minors\n\n            var majorValues = tickVals.map(function(d) { return d.value; });\n\n            var list = [];\n            for(var k = 0; k < minorTickVals.length; k++) {\n                var T = minorTickVals[k];\n                var v = T.value;\n                if(majorValues.indexOf(v) !== -1) {\n                    continue;\n                }\n                var found = false;\n                for(var q = 0; !found && (q < tickVals.length); q++) {\n                    if(\n                        // add 10e6 to eliminate problematic digits\n                        10e6 + tickVals[q].value ===\n                        10e6 + v\n                    ) {\n                        found = true;\n                    }\n                }\n                if(!found) list.push(T);\n            }\n            minorTickVals = list;\n        }\n    }\n\n    if(isPeriod) positionPeriodTicks(tickVals, ax, ax._definedDelta);\n\n    var i;\n    if(ax.rangebreaks) {\n        var flip = ax._id.charAt(0) === 'y';\n\n        var fontSize = 1; // one pixel minimum\n        if(ax.tickmode === 'auto') {\n            fontSize = ax.tickfont ? ax.tickfont.size : 12;\n        }\n\n        var prevL = NaN;\n        for(i = tickVals.length - 1; i > -1; i--) {\n            if(tickVals[i].drop) {\n                tickVals.splice(i, 1);\n                continue;\n            }\n\n            tickVals[i].value = moveOutsideBreak(tickVals[i].value, ax);\n\n            // avoid overlaps\n            var l = ax.c2p(tickVals[i].value);\n            if(flip ?\n                (prevL > l - fontSize) :\n                (prevL < l + fontSize)\n            ) { // ensure one pixel minimum\n                tickVals.splice(axrev ? i + 1 : i, 1);\n            } else {\n                prevL = l;\n            }\n        }\n    }\n\n    // If same angle over a full circle, the last tick vals is a duplicate.\n    // TODO must do something similar for angular date axes.\n    if(isAngular(ax) && Math.abs(rng[1] - rng[0]) === 360) {\n        tickVals.pop();\n    }\n\n    // save the last tick as well as first, so we can\n    // show the exponent only on the last one\n    ax._tmax = (tickVals[tickVals.length - 1] || {}).value;\n\n    // for showing the rest of a date when the main tick label is only the\n    // latter part: ax._prevDateHead holds what we showed most recently.\n    // Start with it cleared and mark that we're in calcTicks (ie calculating a\n    // whole string of these so we should care what the previous date head was!)\n    ax._prevDateHead = '';\n    ax._inCalcTicks = true;\n\n    var lastVisibleHead;\n    var hideLabel = function(tick) {\n        tick.text = '';\n        ax._prevDateHead = lastVisibleHead;\n    };\n\n    tickVals = tickVals.concat(minorTickVals);\n\n    var t, p;\n    for(i = 0; i < tickVals.length; i++) {\n        var _minor = tickVals[i].minor;\n        var _value = tickVals[i].value;\n\n        if(_minor) {\n            minorTicks.push({\n                x: _value,\n                minor: true\n            });\n        } else {\n            lastVisibleHead = ax._prevDateHead;\n\n            t = axes.tickText(\n                ax,\n                _value,\n                false, // hover\n                tickVals[i].simpleLabel // noSuffixPrefix\n            );\n\n            p = tickVals[i].periodX;\n            if(p !== undefined) {\n                t.periodX = p;\n                if(p > maxRange || p < minRange) { // hide label if outside the range\n                    if(p > maxRange) t.periodX = maxRange;\n                    if(p < minRange) t.periodX = minRange;\n\n                    hideLabel(t);\n                }\n            }\n\n            if(tickVals[i].skipLabel) {\n                hideLabel(t);\n            }\n\n            ticksOut.push(t);\n        }\n    }\n    ticksOut = ticksOut.concat(minorTicks);\n\n    ax._inCalcTicks = false;\n\n    if(isPeriod && ticksOut.length) {\n        // drop very first tick that we added to handle period\n        ticksOut[0].noTick = true;\n    }\n\n    return ticksOut;\n};\n\nfunction filterRangeBreaks(ax, ticksOut) {\n    if(ax.rangebreaks) {\n        // remove ticks falling inside rangebreaks\n        ticksOut = ticksOut.filter(function(d) {\n            return ax.maskBreaks(d.x) !== BADNUM;\n        });\n    }\n\n    return ticksOut;\n}\n\nfunction syncTicks(ax) {\n    // get the overlaying axis\n    var baseAxis = ax._mainAxis;\n\n    var ticksOut = [];\n    if(baseAxis._vals) {\n        for(var i = 0; i < baseAxis._vals.length; i++) {\n            // filter vals with noTick flag\n            if(baseAxis._vals[i].noTick) {\n                continue;\n            }\n\n            // get the position of the every tick\n            var pos = baseAxis.l2p(baseAxis._vals[i].x);\n\n            // get the tick for the current axis based on position\n            var vali = ax.p2l(pos);\n            var obj = axes.tickText(ax, vali);\n\n            // assign minor ticks\n            if(baseAxis._vals[i].minor) {\n                obj.minor = true;\n                obj.text = '';\n            }\n\n            ticksOut.push(obj);\n        }\n    }\n\n    ticksOut = filterRangeBreaks(ax, ticksOut);\n\n    return ticksOut;\n}\n\nfunction arrayTicks(ax, majorOnly) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    var exRng = expandRange(rng);\n    var tickMin = Math.min(exRng[0], exRng[1]);\n    var tickMax = Math.max(exRng[0], exRng[1]);\n\n    // make sure showing ticks doesn't accidentally add new categories\n    // TODO multicategory, if we allow ticktext / tickvals\n    var tickVal2l = ax.type === 'category' ? ax.d2l_noadd : ax.d2l;\n\n    // array ticks on log axes always show the full number\n    // (if no explicit ticktext overrides it)\n    if(ax.type === 'log' && String(ax.dtick).charAt(0) !== 'L') {\n        ax.dtick = 'L' + Math.pow(10, Math.floor(Math.min(ax.range[0], ax.range[1])) - 1);\n    }\n\n    var ticksOut = [];\n    for(var isMinor = 0; isMinor <= 1; isMinor++) {\n        if((majorOnly !== undefined) && ((majorOnly && isMinor) || (majorOnly === false && !isMinor))) continue;\n        if(isMinor && !ax.minor) continue;\n        var vals = !isMinor ? ax.tickvals : ax.minor.tickvals;\n        var text = !isMinor ? ax.ticktext : [];\n        if(!vals) continue;\n\n\n        // without a text array, just format the given values as any other ticks\n        // except with more precision to the numbers\n        if(!Lib.isArrayOrTypedArray(text)) text = [];\n\n        for(var i = 0; i < vals.length; i++) {\n            var vali = tickVal2l(vals[i]);\n            if(vali > tickMin && vali < tickMax) {\n                var obj = axes.tickText(ax, vali, false, String(text[i]));\n                if(isMinor) {\n                    obj.minor = true;\n                    obj.text = '';\n                }\n\n                ticksOut.push(obj);\n            }\n        }\n    }\n\n    ticksOut = filterRangeBreaks(ax, ticksOut);\n\n    return ticksOut;\n}\n\nvar roundBase10 = [2, 5, 10];\nvar roundBase24 = [1, 2, 3, 6, 12];\nvar roundBase60 = [1, 2, 5, 10, 15, 30];\n// 2&3 day ticks are weird, but need something btwn 1&7\nvar roundDays = [1, 2, 3, 7, 14];\n// approx. tick positions for log axes, showing all (1) and just 1, 2, 5 (2)\n// these don't have to be exact, just close enough to round to the right value\nvar roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1];\nvar roundLog2 = [-0.301, 0, 0.301, 0.699, 1];\n// N.B. `thetaunit; 'radians' angular axes must be converted to degrees\nvar roundAngles = [15, 30, 45, 90, 180];\n\nfunction roundDTick(roughDTick, base, roundingSet) {\n    return base * Lib.roundUp(roughDTick / base, roundingSet);\n}\n\n// autoTicks: calculate best guess at pleasant ticks for this axis\n// inputs:\n//      ax - an axis object\n//      roughDTick - rough tick spacing (to be turned into a nice round number)\n// outputs (into ax):\n//   tick0: starting point for ticks (not necessarily on the graph)\n//      usually 0 for numeric (=10^0=1 for log) or jan 1, 2000 for dates\n//   dtick: the actual, nice round tick spacing, usually a little larger than roughDTick\n//      if the ticks are spaced linearly (linear scale, categories,\n//          log with only full powers, date ticks < month),\n//          this will just be a number\n//      months: M#\n//      years: M# where # is 12*number of years\n//      log with linear ticks: L# where # is the linear tick spacing\n//      log showing powers plus some intermediates:\n//          D1 shows all digits, D2 shows 2 and 5\naxes.autoTicks = function(ax, roughDTick, isMinor) {\n    var base;\n\n    function getBase(v) {\n        return Math.pow(v, Math.floor(Math.log(roughDTick) / Math.LN10));\n    }\n\n    if(ax.type === 'date') {\n        ax.tick0 = Lib.dateTick0(ax.calendar, 0);\n\n        // the criteria below are all based on the rough spacing we calculate\n        // being > half of the final unit - so precalculate twice the rough val\n        var roughX2 = 2 * roughDTick;\n\n        if(roughX2 > ONEAVGYEAR) {\n            roughDTick /= ONEAVGYEAR;\n            base = getBase(10);\n            ax.dtick = 'M' + (12 * roundDTick(roughDTick, base, roundBase10));\n        } else if(roughX2 > ONEAVGMONTH) {\n            roughDTick /= ONEAVGMONTH;\n            ax.dtick = 'M' + roundDTick(roughDTick, 1, roundBase24);\n        } else if(roughX2 > ONEDAY) {\n            ax.dtick = roundDTick(roughDTick, ONEDAY, ax._hasDayOfWeekBreaks ? [1, 2, 7, 14] : roundDays);\n            if(!isMinor) {\n                // get week ticks on sunday\n                // this will also move the base tick off 2000-01-01 if dtick is\n                // 2 or 3 days... but that's a weird enough case that we'll ignore it.\n                var tickformat = axes.getTickFormat(ax);\n                var isPeriod = ax.ticklabelmode === 'period';\n                if(isPeriod) ax._rawTick0 = ax.tick0;\n\n                if(/%[uVW]/.test(tickformat)) {\n                    ax.tick0 = Lib.dateTick0(ax.calendar, 2); // Monday\n                } else {\n                    ax.tick0 = Lib.dateTick0(ax.calendar, 1); // Sunday\n                }\n\n                if(isPeriod) ax._dowTick0 = ax.tick0;\n            }\n        } else if(roughX2 > ONEHOUR) {\n            ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);\n        } else if(roughX2 > ONEMIN) {\n            ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);\n        } else if(roughX2 > ONESEC) {\n            ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);\n        } else {\n            // milliseconds\n            base = getBase(10);\n            ax.dtick = roundDTick(roughDTick, base, roundBase10);\n        }\n    } else if(ax.type === 'log') {\n        ax.tick0 = 0;\n        var rng = Lib.simpleMap(ax.range, ax.r2l);\n        if(ax._isMinor) {\n            // Log axes by default get MORE than nTicks based on the metrics below\n            // But for minor ticks we don't want this increase, we already have\n            // the major ticks.\n            roughDTick *= 1.5;\n        }\n        if(roughDTick > 0.7) {\n            // only show powers of 10\n            ax.dtick = Math.ceil(roughDTick);\n        } else if(Math.abs(rng[1] - rng[0]) < 1) {\n            // span is less than one power of 10\n            var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick);\n\n            // ticks on a linear scale, labeled fully\n            roughDTick = Math.abs(Math.pow(10, rng[1]) -\n                Math.pow(10, rng[0])) / nt;\n            base = getBase(10);\n            ax.dtick = 'L' + roundDTick(roughDTick, base, roundBase10);\n        } else {\n            // include intermediates between powers of 10,\n            // labeled with small digits\n            // ax.dtick = \"D2\" (show 2 and 5) or \"D1\" (show all digits)\n            ax.dtick = (roughDTick > 0.3) ? 'D2' : 'D1';\n        }\n    } else if(ax.type === 'category' || ax.type === 'multicategory') {\n        ax.tick0 = 0;\n        ax.dtick = Math.ceil(Math.max(roughDTick, 1));\n    } else if(isAngular(ax)) {\n        ax.tick0 = 0;\n        base = 1;\n        ax.dtick = roundDTick(roughDTick, base, roundAngles);\n    } else {\n        // auto ticks always start at 0\n        ax.tick0 = 0;\n        base = getBase(10);\n        ax.dtick = roundDTick(roughDTick, base, roundBase10);\n    }\n\n    // prevent infinite loops\n    if(ax.dtick === 0) ax.dtick = 1;\n\n    // TODO: this is from log axis histograms with autorange off\n    if(!isNumeric(ax.dtick) && typeof ax.dtick !== 'string') {\n        var olddtick = ax.dtick;\n        ax.dtick = 1;\n        throw 'ax.dtick error: ' + String(olddtick);\n    }\n};\n\n// after dtick is already known, find tickround = precision\n// to display in tick labels\n//   for numeric ticks, integer # digits after . to round to\n//   for date ticks, the last date part to show (y,m,d,H,M,S)\n//      or an integer # digits past seconds\nfunction autoTickRound(ax) {\n    var dtick = ax.dtick;\n\n    ax._tickexponent = 0;\n    if(!isNumeric(dtick) && typeof dtick !== 'string') {\n        dtick = 1;\n    }\n\n    if(ax.type === 'category' || ax.type === 'multicategory') {\n        ax._tickround = null;\n    }\n    if(ax.type === 'date') {\n        // If tick0 is unusual, give tickround a bit more information\n        // not necessarily *all* the information in tick0 though, if it's really odd\n        // minimal string length for tick0: 'd' is 10, 'M' is 16, 'S' is 19\n        // take off a leading minus (year < 0) and i (intercalary month) so length is consistent\n        var tick0ms = ax.r2l(ax.tick0);\n        var tick0str = ax.l2r(tick0ms).replace(/(^-|i)/g, '');\n        var tick0len = tick0str.length;\n\n        if(String(dtick).charAt(0) === 'M') {\n            // any tick0 more specific than a year: alway show the full date\n            if(tick0len > 10 || tick0str.substr(5) !== '01-01') ax._tickround = 'd';\n            // show the month unless ticks are full multiples of a year\n            else ax._tickround = (+(dtick.substr(1)) % 12 === 0) ? 'y' : 'm';\n        } else if((dtick >= ONEDAY && tick0len <= 10) || (dtick >= ONEDAY * 15)) ax._tickround = 'd';\n        else if((dtick >= ONEMIN && tick0len <= 16) || (dtick >= ONEHOUR)) ax._tickround = 'M';\n        else if((dtick >= ONESEC && tick0len <= 19) || (dtick >= ONEMIN)) ax._tickround = 'S';\n        else {\n            // tickround is a number of digits of fractional seconds\n            // of any two adjacent ticks, at least one will have the maximum fractional digits\n            // of all possible ticks - so take the max. length of tick0 and the next one\n            var tick1len = ax.l2r(tick0ms + dtick).replace(/^-/, '').length;\n            ax._tickround = Math.max(tick0len, tick1len) - 20;\n\n            // We shouldn't get here... but in case there's a situation I'm\n            // not thinking of where tick0str and tick1str are identical or\n            // something, fall back on maximum precision\n            if(ax._tickround < 0) ax._tickround = 4;\n        }\n    } else if(isNumeric(dtick) || dtick.charAt(0) === 'L') {\n        // linear or log (except D1, D2)\n        var rng = ax.range.map(ax.r2d || Number);\n        if(!isNumeric(dtick)) dtick = Number(dtick.substr(1));\n        // 2 digits past largest digit of dtick\n        ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);\n\n        var maxend = Math.max(Math.abs(rng[0]), Math.abs(rng[1]));\n        var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);\n        var minexponent = ax.minexponent === undefined ? 3 : ax.minexponent;\n        if(Math.abs(rangeexp) > minexponent) {\n            if(isSIFormat(ax.exponentformat) && !beyondSI(rangeexp)) {\n                ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);\n            } else ax._tickexponent = rangeexp;\n        }\n    } else {\n        // D1 or D2 (log)\n        ax._tickround = null;\n    }\n}\n\n// months and years don't have constant millisecond values\n// (but a year is always 12 months so we only need months)\n// log-scale ticks are also not consistently spaced, except\n// for pure powers of 10\n// numeric ticks always have constant differences, other datetime ticks\n// can all be calculated as constant number of milliseconds\naxes.tickIncrement = function(x, dtick, axrev, calendar) {\n    var axSign = axrev ? -1 : 1;\n\n    // includes linear, all dates smaller than month, and pure 10^n in log\n    if(isNumeric(dtick)) return Lib.increment(x, axSign * dtick);\n\n    // everything else is a string, one character plus a number\n    var tType = dtick.charAt(0);\n    var dtSigned = axSign * Number(dtick.substr(1));\n\n    // Dates: months (or years - see Lib.incrementMonth)\n    if(tType === 'M') return Lib.incrementMonth(x, dtSigned, calendar);\n\n    // Log scales: Linear, Digits\n    if(tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;\n\n    // log10 of 2,5,10, or all digits (logs just have to be\n    // close enough to round)\n    if(tType === 'D') {\n        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1;\n        var x2 = x + axSign * 0.01;\n        var frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);\n\n        return Math.floor(x2) +\n            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n    }\n\n    throw 'unrecognized dtick ' + String(dtick);\n};\n\n// calculate the first tick on an axis\naxes.tickFirst = function(ax, opts) {\n    var r2l = ax.r2l || Number;\n    var rng = Lib.simpleMap(ax.range, r2l, undefined, undefined, opts);\n    var axrev = rng[1] < rng[0];\n    var sRound = axrev ? Math.floor : Math.ceil;\n    // add a tiny extra bit to make sure we get ticks\n    // that may have been rounded out\n    var r0 = expandRange(rng)[0];\n    var dtick = ax.dtick;\n    var tick0 = r2l(ax.tick0);\n\n    if(isNumeric(dtick)) {\n        var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0;\n\n        // make sure no ticks outside the category list\n        if(ax.type === 'category' || ax.type === 'multicategory') {\n            tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);\n        }\n        return tmin;\n    }\n\n    var tType = dtick.charAt(0);\n    var dtNum = Number(dtick.substr(1));\n\n    // Dates: months (or years)\n    if(tType === 'M') {\n        var cnt = 0;\n        var t0 = tick0;\n        var t1, mult, newDTick;\n\n        // This algorithm should work for *any* nonlinear (but close to linear!)\n        // tick spacing. Limit to 10 iterations, for gregorian months it's normally <=3.\n        while(cnt < 10) {\n            t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);\n            if((t1 - r0) * (t0 - r0) <= 0) {\n                // t1 and t0 are on opposite sides of r0! we've succeeded!\n                if(axrev) return Math.min(t0, t1);\n                return Math.max(t0, t1);\n            }\n            mult = (r0 - ((t0 + t1) / 2)) / (t1 - t0);\n            newDTick = tType + ((Math.abs(Math.round(mult)) || 1) * dtNum);\n            t0 = axes.tickIncrement(t0, newDTick, mult < 0 ? !axrev : axrev, ax.calendar);\n            cnt++;\n        }\n        Lib.error('tickFirst did not converge', ax);\n        return t0;\n    } else if(tType === 'L') {\n        // Log scales: Linear, Digits\n\n        return Math.log(sRound(\n            (Math.pow(10, r0) - tick0) / dtNum) * dtNum + tick0) / Math.LN10;\n    } else if(tType === 'D') {\n        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1;\n        var frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);\n\n        return Math.floor(r0) +\n            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n    } else throw 'unrecognized dtick ' + String(dtick);\n};\n\n// draw the text for one tick.\n// px,py are the location on gd.paper\n// prefix is there so the x axis ticks can be dropped a line\n// ax is the axis layout, x is the tick value\n// hover is a (truthy) flag for whether to show numbers with a bit\n// more precision for hovertext\naxes.tickText = function(ax, x, hover, noSuffixPrefix) {\n    var out = tickTextObj(ax, x);\n    var arrayMode = ax.tickmode === 'array';\n    var extraPrecision = hover || arrayMode;\n    var axType = ax.type;\n    // TODO multicategory, if we allow ticktext / tickvals\n    var tickVal2l = axType === 'category' ? ax.d2l_noadd : ax.d2l;\n    var i;\n\n    var inbounds = function(v) {\n        var p = ax.l2p(v);\n        return p >= 0 && p <= ax._length ? v : null;\n    };\n    if(arrayMode && Lib.isArrayOrTypedArray(ax.ticktext)) {\n        var rng = Lib.simpleMap(ax.range, ax.r2l);\n        var minDiff = (Math.abs(rng[1] - rng[0]) - (ax._lBreaks || 0)) / 10000;\n\n        for(i = 0; i < ax.ticktext.length; i++) {\n            if(Math.abs(x - tickVal2l(ax.tickvals[i])) < minDiff) break;\n        }\n        if(i < ax.ticktext.length) {\n            out.text = String(ax.ticktext[i]);\n\n            out.xbnd = [\n                inbounds(out.x - 0.5),\n                inbounds(out.x + ax.dtick - 0.5)\n            ];\n            return out;\n        }\n    }\n\n    function isHidden(showAttr) {\n        if(showAttr === undefined) return true;\n        if(hover) return showAttr === 'none';\n\n        var firstOrLast = {\n            first: ax._tmin,\n            last: ax._tmax\n        }[showAttr];\n\n        return showAttr !== 'all' && x !== firstOrLast;\n    }\n\n    var hideexp = hover ?\n        'never' :\n        ax.exponentformat !== 'none' && isHidden(ax.showexponent) ? 'hide' : '';\n\n    if(axType === 'date') formatDate(ax, out, hover, extraPrecision);\n    else if(axType === 'log') formatLog(ax, out, hover, extraPrecision, hideexp);\n    else if(axType === 'category') formatCategory(ax, out);\n    else if(axType === 'multicategory') formatMultiCategory(ax, out, hover);\n    else if(isAngular(ax)) formatAngle(ax, out, hover, extraPrecision, hideexp);\n    else formatLinear(ax, out, hover, extraPrecision, hideexp);\n\n    // add prefix and suffix\n    if(!noSuffixPrefix) {\n        if(ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;\n        if(ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;\n    }\n\n    if(ax.labelalias && ax.labelalias.hasOwnProperty(out.text)) {\n        var t = ax.labelalias[out.text];\n        if(typeof t === 'string') out.text = t;\n    }\n\n    // Setup ticks and grid lines boundaries\n    // at 1/2 a 'category' to the left/bottom\n    if(ax.tickson === 'boundaries' || ax.showdividers) {\n        out.xbnd = [\n            inbounds(out.x - 0.5),\n            inbounds(out.x + ax.dtick - 0.5)\n        ];\n    }\n\n    return out;\n};\n\n/**\n * create text for a hover label on this axis, with special handling of\n * log axes (where negative values can't be displayed but can appear in hover text)\n *\n * @param {object} ax: the axis to format text for\n * @param {number or array of numbers} values: calcdata value(s) to format\n * @param {Optional(string)} hoverformat: trace (x|y)hoverformat to override axis.hoverformat\n *\n * @returns {string} `val` formatted as a string appropriate to this axis, or\n *     first value and second value as a range (ie '<val1> - <val2>') if the second value is provided and\n *     it's different from the first value.\n */\naxes.hoverLabelText = function(ax, values, hoverformat) {\n    if(hoverformat) ax = Lib.extendFlat({}, ax, {hoverformat: hoverformat});\n\n    var val = Lib.isArrayOrTypedArray(values) ? values[0] : values;\n    var val2 = Lib.isArrayOrTypedArray(values) ? values[1] : undefined;\n    if(val2 !== undefined && val2 !== val) {\n        return (\n            axes.hoverLabelText(ax, val, hoverformat) + ' - ' +\n            axes.hoverLabelText(ax, val2, hoverformat)\n        );\n    }\n\n    var logOffScale = (ax.type === 'log' && val <= 0);\n    var tx = axes.tickText(ax, ax.c2l(logOffScale ? -val : val), 'hover').text;\n\n    if(logOffScale) {\n        return val === 0 ? '0' : MINUS_SIGN + tx;\n    }\n\n    // TODO: should we do something special if the axis calendar and\n    // the data calendar are different? Somehow display both dates with\n    // their system names? Right now it will just display in the axis calendar\n    // but users could add the other one as text.\n    return tx;\n};\n\nfunction tickTextObj(ax, x, text) {\n    var tf = ax.tickfont || {};\n\n    return {\n        x: x,\n        dx: 0,\n        dy: 0,\n        text: text || '',\n        fontSize: tf.size,\n        font: tf.family,\n        fontColor: tf.color\n    };\n}\n\nfunction formatDate(ax, out, hover, extraPrecision) {\n    var tr = ax._tickround;\n    var fmt = (hover && ax.hoverformat) || axes.getTickFormat(ax);\n\n    // Only apply extra precision if no explicit format was provided.\n    extraPrecision = !fmt && extraPrecision;\n\n    if(extraPrecision) {\n        // second or sub-second precision: extra always shows max digits.\n        // for other fields, extra precision just adds one field.\n        if(isNumeric(tr)) tr = 4;\n        else tr = {y: 'm', m: 'd', d: 'M', M: 'S', S: 4}[tr];\n    }\n\n    var dateStr = Lib.formatDate(out.x, fmt, tr, ax._dateFormat, ax.calendar, ax._extraFormat);\n    var headStr;\n\n    var splitIndex = dateStr.indexOf('\\n');\n    if(splitIndex !== -1) {\n        headStr = dateStr.substr(splitIndex + 1);\n        dateStr = dateStr.substr(0, splitIndex);\n    }\n\n    if(extraPrecision) {\n        // if extraPrecision led to trailing zeros, strip them off\n        // actually, this can lead to removing even more zeros than\n        // in the original rounding, but that's fine because in these\n        // contexts uniformity is not so important (if there's even\n        // anything to be uniform with!)\n\n        // can we remove the whole time part?\n        if(headStr !== undefined && (dateStr === '00:00:00' || dateStr === '00:00')) {\n            dateStr = headStr;\n            headStr = '';\n        } else if(dateStr.length === 8) {\n            // strip off seconds if they're zero (zero fractional seconds\n            // are already omitted)\n            // but we never remove minutes and leave just hours\n            dateStr = dateStr.replace(/:00$/, '');\n        }\n    }\n\n    if(headStr) {\n        if(hover) {\n            // hover puts it all on one line, so headPart works best up front\n            // except for year headPart: turn this into \"Jan 1, 2000\" etc.\n            if(tr === 'd') dateStr += ', ' + headStr;\n            else dateStr = headStr + (dateStr ? ', ' + dateStr : '');\n        } else {\n            if(\n                !ax._inCalcTicks ||\n                ax._prevDateHead !== headStr\n            ) {\n                ax._prevDateHead = headStr;\n                dateStr += '<br>' + headStr;\n            } else {\n                var isInside = insideTicklabelposition(ax);\n                var side = ax._trueSide || ax.side; // polar mocks the side of the radial axis\n                if(\n                    (!isInside && side === 'top') ||\n                    (isInside && side === 'bottom')\n                ) {\n                    dateStr += '<br> ';\n                }\n            }\n        }\n    }\n\n    out.text = dateStr;\n}\n\nfunction formatLog(ax, out, hover, extraPrecision, hideexp) {\n    var dtick = ax.dtick;\n    var x = out.x;\n    var tickformat = ax.tickformat;\n    var dtChar0 = typeof dtick === 'string' && dtick.charAt(0);\n\n    if(hideexp === 'never') {\n        // If this is a hover label, then we must *never* hide the exponent\n        // for the sake of display, which could give the wrong value by\n        // potentially many orders of magnitude. If hideexp was 'never', then\n        // it's now succeeded by preventing the other condition from automating\n        // this choice. Thus we can unset it so that the axis formatting takes\n        // precedence.\n        hideexp = '';\n    }\n\n    if(extraPrecision && (dtChar0 !== 'L')) {\n        dtick = 'L3';\n        dtChar0 = 'L';\n    }\n\n    if(tickformat || (dtChar0 === 'L')) {\n        out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);\n    } else if(isNumeric(dtick) || ((dtChar0 === 'D') && (Lib.mod(x + 0.01, 1) < 0.1))) {\n        var p = Math.round(x);\n        var absP = Math.abs(p);\n        var exponentFormat = ax.exponentformat;\n        if(exponentFormat === 'power' || (isSIFormat(exponentFormat) && beyondSI(p))) {\n            if(p === 0) out.text = 1;\n            else if(p === 1) out.text = '10';\n            else out.text = '10<sup>' + (p > 1 ? '' : MINUS_SIGN) + absP + '</sup>';\n\n            out.fontSize *= 1.25;\n        } else if((exponentFormat === 'e' || exponentFormat === 'E') && absP > 2) {\n            out.text = '1' + exponentFormat + (p > 0 ? '+' : MINUS_SIGN) + absP;\n        } else {\n            out.text = numFormat(Math.pow(10, x), ax, '', 'fakehover');\n            if(dtick === 'D1' && ax._id.charAt(0) === 'y') {\n                out.dy -= out.fontSize / 6;\n            }\n        }\n    } else if(dtChar0 === 'D') {\n        out.text = String(Math.round(Math.pow(10, Lib.mod(x, 1))));\n        out.fontSize *= 0.75;\n    } else throw 'unrecognized dtick ' + String(dtick);\n\n    // if 9's are printed on log scale, move the 10's away a bit\n    if(ax.dtick === 'D1') {\n        var firstChar = String(out.text).charAt(0);\n        if(firstChar === '0' || firstChar === '1') {\n            if(ax._id.charAt(0) === 'y') {\n                out.dx -= out.fontSize / 4;\n            } else {\n                out.dy += out.fontSize / 2;\n                out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) *\n                    out.fontSize * (x < 0 ? 0.5 : 0.25);\n            }\n        }\n    }\n}\n\nfunction formatCategory(ax, out) {\n    var tt = ax._categories[Math.round(out.x)];\n    if(tt === undefined) tt = '';\n    out.text = String(tt);\n}\n\nfunction formatMultiCategory(ax, out, hover) {\n    var v = Math.round(out.x);\n    var cats = ax._categories[v] || [];\n    var tt = cats[1] === undefined ? '' : String(cats[1]);\n    var tt2 = cats[0] === undefined ? '' : String(cats[0]);\n\n    if(hover) {\n        // TODO is this what we want?\n        out.text = tt2 + ' - ' + tt;\n    } else {\n        // setup for secondary labels\n        out.text = tt;\n        out.text2 = tt2;\n    }\n}\n\nfunction formatLinear(ax, out, hover, extraPrecision, hideexp) {\n    if(hideexp === 'never') {\n        // If this is a hover label, then we must *never* hide the exponent\n        // for the sake of display, which could give the wrong value by\n        // potentially many orders of magnitude. If hideexp was 'never', then\n        // it's now succeeded by preventing the other condition from automating\n        // this choice. Thus we can unset it so that the axis formatting takes\n        // precedence.\n        hideexp = '';\n    } else if(ax.showexponent === 'all' && Math.abs(out.x / ax.dtick) < 1e-6) {\n        // don't add an exponent to zero if we're showing all exponents\n        // so the only reason you'd show an exponent on zero is if it's the\n        // ONLY tick to get an exponent (first or last)\n        hideexp = 'hide';\n    }\n    out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n}\n\nfunction formatAngle(ax, out, hover, extraPrecision, hideexp) {\n    if(ax.thetaunit === 'radians' && !hover) {\n        var num = out.x / 180;\n\n        if(num === 0) {\n            out.text = '0';\n        } else {\n            var frac = num2frac(num);\n\n            if(frac[1] >= 100) {\n                out.text = numFormat(Lib.deg2rad(out.x), ax, hideexp, extraPrecision);\n            } else {\n                var isNeg = out.x < 0;\n\n                if(frac[1] === 1) {\n                    if(frac[0] === 1) out.text = 'π';\n                    else out.text = frac[0] + 'π';\n                } else {\n                    out.text = [\n                        '<sup>', frac[0], '</sup>',\n                        '⁄',\n                        '<sub>', frac[1], '</sub>',\n                        'π'\n                    ].join('');\n                }\n\n                if(isNeg) out.text = MINUS_SIGN + out.text;\n            }\n        }\n    } else {\n        out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n    }\n}\n\n// inspired by\n// https://github.com/yisibl/num2fraction/blob/master/index.js\nfunction num2frac(num) {\n    function almostEq(a, b) {\n        return Math.abs(a - b) <= 1e-6;\n    }\n\n    function findGCD(a, b) {\n        return almostEq(b, 0) ? a : findGCD(b, a % b);\n    }\n\n    function findPrecision(n) {\n        var e = 1;\n        while(!almostEq(Math.round(n * e) / e, n)) {\n            e *= 10;\n        }\n        return e;\n    }\n\n    var precision = findPrecision(num);\n    var number = num * precision;\n    var gcd = Math.abs(findGCD(number, precision));\n\n    return [\n        // numerator\n        Math.round(number / gcd),\n        // denominator\n        Math.round(precision / gcd)\n    ];\n}\n\n// format a number (tick value) according to the axis settings\n// new, more reliable procedure than d3.round or similar:\n// add half the rounding increment, then stringify and truncate\n// also automatically switch to sci. notation\nvar SIPREFIXES = ['f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T'];\n\nfunction isSIFormat(exponentFormat) {\n    return exponentFormat === 'SI' || exponentFormat === 'B';\n}\n\n// are we beyond the range of common SI prefixes?\n// 10^-16 -> 1x10^-16\n// 10^-15 -> 1f\n// ...\n// 10^14 -> 100T\n// 10^15 -> 1x10^15\n// 10^16 -> 1x10^16\nfunction beyondSI(exponent) {\n    return exponent > 14 || exponent < -15;\n}\n\nfunction numFormat(v, ax, fmtoverride, hover) {\n    var isNeg = v < 0;\n    // max number of digits past decimal point to show\n    var tickRound = ax._tickround;\n    var exponentFormat = fmtoverride || ax.exponentformat || 'B';\n    var exponent = ax._tickexponent;\n    var tickformat = axes.getTickFormat(ax);\n    var separatethousands = ax.separatethousands;\n\n    // special case for hover: set exponent just for this value, and\n    // add a couple more digits of precision over tick labels\n    if(hover) {\n        // make a dummy axis obj to get the auto rounding and exponent\n        var ah = {\n            exponentformat: exponentFormat,\n            minexponent: ax.minexponent,\n            dtick: ax.showexponent === 'none' ? ax.dtick :\n                (isNumeric(v) ? Math.abs(v) || 1 : 1),\n            // if not showing any exponents, don't change the exponent\n            // from what we calculate\n            range: ax.showexponent === 'none' ? ax.range.map(ax.r2d) : [0, v || 1]\n        };\n        autoTickRound(ah);\n        tickRound = (Number(ah._tickround) || 0) + 4;\n        exponent = ah._tickexponent;\n        if(ax.hoverformat) tickformat = ax.hoverformat;\n    }\n\n    if(tickformat) return ax._numFormat(tickformat)(v).replace(/-/g, MINUS_SIGN);\n\n    // 'epsilon' - rounding increment\n    var e = Math.pow(10, -tickRound) / 2;\n\n    // exponentFormat codes:\n    // 'e' (1.2e+6, default)\n    // 'E' (1.2E+6)\n    // 'SI' (1.2M)\n    // 'B' (same as SI except 10^9=B not G)\n    // 'none' (1200000)\n    // 'power' (1.2x10^6)\n    // 'hide' (1.2, use 3rd argument=='hide' to eg\n    //      only show exponent on last tick)\n    if(exponentFormat === 'none') exponent = 0;\n\n    // take the sign out, put it back manually at the end\n    // - makes cases easier\n    v = Math.abs(v);\n    if(v < e) {\n        // 0 is just 0, but may get exponent if it's the last tick\n        v = '0';\n        isNeg = false;\n    } else {\n        v += e;\n        // take out a common exponent, if any\n        if(exponent) {\n            v *= Math.pow(10, -exponent);\n            tickRound += exponent;\n        }\n        // round the mantissa\n        if(tickRound === 0) v = String(Math.floor(v));\n        else if(tickRound < 0) {\n            v = String(Math.round(v));\n            v = v.substr(0, v.length + tickRound);\n            for(var i = tickRound; i < 0; i++) v += '0';\n        } else {\n            v = String(v);\n            var dp = v.indexOf('.') + 1;\n            if(dp) v = v.substr(0, dp + tickRound).replace(/\\.?0+$/, '');\n        }\n        // insert appropriate decimal point and thousands separator\n        v = Lib.numSeparate(v, ax._separators, separatethousands);\n    }\n\n    // add exponent\n    if(exponent && exponentFormat !== 'hide') {\n        if(isSIFormat(exponentFormat) && beyondSI(exponent)) exponentFormat = 'power';\n\n        var signedExponent;\n        if(exponent < 0) signedExponent = MINUS_SIGN + -exponent;\n        else if(exponentFormat !== 'power') signedExponent = '+' + exponent;\n        else signedExponent = String(exponent);\n\n        if(exponentFormat === 'e' || exponentFormat === 'E') {\n            v += exponentFormat + signedExponent;\n        } else if(exponentFormat === 'power') {\n            v += '×10<sup>' + signedExponent + '</sup>';\n        } else if(exponentFormat === 'B' && exponent === 9) {\n            v += 'B';\n        } else if(isSIFormat(exponentFormat)) {\n            v += SIPREFIXES[exponent / 3 + 5];\n        }\n    }\n\n    // put sign back in and return\n    // replace standard minus character (which is technically a hyphen)\n    // with a true minus sign\n    if(isNeg) return MINUS_SIGN + v;\n    return v;\n}\n\naxes.getTickFormat = function(ax) {\n    var i;\n\n    function convertToMs(dtick) {\n        return typeof dtick !== 'string' ? dtick : Number(dtick.replace('M', '')) * ONEAVGMONTH;\n    }\n\n    function compareLogTicks(left, right) {\n        var priority = ['L', 'D'];\n        if(typeof left === typeof right) {\n            if(typeof left === 'number') {\n                return left - right;\n            } else {\n                var leftPriority = priority.indexOf(left.charAt(0));\n                var rightPriority = priority.indexOf(right.charAt(0));\n                if(leftPriority === rightPriority) {\n                    return Number(left.replace(/(L|D)/g, '')) - Number(right.replace(/(L|D)/g, ''));\n                } else {\n                    return leftPriority - rightPriority;\n                }\n            }\n        } else {\n            return typeof left === 'number' ? 1 : -1;\n        }\n    }\n\n    function isProperStop(dtick, range, convert) {\n        var convertFn = convert || function(x) { return x;};\n        var leftDtick = range[0];\n        var rightDtick = range[1];\n        return ((!leftDtick && typeof leftDtick !== 'number') || convertFn(leftDtick) <= convertFn(dtick)) &&\n               ((!rightDtick && typeof rightDtick !== 'number') || convertFn(rightDtick) >= convertFn(dtick));\n    }\n\n    function isProperLogStop(dtick, range) {\n        var isLeftDtickNull = range[0] === null;\n        var isRightDtickNull = range[1] === null;\n        var isDtickInRangeLeft = compareLogTicks(dtick, range[0]) >= 0;\n        var isDtickInRangeRight = compareLogTicks(dtick, range[1]) <= 0;\n        return (isLeftDtickNull || isDtickInRangeLeft) && (isRightDtickNull || isDtickInRangeRight);\n    }\n\n    var tickstop, stopi;\n    if(ax.tickformatstops && ax.tickformatstops.length > 0) {\n        switch(ax.type) {\n            case 'date':\n            case 'linear': {\n                for(i = 0; i < ax.tickformatstops.length; i++) {\n                    stopi = ax.tickformatstops[i];\n                    if(stopi.enabled && isProperStop(ax.dtick, stopi.dtickrange, convertToMs)) {\n                        tickstop = stopi;\n                        break;\n                    }\n                }\n                break;\n            }\n            case 'log': {\n                for(i = 0; i < ax.tickformatstops.length; i++) {\n                    stopi = ax.tickformatstops[i];\n                    if(stopi.enabled && isProperLogStop(ax.dtick, stopi.dtickrange)) {\n                        tickstop = stopi;\n                        break;\n                    }\n                }\n                break;\n            }\n            default:\n        }\n    }\n    return tickstop ? tickstop.value : ax.tickformat;\n};\n\n// getSubplots - extract all subplot IDs we need\n// as an array of items like 'xy', 'x2y', 'x2y2'...\n// sorted by x (x,x2,x3...) then y\n// optionally restrict to only subplots containing axis object ax\n//\n// NOTE: this is currently only used OUTSIDE plotly.js (toolpanel, webapp)\n// ideally we get rid of it there (or just copy this there) and remove it here\naxes.getSubplots = function(gd, ax) {\n    var subplotObj = gd._fullLayout._subplots;\n    var allSubplots = subplotObj.cartesian.concat(subplotObj.gl2d || []);\n\n    var out = ax ? axes.findSubplotsWithAxis(allSubplots, ax) : allSubplots;\n\n    out.sort(function(a, b) {\n        var aParts = a.substr(1).split('y');\n        var bParts = b.substr(1).split('y');\n\n        if(aParts[0] === bParts[0]) return +aParts[1] - +bParts[1];\n        return +aParts[0] - +bParts[0];\n    });\n\n    return out;\n};\n\n// find all subplots with axis 'ax'\n// NOTE: this is only used in axes.getSubplots (only used outside plotly.js) and\n// gl2d/convert (where it restricts axis subplots to only those with gl2d)\naxes.findSubplotsWithAxis = function(subplots, ax) {\n    var axMatch = new RegExp(\n        (ax._id.charAt(0) === 'x') ? ('^' + ax._id + 'y') : (ax._id + '$')\n    );\n    var subplotsWithAx = [];\n\n    for(var i = 0; i < subplots.length; i++) {\n        var sp = subplots[i];\n        if(axMatch.test(sp)) subplotsWithAx.push(sp);\n    }\n\n    return subplotsWithAx;\n};\n\n// makeClipPaths: prepare clipPaths for all single axes and all possible xy pairings\naxes.makeClipPaths = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    // for more info: https://github.com/plotly/plotly.js/issues/2595\n    if(fullLayout._hasOnlyLargeSploms) return;\n\n    var fullWidth = {_offset: 0, _length: fullLayout.width, _id: ''};\n    var fullHeight = {_offset: 0, _length: fullLayout.height, _id: ''};\n    var xaList = axes.list(gd, 'x', true);\n    var yaList = axes.list(gd, 'y', true);\n    var clipList = [];\n    var i, j;\n\n    for(i = 0; i < xaList.length; i++) {\n        clipList.push({x: xaList[i], y: fullHeight});\n        for(j = 0; j < yaList.length; j++) {\n            if(i === 0) clipList.push({x: fullWidth, y: yaList[j]});\n            clipList.push({x: xaList[i], y: yaList[j]});\n        }\n    }\n\n    // selectors don't work right with camelCase tags,\n    // have to use class instead\n    // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I\n    var axClips = fullLayout._clips.selectAll('.axesclip')\n        .data(clipList, function(d) { return d.x._id + d.y._id; });\n\n    axClips.enter().append('clipPath')\n        .classed('axesclip', true)\n        .attr('id', function(d) { return 'clip' + fullLayout._uid + d.x._id + d.y._id; })\n      .append('rect');\n\n    axClips.exit().remove();\n\n    axClips.each(function(d) {\n        d3.select(this).select('rect').attr({\n            x: d.x._offset || 0,\n            y: d.y._offset || 0,\n            width: d.x._length || 1,\n            height: d.y._length || 1\n        });\n    });\n};\n\n/**\n * Main multi-axis drawing routine!\n *\n * @param {DOM element} gd : graph div\n * @param {string or array of strings} arg : polymorphic argument\n * @param {object} opts:\n * - @param {boolean} skipTitle : optional flag to skip axis title draw/update\n *\n * Signature 1: Axes.draw(gd, 'redraw')\n *   use this to clear and redraw all axes on graph\n *\n * Signature 2: Axes.draw(gd, '')\n *   use this to draw all axes on graph w/o the selectAll().remove()\n *   of the 'redraw' signature\n *\n * Signature 3: Axes.draw(gd, [axId, axId2, ...])\n *   where the items are axis id string,\n *   use this to update multiple axes in one call\n *\n * N.B draw updates:\n * - ax._r (stored range for use by zoom/pan)\n * - ax._rl (stored linearized range for use by zoom/pan)\n */\naxes.draw = function(gd, arg, opts) {\n    var fullLayout = gd._fullLayout;\n\n    if(arg === 'redraw') {\n        fullLayout._paper.selectAll('g.subplot').each(function(d) {\n            var id = d[0];\n            var plotinfo = fullLayout._plots[id];\n            if(plotinfo) {\n                var xa = plotinfo.xaxis;\n                var ya = plotinfo.yaxis;\n\n                plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick').remove();\n                plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick').remove();\n                plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick2').remove();\n                plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick2').remove();\n                plotinfo.xaxislayer.selectAll('.' + xa._id + 'divider').remove();\n                plotinfo.yaxislayer.selectAll('.' + ya._id + 'divider').remove();\n\n                if(plotinfo.minorGridlayer) plotinfo.minorGridlayer.selectAll('path').remove();\n                if(plotinfo.gridlayer) plotinfo.gridlayer.selectAll('path').remove();\n                if(plotinfo.zerolinelayer) plotinfo.zerolinelayer.selectAll('path').remove();\n\n                fullLayout._infolayer.select('.g-' + xa._id + 'title').remove();\n                fullLayout._infolayer.select('.g-' + ya._id + 'title').remove();\n            }\n        });\n    }\n\n    var axList = (!arg || arg === 'redraw') ? axes.listIds(gd) : arg;\n\n    var fullAxList = axes.list(gd);\n    // Get the list of the overlaying axis for all 'shift' axes\n    var overlayingShiftedAx = fullAxList.filter(function(ax) {\n        return ax.autoshift;\n    }).map(function(ax) {\n        return ax.overlaying;\n    });\n\n    // order axes that have dependency to other axes\n    axList.map(function(axId) {\n        var ax = axes.getFromId(gd, axId);\n\n        if(ax.tickmode === 'sync' && ax.overlaying) {\n            var overlayingIndex = axList.findIndex(function(axis) {return axis === ax.overlaying;});\n\n            if(overlayingIndex >= 0) {\n                axList.unshift(axList.splice(overlayingIndex, 1).shift());\n            }\n        }\n    });\n\n    var axShifts = {false: {left: 0, right: 0}};\n\n    return Lib.syncOrAsync(axList.map(function(axId) {\n        return function() {\n            if(!axId) return;\n\n            var ax = axes.getFromId(gd, axId);\n\n            if(!opts) opts = {};\n            opts.axShifts = axShifts;\n            opts.overlayingShiftedAx = overlayingShiftedAx;\n\n            var axDone = axes.drawOne(gd, ax, opts);\n\n            if(ax._shiftPusher) {\n                incrementShift(ax, ax._fullDepth || 0, axShifts, true);\n            }\n            ax._r = ax.range.slice();\n            ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n\n            return axDone;\n        };\n    }));\n};\n\n/**\n * Draw one cartesian axis\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n * @param {object} opts\n * - @param {boolean} skipTitle (set to true to skip axis title draw call)\n *\n * Depends on:\n * - ax._mainSubplot (from linkSubplots)\n * - ax._mainAxis\n * - ax._anchorAxis\n * - ax._subplotsWith\n * - ax._counterDomainMin, ax._counterDomainMax (optionally, from linkSubplots)\n * - ax._tickAngles (on redraw only, old value relinked during supplyDefaults)\n * - ax._mainLinePosition (from lsInner)\n * - ax._mainMirrorPosition\n * - ax._linepositions\n *\n * Fills in:\n * - ax._vals:\n * - ax._gridVals:\n * - ax._selections:\n * - ax._tickAngles:\n * - ax._depth (when required only):\n * - and calls ax.setScale\n */\naxes.drawOne = function(gd, ax, opts) {\n    opts = opts || {};\n\n    var axShifts = opts.axShifts || {};\n    var overlayingShiftedAx = opts.overlayingShiftedAx || [];\n\n    var i, sp, plotinfo;\n\n    ax.setScale();\n\n    var fullLayout = gd._fullLayout;\n    var axId = ax._id;\n    var axLetter = axId.charAt(0);\n    var counterLetter = axes.counterLetter(axId);\n    var mainPlotinfo = fullLayout._plots[ax._mainSubplot];\n\n    // this happens when updating matched group with 'missing' axes\n    if(!mainPlotinfo) return;\n\n    ax._shiftPusher = ax.autoshift ||\n        overlayingShiftedAx.indexOf(ax._id) !== -1 ||\n        overlayingShiftedAx.indexOf(ax.overlaying) !== -1;\n    // An axis is also shifted by 1/2 of its own linewidth and inside tick length if applicable\n    // as well as its manually specified `shift` val if we're in the context of `autoshift`\n    if(ax._shiftPusher & ax.anchor === 'free') {\n        var selfPush = (ax.linewidth / 2 || 0);\n        if(ax.ticks === 'inside') {\n            selfPush += ax.ticklen;\n        }\n        incrementShift(ax, selfPush, axShifts, true);\n        incrementShift(ax, (ax.shift || 0), axShifts, false);\n    }\n\n    // Somewhat inelegant way of making sure that the shift value is only updated when the\n    // Axes.DrawOne() function is called from the right context. An issue when redrawing the\n    // axis as result of using the dragbox, for example.\n    if(opts.skipTitle !== true || ax._shift === undefined) ax._shift = setShiftVal(ax, axShifts);\n\n    var mainAxLayer = mainPlotinfo[axLetter + 'axislayer'];\n    var mainLinePosition = ax._mainLinePosition;\n    var mainLinePositionShift = mainLinePosition += ax._shift;\n    var mainMirrorPosition = ax._mainMirrorPosition;\n\n    var vals = ax._vals = axes.calcTicks(ax);\n\n    // Add a couple of axis properties that should cause us to recreate\n    // elements. Used in d3 data function.\n    var axInfo = [ax.mirror, mainLinePositionShift, mainMirrorPosition].join('_');\n    for(i = 0; i < vals.length; i++) {\n        vals[i].axInfo = axInfo;\n    }\n\n    // stash selections to avoid DOM queries e.g.\n    // - stash tickLabels selection, so that drawTitle can use it to scoot title\n    ax._selections = {};\n    // stash tick angle (including the computed 'auto' values) per tick-label class\n    // linkup 'previous' tick angles on redraws\n    if(ax._tickAngles) ax._prevTickAngles = ax._tickAngles;\n    ax._tickAngles = {};\n    // measure [in px] between axis position and outward-most part of bounding box\n    // (touching either the tick label or ticks)\n    // depth can be expansive to compute, so we only do so when required\n    ax._depth = null;\n\n    // calcLabelLevelBbox can be expensive,\n    // so make sure to not call it twice during the same Axes.drawOne call\n    // by stashing label-level bounding boxes per tick-label class\n    var llbboxes = {};\n    function getLabelLevelBbox(suffix) {\n        var cls = axId + (suffix || 'tick');\n        if(!llbboxes[cls]) llbboxes[cls] = calcLabelLevelBbox(ax, cls, mainLinePositionShift);\n        return llbboxes[cls];\n    }\n\n    if(!ax.visible) return;\n\n    var transTickFn = axes.makeTransTickFn(ax);\n    var transTickLabelFn = axes.makeTransTickLabelFn(ax);\n\n    var tickVals;\n    // We remove zero lines, grid lines, and inside ticks if they're within 1px of the end\n    // The key case here is removing zero lines when the axis bound is zero\n    var valsClipped;\n\n    var insideTicks = ax.ticks === 'inside';\n    var outsideTicks = ax.ticks === 'outside';\n\n    if(ax.tickson === 'boundaries') {\n        var boundaryVals = getBoundaryVals(ax, vals);\n        valsClipped = axes.clipEnds(ax, boundaryVals);\n        tickVals = insideTicks ? valsClipped : boundaryVals;\n    } else {\n        valsClipped = axes.clipEnds(ax, vals);\n        tickVals = (insideTicks && ax.ticklabelmode !== 'period') ? valsClipped : vals;\n    }\n\n    var gridVals = ax._gridVals = valsClipped;\n    var dividerVals = getDividerVals(ax, vals);\n\n    if(!fullLayout._hasOnlyLargeSploms) {\n        var subplotsWithAx = ax._subplotsWith;\n\n        // keep track of which subplots (by main counter axis) we've already\n        // drawn grids for, so we don't overdraw overlaying subplots\n        var finishedGrids = {};\n\n        for(i = 0; i < subplotsWithAx.length; i++) {\n            sp = subplotsWithAx[i];\n            plotinfo = fullLayout._plots[sp];\n\n            var counterAxis = plotinfo[counterLetter + 'axis'];\n            var mainCounterID = counterAxis._mainAxis._id;\n            if(finishedGrids[mainCounterID]) continue;\n            finishedGrids[mainCounterID] = 1;\n\n            var gridPath = axLetter === 'x' ?\n                'M0,' + counterAxis._offset + 'v' + counterAxis._length :\n                'M' + counterAxis._offset + ',0h' + counterAxis._length;\n\n            axes.drawGrid(gd, ax, {\n                vals: gridVals,\n                counterAxis: counterAxis,\n                layer: plotinfo.gridlayer.select('.' + axId),\n                minorLayer: plotinfo.minorGridlayer.select('.' + axId),\n                path: gridPath,\n                transFn: transTickFn\n            });\n            axes.drawZeroLine(gd, ax, {\n                counterAxis: counterAxis,\n                layer: plotinfo.zerolinelayer,\n                path: gridPath,\n                transFn: transTickFn\n            });\n        }\n    }\n\n    var tickPath;\n\n    var majorTickSigns = axes.getTickSigns(ax);\n    var minorTickSigns = axes.getTickSigns(ax, 'minor');\n\n    if(ax.ticks || (ax.minor && ax.minor.ticks)) {\n        var majorTickPath = axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[2]);\n        var minorTickPath = axes.makeTickPath(ax, mainLinePositionShift, minorTickSigns[2], { minor: true });\n\n        var mirrorMajorTickPath;\n        var mirrorMinorTickPath;\n\n        var fullMajorTickPath;\n        var fullMinorTickPath;\n\n        if(ax._anchorAxis && ax.mirror && ax.mirror !== true) {\n            mirrorMajorTickPath = axes.makeTickPath(ax, mainMirrorPosition, majorTickSigns[3]);\n            mirrorMinorTickPath = axes.makeTickPath(ax, mainMirrorPosition, minorTickSigns[3], { minor: true });\n\n            fullMajorTickPath = majorTickPath + mirrorMajorTickPath;\n            fullMinorTickPath = minorTickPath + mirrorMinorTickPath;\n        } else {\n            mirrorMajorTickPath = '';\n            mirrorMinorTickPath = '';\n            fullMajorTickPath = majorTickPath;\n            fullMinorTickPath = minorTickPath;\n        }\n\n        if(ax.showdividers && outsideTicks && ax.tickson === 'boundaries') {\n            var dividerLookup = {};\n            for(i = 0; i < dividerVals.length; i++) {\n                dividerLookup[dividerVals[i].x] = 1;\n            }\n            tickPath = function(d) {\n                return dividerLookup[d.x] ? mirrorMajorTickPath : fullMajorTickPath;\n            };\n        } else {\n            tickPath = function(d) {\n                return d.minor ? fullMinorTickPath : fullMajorTickPath;\n            };\n        }\n    }\n\n    axes.drawTicks(gd, ax, {\n        vals: tickVals,\n        layer: mainAxLayer,\n        path: tickPath,\n        transFn: transTickFn\n    });\n\n    if(ax.mirror === 'allticks') {\n        var tickSubplots = Object.keys(ax._linepositions || {});\n\n        for(i = 0; i < tickSubplots.length; i++) {\n            sp = tickSubplots[i];\n            plotinfo = fullLayout._plots[sp];\n            // [bottom or left, top or right], free and main are handled above\n            var linepositions = ax._linepositions[sp] || [];\n\n            var p0 = linepositions[0];\n            var p1 = linepositions[1];\n            var isMinor = linepositions[2];\n\n            var spTickPath =\n                axes.makeTickPath(ax, p0,\n                    isMinor ? majorTickSigns[0] : minorTickSigns[0],\n                    { minor: isMinor }\n                ) +\n                axes.makeTickPath(ax, p1,\n                    isMinor ? majorTickSigns[1] : minorTickSigns[1],\n                    { minor: isMinor }\n                );\n\n            axes.drawTicks(gd, ax, {\n                vals: tickVals,\n                layer: plotinfo[axLetter + 'axislayer'],\n                path: spTickPath,\n                transFn: transTickFn\n            });\n        }\n    }\n\n    var seq = [];\n\n    // tick labels - for now just the main labels.\n    // TODO: mirror labels, esp for subplots\n\n    seq.push(function() {\n        return axes.drawLabels(gd, ax, {\n            vals: vals,\n            layer: mainAxLayer,\n            plotinfo: plotinfo,\n            transFn: transTickLabelFn,\n            labelFns: axes.makeLabelFns(ax, mainLinePositionShift)\n        });\n    });\n\n    if(ax.type === 'multicategory') {\n        var pad = {x: 2, y: 10}[axLetter];\n\n        seq.push(function() {\n            var bboxKey = {x: 'height', y: 'width'}[axLetter];\n            var standoff = getLabelLevelBbox()[bboxKey] + pad +\n                (ax._tickAngles[axId + 'tick'] ? ax.tickfont.size * LINE_SPACING : 0);\n\n            return axes.drawLabels(gd, ax, {\n                vals: getSecondaryLabelVals(ax, vals),\n                layer: mainAxLayer,\n                cls: axId + 'tick2',\n                repositionOnUpdate: true,\n                secondary: true,\n                transFn: transTickFn,\n                labelFns: axes.makeLabelFns(ax, mainLinePositionShift + standoff * majorTickSigns[4])\n            });\n        });\n\n        seq.push(function() {\n            ax._depth = majorTickSigns[4] * (getLabelLevelBbox('tick2')[ax.side] - mainLinePositionShift);\n\n            return drawDividers(gd, ax, {\n                vals: dividerVals,\n                layer: mainAxLayer,\n                path: axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[4], { len: ax._depth }),\n                transFn: transTickFn\n            });\n        });\n    } else if(ax.title.hasOwnProperty('standoff')) {\n        seq.push(function() {\n            ax._depth = majorTickSigns[4] * (getLabelLevelBbox()[ax.side] - mainLinePositionShift);\n        });\n    }\n\n    var hasRangeSlider = Registry.getComponentMethod('rangeslider', 'isVisible')(ax);\n\n    if(!opts.skipTitle &&\n        !(hasRangeSlider && ax.side === 'bottom')\n    ) {\n        seq.push(function() { return drawTitle(gd, ax); });\n    }\n\n    seq.push(function() {\n        var s = ax.side.charAt(0);\n        var sMirror = OPPOSITE_SIDE[ax.side].charAt(0);\n        var pos = axes.getPxPosition(gd, ax);\n        var outsideTickLen = outsideTicks ? ax.ticklen : 0;\n        var llbbox;\n\n        var push;\n        var mirrorPush;\n        var rangeSliderPush;\n\n        if(ax.automargin || hasRangeSlider || ax._shiftPusher) {\n            if(ax.type === 'multicategory') {\n                llbbox = getLabelLevelBbox('tick2');\n            } else {\n                llbbox = getLabelLevelBbox();\n                if(axLetter === 'x' && s === 'b') {\n                    ax._depth = Math.max(llbbox.width > 0 ? llbbox.bottom - pos : 0, outsideTickLen);\n                }\n            }\n        }\n\n        var axDepth = 0;\n        var titleDepth = 0;\n        if(ax._shiftPusher) {\n            axDepth = Math.max(\n                outsideTickLen,\n                llbbox.height > 0 ? (s === 'l' ? pos - llbbox.left : llbbox.right - pos) : 0\n            );\n            if(ax.title.text !== fullLayout._dfltTitle[axLetter]) {\n                titleDepth = (ax._titleStandoff || 0) + (ax._titleScoot || 0);\n                if(s === 'l') {\n                    titleDepth += approxTitleDepth(ax);\n                }\n            }\n\n            ax._fullDepth = Math.max(axDepth, titleDepth);\n        }\n\n        if(ax.automargin) {\n            push = {x: 0, y: 0, r: 0, l: 0, t: 0, b: 0};\n            var domainIndices = [0, 1];\n            var shift = typeof ax._shift === 'number' ? ax._shift : 0;\n            if(axLetter === 'x') {\n                if(s === 'b') {\n                    push[s] = ax._depth;\n                } else {\n                    push[s] = ax._depth = Math.max(llbbox.width > 0 ? pos - llbbox.top : 0, outsideTickLen);\n                    domainIndices.reverse();\n                }\n\n                if(llbbox.width > 0) {\n                    var rExtra = llbbox.right - (ax._offset + ax._length);\n                    if(rExtra > 0) {\n                        push.xr = 1;\n                        push.r = rExtra;\n                    }\n                    var lExtra = ax._offset - llbbox.left;\n                    if(lExtra > 0) {\n                        push.xl = 0;\n                        push.l = lExtra;\n                    }\n                }\n            } else {\n                if(s === 'l') {\n                    ax._depth = Math.max(llbbox.height > 0 ? pos - llbbox.left : 0, outsideTickLen);\n                    push[s] = ax._depth - shift;\n                } else {\n                    ax._depth = Math.max(llbbox.height > 0 ? llbbox.right - pos : 0, outsideTickLen);\n                    push[s] = ax._depth + shift;\n                    domainIndices.reverse();\n                }\n\n                if(llbbox.height > 0) {\n                    var bExtra = llbbox.bottom - (ax._offset + ax._length);\n                    if(bExtra > 0) {\n                        push.yb = 0;\n                        push.b = bExtra;\n                    }\n                    var tExtra = ax._offset - llbbox.top;\n                    if(tExtra > 0) {\n                        push.yt = 1;\n                        push.t = tExtra;\n                    }\n                }\n            }\n\n            push[counterLetter] = ax.anchor === 'free' ?\n                ax.position :\n                ax._anchorAxis.domain[domainIndices[0]];\n\n            if(ax.title.text !== fullLayout._dfltTitle[axLetter]) {\n                push[s] += approxTitleDepth(ax) + (ax.title.standoff || 0);\n            }\n\n            if(ax.mirror && ax.anchor !== 'free') {\n                mirrorPush = {x: 0, y: 0, r: 0, l: 0, t: 0, b: 0};\n\n                mirrorPush[sMirror] = ax.linewidth;\n                if(ax.mirror && ax.mirror !== true) mirrorPush[sMirror] += outsideTickLen;\n\n                if(ax.mirror === true || ax.mirror === 'ticks') {\n                    mirrorPush[counterLetter] = ax._anchorAxis.domain[domainIndices[1]];\n                } else if(ax.mirror === 'all' || ax.mirror === 'allticks') {\n                    mirrorPush[counterLetter] = [ax._counterDomainMin, ax._counterDomainMax][domainIndices[1]];\n                }\n            }\n        }\n        if(hasRangeSlider) {\n            rangeSliderPush = Registry.getComponentMethod('rangeslider', 'autoMarginOpts')(gd, ax);\n        }\n\n        if(typeof ax.automargin === 'string') {\n            filterPush(push, ax.automargin);\n            filterPush(mirrorPush, ax.automargin);\n        }\n\n        Plots.autoMargin(gd, axAutoMarginID(ax), push);\n        Plots.autoMargin(gd, axMirrorAutoMarginID(ax), mirrorPush);\n        Plots.autoMargin(gd, rangeSliderAutoMarginID(ax), rangeSliderPush);\n    });\n\n    return Lib.syncOrAsync(seq);\n};\n\nfunction filterPush(push, automargin) {\n    if(!push) return;\n\n    var keepMargin = Object.keys(MARGIN_MAPPING).reduce(function(data, nextKey) {\n        if(automargin.indexOf(nextKey) !== -1) {\n            MARGIN_MAPPING[nextKey].forEach(function(key) { data[key] = 1;});\n        }\n        return data;\n    }, {});\n    Object.keys(push).forEach(function(key) {\n        if(!keepMargin[key]) {\n            if(key.length === 1) push[key] = 0;\n            else delete push[key];\n        }\n    });\n}\n\nfunction getBoundaryVals(ax, vals) {\n    var out = [];\n    var i;\n\n    // boundaryVals are never used for labels;\n    // no need to worry about the other tickTextObj keys\n    var _push = function(d, bndIndex) {\n        var xb = d.xbnd[bndIndex];\n        if(xb !== null) {\n            out.push(Lib.extendFlat({}, d, {x: xb}));\n        }\n    };\n\n    if(vals.length) {\n        for(i = 0; i < vals.length; i++) {\n            _push(vals[i], 0);\n        }\n        _push(vals[i - 1], 1);\n    }\n\n    return out;\n}\n\nfunction getSecondaryLabelVals(ax, vals) {\n    var out = [];\n    var lookup = {};\n\n    for(var i = 0; i < vals.length; i++) {\n        var d = vals[i];\n        if(lookup[d.text2]) {\n            lookup[d.text2].push(d.x);\n        } else {\n            lookup[d.text2] = [d.x];\n        }\n    }\n\n    for(var k in lookup) {\n        out.push(tickTextObj(ax, Lib.interp(lookup[k], 0.5), k));\n    }\n\n    return out;\n}\n\nfunction getDividerVals(ax, vals) {\n    var out = [];\n    var i, current;\n\n    var reversed = (vals.length && vals[vals.length - 1].x < vals[0].x);\n\n    // never used for labels;\n    // no need to worry about the other tickTextObj keys\n    var _push = function(d, bndIndex) {\n        var xb = d.xbnd[bndIndex];\n        if(xb !== null) {\n            out.push(Lib.extendFlat({}, d, {x: xb}));\n        }\n    };\n\n    if(ax.showdividers && vals.length) {\n        for(i = 0; i < vals.length; i++) {\n            var d = vals[i];\n            if(d.text2 !== current) {\n                _push(d, reversed ? 1 : 0);\n            }\n            current = d.text2;\n        }\n        _push(vals[i - 1], reversed ? 0 : 1);\n    }\n\n    return out;\n}\n\nfunction calcLabelLevelBbox(ax, cls, mainLinePositionShift) {\n    var top, bottom;\n    var left, right;\n\n    if(ax._selections[cls].size()) {\n        top = Infinity;\n        bottom = -Infinity;\n        left = Infinity;\n        right = -Infinity;\n        ax._selections[cls].each(function() {\n            var thisLabel = selectTickLabel(this);\n            // Use parent node <g.(x|y)tick>, to make Drawing.bBox\n            // retrieve a bbox computed with transform info\n            //\n            // To improve perf, it would be nice to use `thisLabel.node()`\n            // (like in fixLabelOverlaps) instead and use Axes.getPxPosition\n            // together with the makeLabelFns outputs and `tickangle`\n            // to compute one bbox per (tick value x tick style)\n            var bb = Drawing.bBox(thisLabel.node().parentNode);\n            top = Math.min(top, bb.top);\n            bottom = Math.max(bottom, bb.bottom);\n            left = Math.min(left, bb.left);\n            right = Math.max(right, bb.right);\n        });\n    } else {\n        var dummyCalc = axes.makeLabelFns(ax, mainLinePositionShift);\n        top = bottom = dummyCalc.yFn({dx: 0, dy: 0, fontSize: 0});\n        left = right = dummyCalc.xFn({dx: 0, dy: 0, fontSize: 0});\n    }\n\n    return {\n        top: top,\n        bottom: bottom,\n        left: left,\n        right: right,\n        height: bottom - top,\n        width: right - left\n    };\n}\n\n/**\n * Which direction do the 'ax.side' values, and free ticks go?\n *\n * @param {object} ax (full) axis object\n *  - {string} _id (starting with 'x' or 'y')\n *  - {string} side\n *  - {string} ticks\n * @return {array} all entries are either -1 or 1\n *  - [0]: sign for top/right ticks (i.e. negative SVG direction)\n *  - [1]: sign for bottom/left ticks (i.e. positive SVG direction)\n *  - [2]: sign for ticks corresponding to 'ax.side'\n *  - [3]: sign for ticks mirroring 'ax.side'\n *  - [4]: sign of arrow starting at axis pointing towards margin\n */\naxes.getTickSigns = function(ax, minor) {\n    var axLetter = ax._id.charAt(0);\n    var sideOpposite = {x: 'top', y: 'right'}[axLetter];\n    var main = ax.side === sideOpposite ? 1 : -1;\n    var out = [-1, 1, main, -main];\n    // then we flip if outside XOR y axis\n\n    var ticks = minor ? (ax.minor || {}).ticks : ax.ticks;\n    if((ticks !== 'inside') === (axLetter === 'x')) {\n        out = out.map(function(v) { return -v; });\n    }\n    // independent of `ticks`; do not flip this one\n    if(ax.side) {\n        out.push({l: -1, t: -1, r: 1, b: 1}[ax.side.charAt(0)]);\n    }\n    return out;\n};\n\n/**\n * Make axis translate transform function\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} _offset\n *  - {fn} l2p\n * @return {fn} function of calcTicks items\n */\naxes.makeTransTickFn = function(ax) {\n    return ax._id.charAt(0) === 'x' ?\n        function(d) { return strTranslate(ax._offset + ax.l2p(d.x), 0); } :\n        function(d) { return strTranslate(0, ax._offset + ax.l2p(d.x)); };\n};\n\naxes.makeTransTickLabelFn = function(ax) {\n    var uv = getTickLabelUV(ax);\n    var u = uv[0];\n    var v = uv[1];\n\n    return ax._id.charAt(0) === 'x' ?\n        function(d) {\n            return strTranslate(\n                u + ax._offset + ax.l2p(getPosX(d)),\n                v\n            );\n        } :\n        function(d) {\n            return strTranslate(\n                v,\n                u + ax._offset + ax.l2p(getPosX(d))\n            );\n        };\n};\n\nfunction getPosX(d) {\n    return d.periodX !== undefined ? d.periodX : d.x;\n}\n\n// u is a shift along the axis,\n// v is a shift perpendicular to the axis\nfunction getTickLabelUV(ax) {\n    var ticklabelposition = ax.ticklabelposition || '';\n    var has = function(str) {\n        return ticklabelposition.indexOf(str) !== -1;\n    };\n\n    var isTop = has('top');\n    var isLeft = has('left');\n    var isRight = has('right');\n    var isBottom = has('bottom');\n    var isInside = has('inside');\n\n    var isAligned = isBottom || isLeft || isTop || isRight;\n\n    // early return\n    if(!isAligned && !isInside) return [0, 0];\n\n    var side = ax.side;\n\n    var u = isAligned ? (ax.tickwidth || 0) / 2 : 0;\n    var v = TEXTPAD;\n\n    var fontSize = ax.tickfont ? ax.tickfont.size : 12;\n    if(isBottom || isTop) {\n        u += fontSize * CAP_SHIFT;\n        v += (ax.linewidth || 0) / 2;\n    }\n    if(isLeft || isRight) {\n        u += (ax.linewidth || 0) / 2;\n        v += TEXTPAD;\n    }\n    if(isInside && side === 'top') {\n        v -= fontSize * (1 - CAP_SHIFT);\n    }\n\n    if(isLeft || isTop) u = -u;\n    if(side === 'bottom' || side === 'right') v = -v;\n\n    return [\n        isAligned ? u : 0,\n        isInside ? v : 0\n    ];\n}\n\n/**\n * Make axis tick path string\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} ticklen\n *  - {number} linewidth\n * @param {number} shift along direction of ticklen\n * @param {1 or -1} sgn tick sign\n * @param {object} opts\n * - {number (optional)} len tick length\n * @return {string}\n */\naxes.makeTickPath = function(ax, shift, sgn, opts) {\n    if(!opts) opts = {};\n    var minor = opts.minor;\n    if(minor && !ax.minor) return '';\n\n    var len = opts.len !== undefined ? opts.len :\n        minor ? ax.minor.ticklen : ax.ticklen;\n\n    var axLetter = ax._id.charAt(0);\n    var pad = (ax.linewidth || 1) / 2;\n\n    return axLetter === 'x' ?\n        'M0,' + (shift + pad * sgn) + 'v' + (len * sgn) :\n        'M' + (shift + pad * sgn) + ',0h' + (len * sgn);\n};\n\n/**\n * Make axis tick label x, y and anchor functions\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} ticklen\n *  - {string} side\n *  - {number} linewidth\n *  - {number} tickfont.size\n *  - {boolean} showline\n * @param {number} shift\n * @param {number} angle [in degrees] ...\n * @return {object}\n *  - {fn} xFn\n *  - {fn} yFn\n *  - {fn} anchorFn\n *  - {fn} heightFn\n *  - {number} labelStandoff (gap parallel to ticks)\n *  - {number} labelShift (gap perpendicular to ticks)\n */\naxes.makeLabelFns = function(ax, shift, angle) {\n    var ticklabelposition = ax.ticklabelposition || '';\n    var has = function(str) {\n        return ticklabelposition.indexOf(str) !== -1;\n    };\n\n    var isTop = has('top');\n    var isLeft = has('left');\n    var isRight = has('right');\n    var isBottom = has('bottom');\n    var isAligned = isBottom || isLeft || isTop || isRight;\n\n    var insideTickLabels = has('inside');\n    var labelsOverTicks =\n        (ticklabelposition === 'inside' && ax.ticks === 'inside') ||\n        (!insideTickLabels && ax.ticks === 'outside' && ax.tickson !== 'boundaries');\n\n    var labelStandoff = 0;\n    var labelShift = 0;\n\n    var tickLen = labelsOverTicks ? ax.ticklen : 0;\n    if(insideTickLabels) {\n        tickLen *= -1;\n    } else if(isAligned) {\n        tickLen = 0;\n    }\n\n    if(labelsOverTicks) {\n        labelStandoff += tickLen;\n        if(angle) {\n            var rad = Lib.deg2rad(angle);\n            labelStandoff = tickLen * Math.cos(rad) + 1;\n            labelShift = tickLen * Math.sin(rad);\n        }\n    }\n\n    if(ax.showticklabels && (labelsOverTicks || ax.showline)) {\n        labelStandoff += 0.2 * ax.tickfont.size;\n    }\n    labelStandoff += (ax.linewidth || 1) / 2 * (insideTickLabels ? -1 : 1);\n\n    var out = {\n        labelStandoff: labelStandoff,\n        labelShift: labelShift\n    };\n\n    var x0, y0, ff, flipIt;\n    var xQ = 0;\n\n    var side = ax.side;\n    var axLetter = ax._id.charAt(0);\n    var tickangle = ax.tickangle;\n    var endSide;\n    if(axLetter === 'x') {\n        endSide =\n            (!insideTickLabels && side === 'bottom') ||\n            (insideTickLabels && side === 'top');\n\n        flipIt = endSide ? 1 : -1;\n        if(insideTickLabels) flipIt *= -1;\n\n        x0 = labelShift * flipIt;\n        y0 = shift + labelStandoff * flipIt;\n        ff = endSide ? 1 : -0.2;\n        if(Math.abs(tickangle) === 90) {\n            if(insideTickLabels) {\n                ff += MID_SHIFT;\n            } else {\n                if(tickangle === -90 && side === 'bottom') {\n                    ff = CAP_SHIFT;\n                } else if(tickangle === 90 && side === 'top') {\n                    ff = MID_SHIFT;\n                } else {\n                    ff = 0.5;\n                }\n            }\n\n            xQ = (MID_SHIFT / 2) * (tickangle / 90);\n        }\n\n        out.xFn = function(d) { return d.dx + x0 + xQ * d.fontSize; };\n        out.yFn = function(d) { return d.dy + y0 + d.fontSize * ff; };\n        out.anchorFn = function(d, a) {\n            if(isAligned) {\n                if(isLeft) return 'end';\n                if(isRight) return 'start';\n            }\n\n            if(!isNumeric(a) || a === 0 || a === 180) {\n                return 'middle';\n            }\n\n            return ((a * flipIt < 0) !== insideTickLabels) ? 'end' : 'start';\n        };\n        out.heightFn = function(d, a, h) {\n            return (a < -60 || a > 60) ? -0.5 * h :\n                ((ax.side === 'top') !== insideTickLabels) ? -h :\n                0;\n        };\n    } else if(axLetter === 'y') {\n        endSide =\n            (!insideTickLabels && side === 'left') ||\n            (insideTickLabels && side === 'right');\n\n        flipIt = endSide ? 1 : -1;\n        if(insideTickLabels) flipIt *= -1;\n\n        x0 = labelStandoff;\n        y0 = labelShift * flipIt;\n        ff = 0;\n        if(!insideTickLabels && Math.abs(tickangle) === 90) {\n            if(\n                (tickangle === -90 && side === 'left') ||\n                (tickangle === 90 && side === 'right')\n            ) {\n                ff = CAP_SHIFT;\n            } else {\n                ff = 0.5;\n            }\n        }\n\n        if(insideTickLabels) {\n            var ang = isNumeric(tickangle) ? +tickangle : 0;\n            if(ang !== 0) {\n                var rA = Lib.deg2rad(ang);\n                xQ = Math.abs(Math.sin(rA)) * CAP_SHIFT * flipIt;\n                ff = 0;\n            }\n        }\n\n        out.xFn = function(d) { return d.dx + shift - (x0 + d.fontSize * ff) * flipIt + xQ * d.fontSize; };\n        out.yFn = function(d) { return d.dy + y0 + d.fontSize * MID_SHIFT; };\n        out.anchorFn = function(d, a) {\n            if(isNumeric(a) && Math.abs(a) === 90) {\n                return 'middle';\n            }\n\n            return endSide ? 'end' : 'start';\n        };\n        out.heightFn = function(d, a, h) {\n            if(ax.side === 'right') a *= -1;\n\n            return a < -30 ? -h :\n                a < 30 ? -0.5 * h :\n                0;\n        };\n    }\n\n    return out;\n};\n\nfunction tickDataFn(d) {\n    return [d.text, d.x, d.axInfo, d.font, d.fontSize, d.fontColor].join('_');\n}\n\n/**\n * Draw axis ticks\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} linewidth\n *  - {string} tickcolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawTicks = function(gd, ax, opts) {\n    opts = opts || {};\n\n    var cls = ax._id + 'tick';\n\n    var vals = []\n        .concat(ax.minor && ax.minor.ticks ?\n            // minor vals\n            opts.vals.filter(function(d) { return d.minor && !d.noTick; }) :\n            []\n        )\n        .concat(ax.ticks ?\n            // major vals\n            opts.vals.filter(function(d) { return !d.minor && !d.noTick; }) :\n            []\n        );\n\n    var ticks = opts.layer.selectAll('path.' + cls)\n        .data(vals, tickDataFn);\n\n    ticks.exit().remove();\n\n    ticks.enter().append('path')\n        .classed(cls, 1)\n        .classed('ticks', 1)\n        .classed('crisp', opts.crisp !== false)\n        .each(function(d) {\n            return Color.stroke(d3.select(this), d.minor ? ax.minor.tickcolor : ax.tickcolor);\n        })\n        .style('stroke-width', function(d) {\n            return Drawing.crispRound(\n                gd,\n                d.minor ? ax.minor.tickwidth : ax.tickwidth,\n                1\n            ) + 'px';\n        })\n        .attr('d', opts.path)\n        .style('display', null); // visible\n\n    hideCounterAxisInsideTickLabels(ax, [TICK_PATH]);\n\n    ticks.attr('transform', opts.transFn);\n};\n\n/**\n * Draw axis grid\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showgrid\n *  - {string} gridcolor\n *  - {string} gridwidth\n *  - {string} griddash\n *  - {boolean} zeroline\n *  - {string} type\n *  - {string} dtick\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n *     optional - only required if this axis supports zero lines\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawGrid = function(gd, ax, opts) {\n    opts = opts || {};\n\n    if(ax.tickmode === 'sync') {\n        // for tickmode sync we use the overlaying axis grid\n        return;\n    }\n\n    var cls = ax._id + 'grid';\n\n    var hasMinor = ax.minor && ax.minor.showgrid;\n    var minorVals = hasMinor ? opts.vals.filter(function(d) { return d.minor; }) : [];\n    var majorVals = ax.showgrid ? opts.vals.filter(function(d) { return !d.minor; }) : [];\n\n    var counterAx = opts.counterAxis;\n    if(counterAx && axes.shouldShowZeroLine(gd, ax, counterAx)) {\n        var isArrayMode = ax.tickmode === 'array';\n        for(var i = 0; i < majorVals.length; i++) {\n            var xi = majorVals[i].x;\n            if(isArrayMode ? !xi : (Math.abs(xi) < ax.dtick / 100)) {\n                majorVals = majorVals.slice(0, i).concat(majorVals.slice(i + 1));\n                // In array mode you can in principle have multiple\n                // ticks at 0, so test them all. Otherwise once we found\n                // one we can stop.\n                if(isArrayMode) i--;\n                else break;\n            }\n        }\n    }\n\n    ax._gw =\n        Drawing.crispRound(gd, ax.gridwidth, 1);\n\n    var wMinor = !hasMinor ? 0 :\n        Drawing.crispRound(gd, ax.minor.gridwidth, 1);\n\n    var majorLayer = opts.layer;\n    var minorLayer = opts.minorLayer;\n    for(var major = 1; major >= 0; major--) {\n        var layer = major ? majorLayer : minorLayer;\n        if(!layer) continue;\n\n        var grid = layer.selectAll('path.' + cls)\n            .data(major ? majorVals : minorVals, tickDataFn);\n\n        grid.exit().remove();\n\n        grid.enter().append('path')\n            .classed(cls, 1)\n            .classed('crisp', opts.crisp !== false);\n\n        grid.attr('transform', opts.transFn)\n            .attr('d', opts.path)\n            .each(function(d) {\n                return Color.stroke(d3.select(this), d.minor ?\n                    ax.minor.gridcolor :\n                    (ax.gridcolor || '#ddd')\n                );\n            })\n            .style('stroke-dasharray', function(d) {\n                return Drawing.dashStyle(\n                    d.minor ? ax.minor.griddash : ax.griddash,\n                    d.minor ? ax.minor.gridwidth : ax.gridwidth\n                );\n            })\n            .style('stroke-width', function(d) {\n                return (d.minor ? wMinor : ax._gw) + 'px';\n            })\n            .style('display', null); // visible\n\n        if(typeof opts.path === 'function') grid.attr('d', opts.path);\n    }\n\n    hideCounterAxisInsideTickLabels(ax, [GRID_PATH, MINORGRID_PATH]);\n};\n\n/**\n * Draw axis zero-line\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} zeroline\n *  - {number} zerolinewidth\n *  - {string} zerolinecolor\n *  - {number (optional)} _gridWidthCrispRound\n * @param {object} opts\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawZeroLine = function(gd, ax, opts) {\n    opts = opts || opts;\n\n    var cls = ax._id + 'zl';\n    var show = axes.shouldShowZeroLine(gd, ax, opts.counterAxis);\n\n    var zl = opts.layer.selectAll('path.' + cls)\n        .data(show ? [{x: 0, id: ax._id}] : []);\n\n    zl.exit().remove();\n\n    zl.enter().append('path')\n        .classed(cls, 1)\n        .classed('zl', 1)\n        .classed('crisp', opts.crisp !== false)\n        .each(function() {\n            // use the fact that only one element can enter to trigger a sort.\n            // If several zerolines enter at the same time we will sort once per,\n            // but generally this should be a minimal overhead.\n            opts.layer.selectAll('path').sort(function(da, db) {\n                return idSort(da.id, db.id);\n            });\n        });\n\n    zl.attr('transform', opts.transFn)\n        .attr('d', opts.path)\n        .call(Color.stroke, ax.zerolinecolor || Color.defaultLine)\n        .style('stroke-width', Drawing.crispRound(gd, ax.zerolinewidth, ax._gw || 1) + 'px')\n        .style('display', null); // visible\n\n    hideCounterAxisInsideTickLabels(ax, [ZERO_PATH]);\n};\n\n/**\n * Draw axis tick labels\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showticklabels\n *  - {number} tickangle\n *  - {object (optional)} _selections\n *  - {object} (optional)} _tickAngles\n *  - {object} (optional)} _prevTickAngles\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string (optional)} cls (node className)\n * - {boolean} repositionOnUpdate (set to true to reposition update selection)\n * - {boolean} secondary\n * - {fn} transFn\n * - {object} labelFns\n *  + {fn} xFn\n *  + {fn} yFn\n *  + {fn} anchorFn\n *  + {fn} heightFn\n */\naxes.drawLabels = function(gd, ax, opts) {\n    opts = opts || {};\n\n    var fullLayout = gd._fullLayout;\n    var axId = ax._id;\n    var cls = opts.cls || axId + 'tick';\n\n    var vals = opts.vals.filter(function(d) { return d.text; });\n\n    var labelFns = opts.labelFns;\n    var tickAngle = opts.secondary ? 0 : ax.tickangle;\n\n    var prevAngle = (ax._prevTickAngles || {})[cls];\n\n    var tickLabels = opts.layer.selectAll('g.' + cls)\n        .data(ax.showticklabels ? vals : [], tickDataFn);\n\n    var labelsReady = [];\n\n    tickLabels.enter().append('g')\n        .classed(cls, 1)\n        .append('text')\n            // only so tex has predictable alignment that we can\n            // alter later\n            .attr('text-anchor', 'middle')\n            .each(function(d) {\n                var thisLabel = d3.select(this);\n                var newPromise = gd._promises.length;\n\n                thisLabel\n                    .call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d))\n                    .call(Drawing.font, d.font, d.fontSize, d.fontColor)\n                    .text(d.text)\n                    .call(svgTextUtils.convertToTspans, gd);\n\n                if(gd._promises[newPromise]) {\n                    // if we have an async label, we'll deal with that\n                    // all here so take it out of gd._promises and\n                    // instead position the label and promise this in\n                    // labelsReady\n                    labelsReady.push(gd._promises.pop().then(function() {\n                        positionLabels(thisLabel, tickAngle);\n                    }));\n                } else {\n                    // sync label: just position it now.\n                    positionLabels(thisLabel, tickAngle);\n                }\n            });\n\n    hideCounterAxisInsideTickLabels(ax, [TICK_TEXT]);\n\n    tickLabels.exit().remove();\n\n    if(opts.repositionOnUpdate) {\n        tickLabels.each(function(d) {\n            d3.select(this).select('text')\n                .call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d));\n        });\n    }\n\n    function positionLabels(s, angle) {\n        s.each(function(d) {\n            var thisLabel = d3.select(this);\n            var mathjaxGroup = thisLabel.select('.text-math-group');\n            var anchor = labelFns.anchorFn(d, angle);\n\n            var transform = opts.transFn.call(thisLabel.node(), d) +\n                ((isNumeric(angle) && +angle !== 0) ?\n                (' rotate(' + angle + ',' + labelFns.xFn(d) + ',' +\n                    (labelFns.yFn(d) - d.fontSize / 2) + ')') :\n                '');\n\n            // how much to shift a multi-line label to center it vertically.\n            var nLines = svgTextUtils.lineCount(thisLabel);\n            var lineHeight = LINE_SPACING * d.fontSize;\n            var anchorHeight = labelFns.heightFn(d, isNumeric(angle) ? +angle : 0, (nLines - 1) * lineHeight);\n\n            if(anchorHeight) {\n                transform += strTranslate(0, anchorHeight);\n            }\n\n            if(mathjaxGroup.empty()) {\n                var thisText = thisLabel.select('text');\n                thisText.attr({\n                    transform: transform,\n                    'text-anchor': anchor\n                });\n\n                thisText.style('opacity', 1); // visible\n\n                if(ax._adjustTickLabelsOverflow) {\n                    ax._adjustTickLabelsOverflow();\n                }\n            } else {\n                var mjWidth = Drawing.bBox(mathjaxGroup.node()).width;\n                var mjShift = mjWidth * {end: -0.5, start: 0.5}[anchor];\n                mathjaxGroup.attr('transform', transform + strTranslate(mjShift, 0));\n            }\n        });\n    }\n\n    ax._adjustTickLabelsOverflow = function() {\n        var ticklabeloverflow = ax.ticklabeloverflow;\n        if(!ticklabeloverflow || ticklabeloverflow === 'allow') return;\n\n        var hideOverflow = ticklabeloverflow.indexOf('hide') !== -1;\n\n        var isX = ax._id.charAt(0) === 'x';\n        // div positions\n        var p0 = 0;\n        var p1 = isX ?\n            gd._fullLayout.width :\n            gd._fullLayout.height;\n\n        if(ticklabeloverflow.indexOf('domain') !== -1) {\n            // domain positions\n            var rl = Lib.simpleMap(ax.range, ax.r2l);\n            p0 = ax.l2p(rl[0]) + ax._offset;\n            p1 = ax.l2p(rl[1]) + ax._offset;\n        }\n\n        var min = Math.min(p0, p1);\n        var max = Math.max(p0, p1);\n\n        var side = ax.side;\n\n        var visibleLabelMin = Infinity;\n        var visibleLabelMax = -Infinity;\n\n        tickLabels.each(function(d) {\n            var thisLabel = d3.select(this);\n            var mathjaxGroup = thisLabel.select('.text-math-group');\n\n            if(mathjaxGroup.empty()) {\n                var bb = Drawing.bBox(thisLabel.node());\n                var adjust = 0;\n                if(isX) {\n                    if(bb.right > max) adjust = 1;\n                    else if(bb.left < min) adjust = 1;\n                } else {\n                    if(bb.bottom > max) adjust = 1;\n                    else if(bb.top + (ax.tickangle ? 0 : d.fontSize / 4) < min) adjust = 1;\n                }\n\n                var t = thisLabel.select('text');\n                if(adjust) {\n                    if(hideOverflow) t.style('opacity', 0); // hidden\n                } else {\n                    t.style('opacity', 1); // visible\n\n                    if(side === 'bottom' || side === 'right') {\n                        visibleLabelMin = Math.min(visibleLabelMin, isX ? bb.top : bb.left);\n                    } else {\n                        visibleLabelMin = -Infinity;\n                    }\n\n                    if(side === 'top' || side === 'left') {\n                        visibleLabelMax = Math.max(visibleLabelMax, isX ? bb.bottom : bb.right);\n                    } else {\n                        visibleLabelMax = Infinity;\n                    }\n                }\n            } // TODO: hide mathjax?\n        });\n\n        for(var subplot in fullLayout._plots) {\n            var plotinfo = fullLayout._plots[subplot];\n            if(ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n            var anchorAx = isX ? plotinfo.yaxis : plotinfo.xaxis;\n            if(anchorAx) {\n                anchorAx['_visibleLabelMin_' + ax._id] = visibleLabelMin;\n                anchorAx['_visibleLabelMax_' + ax._id] = visibleLabelMax;\n            }\n        }\n    };\n\n    ax._hideCounterAxisInsideTickLabels = function(partialOpts) {\n        var isX = ax._id.charAt(0) === 'x';\n\n        var anchoredAxes = [];\n        for(var subplot in fullLayout._plots) {\n            var plotinfo = fullLayout._plots[subplot];\n            if(ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n            anchoredAxes.push(isX ? plotinfo.yaxis : plotinfo.xaxis);\n        }\n\n        anchoredAxes.forEach(function(anchorAx, idx) {\n            if(anchorAx && insideTicklabelposition(anchorAx)) {\n                (partialOpts || [\n                    ZERO_PATH,\n                    MINORGRID_PATH,\n                    GRID_PATH,\n                    TICK_PATH,\n                    TICK_TEXT\n                ]).forEach(function(e) {\n                    var isPeriodLabel =\n                        e.K === 'tick' &&\n                        e.L === 'text' &&\n                        ax.ticklabelmode === 'period';\n\n                    var mainPlotinfo = fullLayout._plots[ax._mainSubplot];\n\n                    var sel;\n                    if(e.K === ZERO_PATH.K) sel = mainPlotinfo.zerolinelayer.selectAll('.' + ax._id + 'zl');\n                    else if(e.K === MINORGRID_PATH.K) sel = mainPlotinfo.minorGridlayer.selectAll('.' + ax._id);\n                    else if(e.K === GRID_PATH.K) sel = mainPlotinfo.gridlayer.selectAll('.' + ax._id);\n                    else sel = mainPlotinfo[ax._id.charAt(0) + 'axislayer'];\n\n                    sel.each(function() {\n                        var w = d3.select(this);\n                        if(e.L) w = w.selectAll(e.L);\n\n                        w.each(function(d) {\n                            var q = ax.l2p(\n                                isPeriodLabel ? getPosX(d) : d.x\n                            ) + ax._offset;\n\n                            var t = d3.select(this);\n                            if(\n                                q < ax['_visibleLabelMax_' + anchorAx._id] &&\n                                q > ax['_visibleLabelMin_' + anchorAx._id]\n                            ) {\n                                t.style('display', 'none'); // hidden\n                            } else if(e.K === 'tick' && !idx) {\n                                t.style('display', null); // visible\n                            }\n                        });\n                    });\n                });\n            }\n        });\n    };\n\n    // make sure all labels are correctly positioned at their base angle\n    // the positionLabels call above is only for newly drawn labels.\n    // do this without waiting, using the last calculated angle to\n    // minimize flicker, then do it again when we know all labels are\n    // there, putting back the prescribed angle to check for overlaps.\n    positionLabels(tickLabels, (prevAngle + 1) ? prevAngle : tickAngle);\n\n    function allLabelsReady() {\n        return labelsReady.length && Promise.all(labelsReady);\n    }\n\n    var autoangle = null;\n\n    function fixLabelOverlaps() {\n        positionLabels(tickLabels, tickAngle);\n\n        // check for auto-angling if x labels overlap\n        // don't auto-angle at all for log axes with\n        // base and digit format\n        if(vals.length && ax.autotickangles &&\n            (ax.type !== 'log' || String(ax.dtick).charAt(0) !== 'D')\n        ) {\n            autoangle = ax.autotickangles[0];\n\n            var maxFontSize = 0;\n            var lbbArray = [];\n            var i;\n            var maxLines = 1;\n            tickLabels.each(function(d) {\n                maxFontSize = Math.max(maxFontSize, d.fontSize);\n\n                var x = ax.l2p(d.x);\n                var thisLabel = selectTickLabel(this);\n                var bb = Drawing.bBox(thisLabel.node());\n                maxLines = Math.max(maxLines, svgTextUtils.lineCount(thisLabel));\n\n                lbbArray.push({\n                    // ignore about y, just deal with x overlaps\n                    top: 0,\n                    bottom: 10,\n                    height: 10,\n                    left: x - bb.width / 2,\n                    // impose a 2px gap\n                    right: x + bb.width / 2 + 2,\n                    width: bb.width + 2\n                });\n            });\n\n            if((ax.tickson === 'boundaries' || ax.showdividers) && !opts.secondary) {\n                var gap = 2;\n                if(ax.ticks) gap += ax.tickwidth / 2;\n\n                // TODO should secondary labels also fall into this fix-overlap regime?\n\n                for(i = 0; i < lbbArray.length; i++) {\n                    var xbnd = vals[i].xbnd;\n                    var lbb = lbbArray[i];\n                    if(\n                        (xbnd[0] !== null && (lbb.left - ax.l2p(xbnd[0])) < gap) ||\n                        (xbnd[1] !== null && (ax.l2p(xbnd[1]) - lbb.right) < gap)\n                    ) {\n                        autoangle = 90;\n                        break;\n                    }\n                }\n            } else {\n                var vLen = vals.length;\n                var tickSpacing = Math.abs((vals[vLen - 1].x - vals[0].x) * ax._m) / (vLen - 1);\n\n                var ticklabelposition = ax.ticklabelposition || '';\n                var has = function(str) {\n                    return ticklabelposition.indexOf(str) !== -1;\n                };\n                var isTop = has('top');\n                var isLeft = has('left');\n                var isRight = has('right');\n                var isBottom = has('bottom');\n                var isAligned = isBottom || isLeft || isTop || isRight;\n                var pad = !isAligned ? 0 :\n                    (ax.tickwidth || 0) + 2 * TEXTPAD;\n\n                // autotickangles\n                var adjacent = tickSpacing;\n                var opposite = maxFontSize * 1.25 * maxLines;\n                var hypotenuse = Math.sqrt(Math.pow(adjacent, 2) + Math.pow(opposite, 2));\n                var maxCos = adjacent / hypotenuse;\n                var autoTickAnglesRadians = ax.autotickangles.map(\n                    function(degrees) { return degrees * Math.PI / 180; }\n                );\n                var angleRadians = autoTickAnglesRadians.find(\n                    function(angle) { return Math.abs(Math.cos(angle)) <= maxCos; }\n                );\n                if(angleRadians === undefined) {\n                    // no angle with smaller cosine than maxCos, just pick the angle with smallest cosine\n                    angleRadians = autoTickAnglesRadians.reduce(\n                        function(currentMax, nextAngle) {\n                            return Math.abs(Math.cos(currentMax)) < Math.abs(Math.cos(nextAngle)) ? currentMax : nextAngle;\n                        }\n                        , autoTickAnglesRadians[0]\n                    );\n                }\n                var newAngle = angleRadians * (180 / Math.PI /* to degrees */);\n\n                for(i = 0; i < lbbArray.length - 1; i++) {\n                    if(Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1], pad)) {\n                        autoangle = newAngle;\n                        break;\n                    }\n                }\n            }\n\n            if(autoangle) {\n                positionLabels(tickLabels, autoangle);\n            }\n        }\n    }\n\n    if(ax._selections) {\n        ax._selections[cls] = tickLabels;\n    }\n\n    var seq = [allLabelsReady];\n\n    // N.B. during auto-margin redraws, if the axis fixed its label overlaps\n    // by rotating 90 degrees, do not attempt to re-fix its label overlaps\n    // as this can lead to infinite redraw loops!\n    if(ax.automargin && fullLayout._redrawFromAutoMarginCount && prevAngle === 90) {\n        autoangle = prevAngle;\n        seq.push(function() {\n            positionLabels(tickLabels, prevAngle);\n        });\n    } else {\n        seq.push(fixLabelOverlaps);\n    }\n\n    // save current tick angle for future redraws\n    if(ax._tickAngles) {\n        seq.push(function() {\n            ax._tickAngles[cls] = autoangle === null ?\n                (isNumeric(tickAngle) ? tickAngle : 0) :\n                autoangle;\n        });\n    }\n\n    var computeTickLabelBoundingBoxes = function() {\n        var labelsMaxW = 0;\n        var labelsMaxH = 0;\n        tickLabels.each(function(d, i) {\n            var thisLabel = selectTickLabel(this);\n            var mathjaxGroup = thisLabel.select('.text-math-group');\n\n            if(mathjaxGroup.empty()) {\n                var bb;\n\n                if(ax._vals[i]) {\n                    bb = ax._vals[i].bb || Drawing.bBox(thisLabel.node());\n                    ax._vals[i].bb = bb;\n                }\n\n                labelsMaxW = Math.max(labelsMaxW, bb.width);\n                labelsMaxH = Math.max(labelsMaxH, bb.height);\n            }\n        });\n\n        return {\n            labelsMaxW: labelsMaxW,\n            labelsMaxH: labelsMaxH\n        };\n    };\n\n    var anchorAx = ax._anchorAxis;\n    if(\n        anchorAx && (anchorAx.autorange || anchorAx.insiderange) &&\n        insideTicklabelposition(ax) &&\n        !isLinked(fullLayout, ax._id)\n    ) {\n        if(!fullLayout._insideTickLabelsUpdaterange) {\n            fullLayout._insideTickLabelsUpdaterange = {};\n        }\n\n        if(anchorAx.autorange) {\n            fullLayout._insideTickLabelsUpdaterange[anchorAx._name + '.autorange'] = anchorAx.autorange;\n\n            seq.push(computeTickLabelBoundingBoxes);\n        }\n\n        if(anchorAx.insiderange) {\n            var BBs = computeTickLabelBoundingBoxes();\n            var move = ax._id.charAt(0) === 'y' ?\n                BBs.labelsMaxW :\n                BBs.labelsMaxH;\n\n            move += 2 * TEXTPAD;\n\n            if(ax.ticklabelposition === 'inside') {\n                move += ax.ticklen || 0;\n            }\n\n            var sgn = (ax.side === 'right' || ax.side === 'top') ? 1 : -1;\n            var index = sgn === 1 ? 1 : 0;\n            var otherIndex = sgn === 1 ? 0 : 1;\n\n            var newRange = [];\n            newRange[otherIndex] = anchorAx.range[otherIndex];\n\n            var anchorAxRange = anchorAx.range;\n\n            var p0 = anchorAx.r2p(anchorAxRange[index]);\n            var p1 = anchorAx.r2p(anchorAxRange[otherIndex]);\n\n            var _tempNewRange = fullLayout._insideTickLabelsUpdaterange[anchorAx._name + '.range'];\n            if(_tempNewRange) { // case of having multiple anchored axes having insideticklabel\n                var q0 = anchorAx.r2p(_tempNewRange[index]);\n                var q1 = anchorAx.r2p(_tempNewRange[otherIndex]);\n\n                var dir = sgn * (ax._id.charAt(0) === 'y' ? 1 : -1);\n\n                if(dir * p0 < dir * q0) {\n                    p0 = q0;\n                    newRange[index] = anchorAxRange[index] = _tempNewRange[index];\n                }\n\n                if(dir * p1 > dir * q1) {\n                    p1 = q1;\n                    newRange[otherIndex] = anchorAxRange[otherIndex] = _tempNewRange[otherIndex];\n                }\n            }\n\n            var dist = Math.abs(p1 - p0);\n            if(dist - move > 0) {\n                dist -= move;\n                move *= 1 + move / dist;\n            } else {\n                move = 0;\n            }\n\n            if(ax._id.charAt(0) !== 'y') move = -move;\n\n            newRange[index] = anchorAx.p2r(\n                anchorAx.r2p(anchorAxRange[index]) +\n                sgn * move\n            );\n\n            // handle partial ranges in insiderange\n            if(\n                anchorAx.autorange === 'min' ||\n                anchorAx.autorange === 'max reversed'\n            ) {\n                newRange[0] = null;\n\n                anchorAx._rangeInitial0 = undefined;\n                anchorAx._rangeInitial1 = undefined;\n            } else if(\n                anchorAx.autorange === 'max' ||\n                anchorAx.autorange === 'min reversed'\n            ) {\n                newRange[1] = null;\n\n                anchorAx._rangeInitial0 = undefined;\n                anchorAx._rangeInitial1 = undefined;\n            }\n\n            fullLayout._insideTickLabelsUpdaterange[anchorAx._name + '.range'] = newRange;\n        }\n    }\n\n    var done = Lib.syncOrAsync(seq);\n    if(done && done.then) gd._promises.push(done);\n    return done;\n};\n\n/**\n * Draw axis dividers\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} showdividers\n *  - {number} dividerwidth\n *  - {string} dividercolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {fn} path\n * - {fn} transFn\n */\nfunction drawDividers(gd, ax, opts) {\n    var cls = ax._id + 'divider';\n    var vals = opts.vals;\n\n    var dividers = opts.layer.selectAll('path.' + cls)\n        .data(vals, tickDataFn);\n\n    dividers.exit().remove();\n\n    dividers.enter().insert('path', ':first-child')\n        .classed(cls, 1)\n        .classed('crisp', 1)\n        .call(Color.stroke, ax.dividercolor)\n        .style('stroke-width', Drawing.crispRound(gd, ax.dividerwidth, 1) + 'px');\n\n    dividers\n        .attr('transform', opts.transFn)\n        .attr('d', opts.path);\n}\n\n/**\n * Get axis position in px, that is the distance for the graph's\n * top (left) edge for x (y) axes.\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} side\n *  if anchored:\n *  - {object} _anchorAxis\n *  Otherwise:\n *  - {number} position\n * @return {number}\n */\naxes.getPxPosition = function(gd, ax) {\n    var gs = gd._fullLayout._size;\n    var axLetter = ax._id.charAt(0);\n    var side = ax.side;\n    var anchorAxis;\n\n    if(ax.anchor !== 'free') {\n        anchorAxis = ax._anchorAxis;\n    } else if(axLetter === 'x') {\n        anchorAxis = {\n            _offset: gs.t + (1 - (ax.position || 0)) * gs.h,\n            _length: 0\n        };\n    } else if(axLetter === 'y') {\n        anchorAxis = {\n            _offset: gs.l + (ax.position || 0) * gs.w + ax._shift,\n            _length: 0\n        };\n    }\n\n    if(side === 'top' || side === 'left') {\n        return anchorAxis._offset;\n    } else if(side === 'bottom' || side === 'right') {\n        return anchorAxis._offset + anchorAxis._length;\n    }\n};\n\n/**\n * Approximate axis title depth (w/o computing its bounding box)\n *\n * @param {object} ax (full) axis object\n *  - {string} title.text\n *  - {number} title.font.size\n *  - {number} title.standoff\n * @return {number} (in px)\n */\nfunction approxTitleDepth(ax) {\n    var fontSize = ax.title.font.size;\n    var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;\n    if(ax.title.hasOwnProperty('standoff')) {\n        return extraLines ?\n            fontSize * (CAP_SHIFT + (extraLines * LINE_SPACING)) :\n            fontSize * CAP_SHIFT;\n    } else {\n        return extraLines ?\n            fontSize * (extraLines + 1) * LINE_SPACING :\n            fontSize;\n    }\n}\n\n/**\n * Draw axis title, compute default standoff if necessary\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} _name\n *  - {string} side\n *  - {number} title.font.size\n *  - {object} _selections\n *\n *  - {number} _depth\n *  - {number} title.standoff\n *  OR\n *  - {number} linewidth\n *  - {boolean} showticklabels\n */\nfunction drawTitle(gd, ax) {\n    var fullLayout = gd._fullLayout;\n    var axId = ax._id;\n    var axLetter = axId.charAt(0);\n    var fontSize = ax.title.font.size;\n    var titleStandoff;\n\n    if(ax.title.hasOwnProperty('standoff')) {\n        titleStandoff = ax._depth + ax.title.standoff + approxTitleDepth(ax);\n    } else {\n        var isInside = insideTicklabelposition(ax);\n\n        if(ax.type === 'multicategory') {\n            titleStandoff = ax._depth;\n        } else {\n            var offsetBase = 1.5 * fontSize;\n            if(isInside) {\n                offsetBase = 0.5 * fontSize;\n                if(ax.ticks === 'outside') {\n                    offsetBase += ax.ticklen;\n                }\n            }\n            titleStandoff = 10 + offsetBase + (ax.linewidth ? ax.linewidth - 1 : 0);\n        }\n\n        if(!isInside) {\n            if(axLetter === 'x') {\n                titleStandoff += ax.side === 'top' ?\n                    fontSize * (ax.showticklabels ? 1 : 0) :\n                    fontSize * (ax.showticklabels ? 1.5 : 0.5);\n            } else {\n                titleStandoff += ax.side === 'right' ?\n                    fontSize * (ax.showticklabels ? 1 : 0.5) :\n                    fontSize * (ax.showticklabels ? 0.5 : 0);\n            }\n        }\n    }\n\n    var pos = axes.getPxPosition(gd, ax);\n    var transform, x, y;\n\n    if(axLetter === 'x') {\n        x = ax._offset + ax._length / 2;\n        y = (ax.side === 'top') ? pos - titleStandoff : pos + titleStandoff;\n    } else {\n        y = ax._offset + ax._length / 2;\n        x = (ax.side === 'right') ? pos + titleStandoff : pos - titleStandoff;\n        transform = {rotate: '-90', offset: 0};\n    }\n\n    var avoid;\n\n    if(ax.type !== 'multicategory') {\n        var tickLabels = ax._selections[ax._id + 'tick'];\n\n        avoid = {\n            selection: tickLabels,\n            side: ax.side\n        };\n\n        if(tickLabels && tickLabels.node() && tickLabels.node().parentNode) {\n            var translation = Drawing.getTranslate(tickLabels.node().parentNode);\n            avoid.offsetLeft = translation.x;\n            avoid.offsetTop = translation.y;\n        }\n\n        if(ax.title.hasOwnProperty('standoff')) {\n            avoid.pad = 0;\n        }\n    }\n\n    ax._titleStandoff = titleStandoff;\n\n    return Titles.draw(gd, axId + 'title', {\n        propContainer: ax,\n        propName: ax._name + '.title.text',\n        placeholder: fullLayout._dfltTitle[axLetter],\n        avoid: avoid,\n        transform: transform,\n        attributes: {x: x, y: y, 'text-anchor': 'middle'}\n    });\n}\n\naxes.shouldShowZeroLine = function(gd, ax, counterAxis) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    return (\n        (rng[0] * rng[1] <= 0) &&\n        ax.zeroline &&\n        (ax.type === 'linear' || ax.type === '-') &&\n        !(ax.rangebreaks && ax.maskBreaks(0) === BADNUM) &&\n        (\n            clipEnds(ax, 0) ||\n            !anyCounterAxLineAtZero(gd, ax, counterAxis, rng) ||\n            hasBarsOrFill(gd, ax)\n        )\n    );\n};\n\naxes.clipEnds = function(ax, vals) {\n    return vals.filter(function(d) { return clipEnds(ax, d.x); });\n};\n\nfunction clipEnds(ax, l) {\n    var p = ax.l2p(l);\n    return (p > 1 && p < ax._length - 1);\n}\n\nfunction anyCounterAxLineAtZero(gd, ax, counterAxis, rng) {\n    var mainCounterAxis = counterAxis._mainAxis;\n    if(!mainCounterAxis) return;\n\n    var fullLayout = gd._fullLayout;\n    var axLetter = ax._id.charAt(0);\n    var counterLetter = axes.counterLetter(ax._id);\n\n    var zeroPosition = ax._offset + (\n        ((Math.abs(rng[0]) < Math.abs(rng[1])) === (axLetter === 'x')) ?\n        0 : ax._length\n    );\n\n    function lineNearZero(ax2) {\n        if(!ax2.showline || !ax2.linewidth) return false;\n        var tolerance = Math.max((ax2.linewidth + ax.zerolinewidth) / 2, 1);\n\n        function closeEnough(pos2) {\n            return typeof pos2 === 'number' && Math.abs(pos2 - zeroPosition) < tolerance;\n        }\n\n        if(closeEnough(ax2._mainLinePosition) || closeEnough(ax2._mainMirrorPosition)) {\n            return true;\n        }\n        var linePositions = ax2._linepositions || {};\n        for(var k in linePositions) {\n            if(closeEnough(linePositions[k][0]) || closeEnough(linePositions[k][1])) {\n                return true;\n            }\n        }\n    }\n\n    var plotinfo = fullLayout._plots[counterAxis._mainSubplot];\n    if(!(plotinfo.mainplotinfo || plotinfo).overlays.length) {\n        return lineNearZero(counterAxis, zeroPosition);\n    }\n\n    var counterLetterAxes = axes.list(gd, counterLetter);\n    for(var i = 0; i < counterLetterAxes.length; i++) {\n        var counterAxis2 = counterLetterAxes[i];\n        if(\n            counterAxis2._mainAxis === mainCounterAxis &&\n            lineNearZero(counterAxis2, zeroPosition)\n        ) {\n            return true;\n        }\n    }\n}\n\nfunction hasBarsOrFill(gd, ax) {\n    var fullData = gd._fullData;\n    var subplot = ax._mainSubplot;\n    var axLetter = ax._id.charAt(0);\n\n    for(var i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n\n        if(trace.visible === true && (trace.xaxis + trace.yaxis) === subplot) {\n            if(\n                Registry.traceIs(trace, 'bar-like') &&\n                trace.orientation === {x: 'h', y: 'v'}[axLetter]\n            ) return true;\n\n            if(\n                trace.fill &&\n                trace.fill.charAt(trace.fill.length - 1) === axLetter\n            ) return true;\n        }\n    }\n    return false;\n}\n\nfunction selectTickLabel(gTick) {\n    var s = d3.select(gTick);\n    var mj = s.select('.text-math-group');\n    return mj.empty() ? s.select('text') : mj;\n}\n\n/**\n * Find all margin pushers for 2D axes and reserve them for later use\n * Both label and rangeslider automargin calculations happen later so\n * we need to explicitly allow their ids in order to not delete them.\n *\n * TODO: can we pull the actual automargin calls forward to avoid this hack?\n * We're probably also doing multiple redraws in this case, would be faster\n * if we can just do the whole calculation ahead of time and draw once.\n */\naxes.allowAutoMargin = function(gd) {\n    var axList = axes.list(gd, '', true);\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        if(ax.automargin) {\n            Plots.allowAutoMargin(gd, axAutoMarginID(ax));\n            if(ax.mirror) {\n                Plots.allowAutoMargin(gd, axMirrorAutoMarginID(ax));\n            }\n        }\n        if(Registry.getComponentMethod('rangeslider', 'isVisible')(ax)) {\n            Plots.allowAutoMargin(gd, rangeSliderAutoMarginID(ax));\n        }\n    }\n};\n\nfunction axAutoMarginID(ax) { return ax._id + '.automargin'; }\nfunction axMirrorAutoMarginID(ax) { return axAutoMarginID(ax) + '.mirror'; }\nfunction rangeSliderAutoMarginID(ax) { return ax._id + '.rangeslider'; }\n\n// swap all the presentation attributes of the axes showing these traces\naxes.swap = function(gd, traces) {\n    var axGroups = makeAxisGroups(gd, traces);\n\n    for(var i = 0; i < axGroups.length; i++) {\n        swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);\n    }\n};\n\nfunction makeAxisGroups(gd, traces) {\n    var groups = [];\n    var i, j;\n\n    for(i = 0; i < traces.length; i++) {\n        var groupsi = [];\n        var xi = gd._fullData[traces[i]].xaxis;\n        var yi = gd._fullData[traces[i]].yaxis;\n        if(!xi || !yi) continue; // not a 2D cartesian trace?\n\n        for(j = 0; j < groups.length; j++) {\n            if(groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {\n                groupsi.push(j);\n            }\n        }\n\n        if(!groupsi.length) {\n            groups.push({x: [xi], y: [yi]});\n            continue;\n        }\n\n        var group0 = groups[groupsi[0]];\n        var groupj;\n\n        if(groupsi.length > 1) {\n            for(j = 1; j < groupsi.length; j++) {\n                groupj = groups[groupsi[j]];\n                mergeAxisGroups(group0.x, groupj.x);\n                mergeAxisGroups(group0.y, groupj.y);\n            }\n        }\n        mergeAxisGroups(group0.x, [xi]);\n        mergeAxisGroups(group0.y, [yi]);\n    }\n\n    return groups;\n}\n\nfunction mergeAxisGroups(intoSet, fromSet) {\n    for(var i = 0; i < fromSet.length; i++) {\n        if(intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);\n    }\n}\n\nfunction swapAxisGroup(gd, xIds, yIds) {\n    var xFullAxes = [];\n    var yFullAxes = [];\n    var layout = gd.layout;\n    var i, j;\n\n    for(i = 0; i < xIds.length; i++) xFullAxes.push(axes.getFromId(gd, xIds[i]));\n    for(i = 0; i < yIds.length; i++) yFullAxes.push(axes.getFromId(gd, yIds[i]));\n\n    var allAxKeys = Object.keys(axAttrs);\n\n    var noSwapAttrs = [\n        'anchor', 'domain', 'overlaying', 'position', 'side', 'tickangle', 'editType'\n    ];\n    var numericTypes = ['linear', 'log'];\n\n    for(i = 0; i < allAxKeys.length; i++) {\n        var keyi = allAxKeys[i];\n        var xVal = xFullAxes[0][keyi];\n        var yVal = yFullAxes[0][keyi];\n        var allEqual = true;\n        var coerceLinearX = false;\n        var coerceLinearY = false;\n        if(keyi.charAt(0) === '_' || typeof xVal === 'function' ||\n                noSwapAttrs.indexOf(keyi) !== -1) {\n            continue;\n        }\n        for(j = 1; j < xFullAxes.length && allEqual; j++) {\n            var xVali = xFullAxes[j][keyi];\n            if(keyi === 'type' && numericTypes.indexOf(xVal) !== -1 &&\n                    numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {\n                // type is special - if we find a mixture of linear and log,\n                // coerce them all to linear on flipping\n                coerceLinearX = true;\n            } else if(xVali !== xVal) allEqual = false;\n        }\n        for(j = 1; j < yFullAxes.length && allEqual; j++) {\n            var yVali = yFullAxes[j][keyi];\n            if(keyi === 'type' && numericTypes.indexOf(yVal) !== -1 &&\n                    numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {\n                // type is special - if we find a mixture of linear and log,\n                // coerce them all to linear on flipping\n                coerceLinearY = true;\n            } else if(yFullAxes[j][keyi] !== yVal) allEqual = false;\n        }\n        if(allEqual) {\n            if(coerceLinearX) layout[xFullAxes[0]._name].type = 'linear';\n            if(coerceLinearY) layout[yFullAxes[0]._name].type = 'linear';\n            swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes, gd._fullLayout._dfltTitle);\n        }\n    }\n\n    // now swap x&y for any annotations anchored to these x & y\n    for(i = 0; i < gd._fullLayout.annotations.length; i++) {\n        var ann = gd._fullLayout.annotations[i];\n        if(xIds.indexOf(ann.xref) !== -1 &&\n                yIds.indexOf(ann.yref) !== -1) {\n            Lib.swapAttrs(layout.annotations[i], ['?']);\n        }\n    }\n}\n\nfunction swapAxisAttrs(layout, key, xFullAxes, yFullAxes, dfltTitle) {\n    // in case the value is the default for either axis,\n    // look at the first axis in each list and see if\n    // this key's value is undefined\n    var np = Lib.nestedProperty;\n    var xVal = np(layout[xFullAxes[0]._name], key).get();\n    var yVal = np(layout[yFullAxes[0]._name], key).get();\n    var i;\n\n    if(key === 'title') {\n        // special handling of placeholder titles\n        if(xVal && xVal.text === dfltTitle.x) {\n            xVal.text = dfltTitle.y;\n        }\n        if(yVal && yVal.text === dfltTitle.y) {\n            yVal.text = dfltTitle.x;\n        }\n    }\n\n    for(i = 0; i < xFullAxes.length; i++) {\n        np(layout, xFullAxes[i]._name + '.' + key).set(yVal);\n    }\n    for(i = 0; i < yFullAxes.length; i++) {\n        np(layout, yFullAxes[i]._name + '.' + key).set(xVal);\n    }\n}\n\nfunction isAngular(ax) {\n    return ax._id === 'angularaxis';\n}\n\nfunction moveOutsideBreak(v, ax) {\n    var len = ax._rangebreaks.length;\n    for(var k = 0; k < len; k++) {\n        var brk = ax._rangebreaks[k];\n        if(v >= brk.min && v < brk.max) {\n            return brk.max;\n        }\n    }\n    return v;\n}\n\nfunction insideTicklabelposition(ax) {\n    return ((ax.ticklabelposition || '').indexOf('inside') !== -1);\n}\n\nfunction hideCounterAxisInsideTickLabels(ax, opts) {\n    if(insideTicklabelposition(ax._anchorAxis || {})) {\n        if(ax._hideCounterAxisInsideTickLabels) {\n            ax._hideCounterAxisInsideTickLabels(opts);\n        }\n    }\n}\n\nfunction incrementShift(ax, shiftVal, axShifts, normalize) {\n    // Need to set 'overlay' for anchored axis\n    var overlay = ((ax.anchor !== 'free') && ((ax.overlaying === undefined) || (ax.overlaying === false))) ? ax._id : ax.overlaying;\n    var shiftValAdj;\n    if(normalize) {\n        shiftValAdj = ax.side === 'right' ? shiftVal : -shiftVal;\n    } else {\n        shiftValAdj = shiftVal;\n    }\n    if(!(overlay in axShifts)) {\n        axShifts[overlay] = {};\n    }\n    if(!(ax.side in axShifts[overlay])) {\n        axShifts[overlay][ax.side] = 0;\n    }\n    axShifts[overlay][ax.side] += shiftValAdj;\n}\n\nfunction setShiftVal(ax, axShifts) {\n    return ax.autoshift ?\n        axShifts[ax.overlaying][ax.side] :\n        (ax.shift || 0);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}