{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar constants = require('./constants');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\n// special position conversion functions... category axis positions can't be\n// specified by their data values, because they don't make a continuous mapping.\n// so these have to be specified in terms of the category serial numbers,\n// but can take fractional values. Other axis types we specify position based on\n// the actual data values.\n// TODO: in V3.0 (when log axis ranges are in data units) range and shape position\n// will be identical, so rangeToShapePosition and shapePositionToRange can be\n// removed entirely.\n\nexports.rangeToShapePosition = function (ax) {\n  return ax.type === 'log' ? ax.r2d : function (v) {\n    return v;\n  };\n};\nexports.shapePositionToRange = function (ax) {\n  return ax.type === 'log' ? ax.d2r : function (v) {\n    return v;\n  };\n};\nexports.decodeDate = function (convertToPx) {\n  return function (v) {\n    if (v.replace) v = v.replace('_', ' ');\n    return convertToPx(v);\n  };\n};\nexports.encodeDate = function (convertToDate) {\n  return function (v) {\n    return convertToDate(v).replace(' ', '_');\n  };\n};\nexports.extractPathCoords = function (path, paramsToUse, isRaw) {\n  var extractedCoordinates = [];\n  var segments = path.match(constants.segmentRE);\n  segments.forEach(function (segment) {\n    var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;\n    if (relevantParamIdx === undefined) return;\n    var params = segment.substr(1).match(constants.paramRE);\n    if (!params || params.length < relevantParamIdx) return;\n    var str = params[relevantParamIdx];\n    var pos = isRaw ? str : Lib.cleanNumber(str);\n    extractedCoordinates.push(pos);\n  });\n  return extractedCoordinates;\n};\nexports.getDataToPixel = function (gd, axis, isVertical, refType) {\n  var gs = gd._fullLayout._size;\n  var dataToPixel;\n  if (axis) {\n    if (refType === 'domain') {\n      dataToPixel = function (v) {\n        return axis._length * (isVertical ? 1 - v : v) + axis._offset;\n      };\n    } else {\n      var d2r = exports.shapePositionToRange(axis);\n      dataToPixel = function (v) {\n        return axis._offset + axis.r2p(d2r(v, true));\n      };\n      if (axis.type === 'date') dataToPixel = exports.decodeDate(dataToPixel);\n    }\n  } else if (isVertical) {\n    dataToPixel = function (v) {\n      return gs.t + gs.h * (1 - v);\n    };\n  } else {\n    dataToPixel = function (v) {\n      return gs.l + gs.w * v;\n    };\n  }\n  return dataToPixel;\n};\nexports.getPixelToData = function (gd, axis, isVertical, opt) {\n  var gs = gd._fullLayout._size;\n  var pixelToData;\n  if (axis) {\n    if (opt === 'domain') {\n      pixelToData = function (p) {\n        var q = (p - axis._offset) / axis._length;\n        return isVertical ? 1 - q : q;\n      };\n    } else {\n      var r2d = exports.rangeToShapePosition(axis);\n      pixelToData = function (p) {\n        return r2d(axis.p2r(p - axis._offset));\n      };\n    }\n  } else if (isVertical) {\n    pixelToData = function (p) {\n      return 1 - (p - gs.t) / gs.h;\n    };\n  } else {\n    pixelToData = function (p) {\n      return (p - gs.l) / gs.w;\n    };\n  }\n  return pixelToData;\n};\n\n/**\n * Based on the given stroke width, rounds the passed\n * position value to represent either a full or half pixel.\n *\n * In case of an odd stroke width (e.g. 1), this measure ensures\n * that a stroke positioned at the returned position isn't rendered\n * blurry due to anti-aliasing.\n *\n * In case of an even stroke width (e.g. 2), this measure ensures\n * that the position value is transformed to a full pixel value\n * so that anti-aliasing doesn't take effect either.\n *\n * @param {number} pos The raw position value to be transformed\n * @param {number} strokeWidth The stroke width\n * @returns {number} either an integer or a .5 decimal number\n */\nexports.roundPositionForSharpStrokeRendering = function (pos, strokeWidth) {\n  var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;\n  var posValAsInt = Math.round(pos);\n  return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;\n};\nexports.makeShapesOptionsAndPlotinfo = function (gd, index) {\n  var options = gd._fullLayout.shapes[index] || {};\n  var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n  var hasPlotinfo = !!plotinfo;\n  if (hasPlotinfo) {\n    plotinfo._hadPlotinfo = true;\n  } else {\n    plotinfo = {};\n    if (options.xref && options.xref !== 'paper') plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n    if (options.yref && options.yref !== 'paper') plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n  }\n  plotinfo.xsizemode = options.xsizemode;\n  plotinfo.ysizemode = options.ysizemode;\n  plotinfo.xanchor = options.xanchor;\n  plotinfo.yanchor = options.yanchor;\n  return {\n    options: options,\n    plotinfo: plotinfo\n  };\n};\n\n// TODO: move to selections helpers?\nexports.makeSelectionsOptionsAndPlotinfo = function (gd, index) {\n  var options = gd._fullLayout.selections[index] || {};\n  var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n  var hasPlotinfo = !!plotinfo;\n  if (hasPlotinfo) {\n    plotinfo._hadPlotinfo = true;\n  } else {\n    plotinfo = {};\n    if (options.xref) plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n    if (options.yref) plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n  }\n  return {\n    options: options,\n    plotinfo: plotinfo\n  };\n};\nexports.getPathString = function (gd, options) {\n  var type = options.type;\n  var xRefType = Axes.getRefType(options.xref);\n  var yRefType = Axes.getRefType(options.yref);\n  var xa = Axes.getFromId(gd, options.xref);\n  var ya = Axes.getFromId(gd, options.yref);\n  var gs = gd._fullLayout._size;\n  var x2r, x2p, y2r, y2p;\n  var x0, x1, y0, y1;\n  if (xa) {\n    if (xRefType === 'domain') {\n      x2p = function (v) {\n        return xa._offset + xa._length * v;\n      };\n    } else {\n      x2r = exports.shapePositionToRange(xa);\n      x2p = function (v) {\n        return xa._offset + xa.r2p(x2r(v, true));\n      };\n    }\n  } else {\n    x2p = function (v) {\n      return gs.l + gs.w * v;\n    };\n  }\n  if (ya) {\n    if (yRefType === 'domain') {\n      y2p = function (v) {\n        return ya._offset + ya._length * (1 - v);\n      };\n    } else {\n      y2r = exports.shapePositionToRange(ya);\n      y2p = function (v) {\n        return ya._offset + ya.r2p(y2r(v, true));\n      };\n    }\n  } else {\n    y2p = function (v) {\n      return gs.t + gs.h * (1 - v);\n    };\n  }\n  if (type === 'path') {\n    if (xa && xa.type === 'date') x2p = exports.decodeDate(x2p);\n    if (ya && ya.type === 'date') y2p = exports.decodeDate(y2p);\n    return convertPath(options, x2p, y2p);\n  }\n  if (options.xsizemode === 'pixel') {\n    var xAnchorPos = x2p(options.xanchor);\n    x0 = xAnchorPos + options.x0;\n    x1 = xAnchorPos + options.x1;\n  } else {\n    x0 = x2p(options.x0);\n    x1 = x2p(options.x1);\n  }\n  if (options.ysizemode === 'pixel') {\n    var yAnchorPos = y2p(options.yanchor);\n    y0 = yAnchorPos - options.y0;\n    y1 = yAnchorPos - options.y1;\n  } else {\n    y0 = y2p(options.y0);\n    y1 = y2p(options.y1);\n  }\n  if (type === 'line') return 'M' + x0 + ',' + y0 + 'L' + x1 + ',' + y1;\n  if (type === 'rect') return 'M' + x0 + ',' + y0 + 'H' + x1 + 'V' + y1 + 'H' + x0 + 'Z';\n\n  // circle\n  var cx = (x0 + x1) / 2;\n  var cy = (y0 + y1) / 2;\n  var rx = Math.abs(cx - x0);\n  var ry = Math.abs(cy - y0);\n  var rArc = 'A' + rx + ',' + ry;\n  var rightPt = cx + rx + ',' + cy;\n  var topPt = cx + ',' + (cy - ry);\n  return 'M' + rightPt + rArc + ' 0 1,1 ' + topPt + rArc + ' 0 0,1 ' + rightPt + 'Z';\n};\nfunction convertPath(options, x2p, y2p) {\n  var pathIn = options.path;\n  var xSizemode = options.xsizemode;\n  var ySizemode = options.ysizemode;\n  var xAnchor = options.xanchor;\n  var yAnchor = options.yanchor;\n  return pathIn.replace(constants.segmentRE, function (segment) {\n    var paramNumber = 0;\n    var segmentType = segment.charAt(0);\n    var xParams = constants.paramIsX[segmentType];\n    var yParams = constants.paramIsY[segmentType];\n    var nParams = constants.numParams[segmentType];\n    var paramString = segment.substr(1).replace(constants.paramRE, function (param) {\n      if (xParams[paramNumber]) {\n        if (xSizemode === 'pixel') param = x2p(xAnchor) + Number(param);else param = x2p(param);\n      } else if (yParams[paramNumber]) {\n        if (ySizemode === 'pixel') param = y2p(yAnchor) - Number(param);else param = y2p(param);\n      }\n      paramNumber++;\n      if (paramNumber > nParams) param = 'X';\n      return param;\n    });\n    if (paramNumber > nParams) {\n      paramString = paramString.replace(/[\\s,]*X.*/, '');\n      Lib.log('Ignoring extra params in segment ' + segment);\n    }\n    return segmentType + paramString;\n  });\n}","map":{"version":3,"names":["require","constants","Lib","Axes","exports","rangeToShapePosition","ax","type","r2d","v","shapePositionToRange","d2r","decodeDate","convertToPx","replace","encodeDate","convertToDate","extractPathCoords","path","paramsToUse","isRaw","extractedCoordinates","segments","match","segmentRE","forEach","segment","relevantParamIdx","charAt","drawn","undefined","params","substr","paramRE","length","str","pos","cleanNumber","push","getDataToPixel","gd","axis","isVertical","refType","gs","_fullLayout","_size","dataToPixel","_length","_offset","r2p","t","h","l","w","getPixelToData","opt","pixelToData","p","q","p2r","roundPositionForSharpStrokeRendering","strokeWidth","strokeWidthIsOdd","Math","round","posValAsInt","makeShapesOptionsAndPlotinfo","index","options","shapes","plotinfo","_plots","xref","yref","hasPlotinfo","_hadPlotinfo","xaxis","yaxis","xsizemode","ysizemode","xanchor","yanchor","makeSelectionsOptionsAndPlotinfo","selections","getPathString","xRefType","getRefType","yRefType","xa","getFromId","ya","x2r","x2p","y2r","y2p","x0","x1","y0","y1","convertPath","xAnchorPos","yAnchorPos","cx","cy","rx","abs","ry","rArc","rightPt","topPt","pathIn","xSizemode","ySizemode","xAnchor","yAnchor","paramNumber","segmentType","xParams","paramIsX","yParams","paramIsY","nParams","numParams","paramString","param","Number","log"],"sources":["/home/zhu/Documents/github/explorer_front/explorer_front_app/node_modules/plotly.js/src/components/shapes/helpers.js"],"sourcesContent":["'use strict';\n\nvar constants = require('./constants');\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\n// special position conversion functions... category axis positions can't be\n// specified by their data values, because they don't make a continuous mapping.\n// so these have to be specified in terms of the category serial numbers,\n// but can take fractional values. Other axis types we specify position based on\n// the actual data values.\n// TODO: in V3.0 (when log axis ranges are in data units) range and shape position\n// will be identical, so rangeToShapePosition and shapePositionToRange can be\n// removed entirely.\n\nexports.rangeToShapePosition = function(ax) {\n    return (ax.type === 'log') ? ax.r2d : function(v) { return v; };\n};\n\nexports.shapePositionToRange = function(ax) {\n    return (ax.type === 'log') ? ax.d2r : function(v) { return v; };\n};\n\nexports.decodeDate = function(convertToPx) {\n    return function(v) {\n        if(v.replace) v = v.replace('_', ' ');\n        return convertToPx(v);\n    };\n};\n\nexports.encodeDate = function(convertToDate) {\n    return function(v) { return convertToDate(v).replace(' ', '_'); };\n};\n\nexports.extractPathCoords = function(path, paramsToUse, isRaw) {\n    var extractedCoordinates = [];\n\n    var segments = path.match(constants.segmentRE);\n    segments.forEach(function(segment) {\n        var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;\n        if(relevantParamIdx === undefined) return;\n\n        var params = segment.substr(1).match(constants.paramRE);\n        if(!params || params.length < relevantParamIdx) return;\n\n        var str = params[relevantParamIdx];\n        var pos = isRaw ? str : Lib.cleanNumber(str);\n\n        extractedCoordinates.push(pos);\n    });\n\n    return extractedCoordinates;\n};\n\nexports.getDataToPixel = function(gd, axis, isVertical, refType) {\n    var gs = gd._fullLayout._size;\n    var dataToPixel;\n\n    if(axis) {\n        if(refType === 'domain') {\n            dataToPixel = function(v) {\n                return axis._length * (isVertical ? (1 - v) : v) + axis._offset;\n            };\n        } else {\n            var d2r = exports.shapePositionToRange(axis);\n\n            dataToPixel = function(v) {\n                return axis._offset + axis.r2p(d2r(v, true));\n            };\n\n            if(axis.type === 'date') dataToPixel = exports.decodeDate(dataToPixel);\n        }\n    } else if(isVertical) {\n        dataToPixel = function(v) { return gs.t + gs.h * (1 - v); };\n    } else {\n        dataToPixel = function(v) { return gs.l + gs.w * v; };\n    }\n\n    return dataToPixel;\n};\n\nexports.getPixelToData = function(gd, axis, isVertical, opt) {\n    var gs = gd._fullLayout._size;\n    var pixelToData;\n\n    if(axis) {\n        if(opt === 'domain') {\n            pixelToData = function(p) {\n                var q = (p - axis._offset) / axis._length;\n                return isVertical ? 1 - q : q;\n            };\n        } else {\n            var r2d = exports.rangeToShapePosition(axis);\n            pixelToData = function(p) { return r2d(axis.p2r(p - axis._offset)); };\n        }\n    } else if(isVertical) {\n        pixelToData = function(p) { return 1 - (p - gs.t) / gs.h; };\n    } else {\n        pixelToData = function(p) { return (p - gs.l) / gs.w; };\n    }\n\n    return pixelToData;\n};\n\n/**\n * Based on the given stroke width, rounds the passed\n * position value to represent either a full or half pixel.\n *\n * In case of an odd stroke width (e.g. 1), this measure ensures\n * that a stroke positioned at the returned position isn't rendered\n * blurry due to anti-aliasing.\n *\n * In case of an even stroke width (e.g. 2), this measure ensures\n * that the position value is transformed to a full pixel value\n * so that anti-aliasing doesn't take effect either.\n *\n * @param {number} pos The raw position value to be transformed\n * @param {number} strokeWidth The stroke width\n * @returns {number} either an integer or a .5 decimal number\n */\nexports.roundPositionForSharpStrokeRendering = function(pos, strokeWidth) {\n    var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;\n    var posValAsInt = Math.round(pos);\n\n    return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;\n};\n\nexports.makeShapesOptionsAndPlotinfo = function(gd, index) {\n    var options = gd._fullLayout.shapes[index] || {};\n\n    var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n    var hasPlotinfo = !!plotinfo;\n    if(hasPlotinfo) {\n        plotinfo._hadPlotinfo = true;\n    } else {\n        plotinfo = {};\n        if(options.xref && options.xref !== 'paper') plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n        if(options.yref && options.yref !== 'paper') plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n    }\n\n    plotinfo.xsizemode = options.xsizemode;\n    plotinfo.ysizemode = options.ysizemode;\n    plotinfo.xanchor = options.xanchor;\n    plotinfo.yanchor = options.yanchor;\n\n    return {\n        options: options,\n        plotinfo: plotinfo\n    };\n};\n\n// TODO: move to selections helpers?\nexports.makeSelectionsOptionsAndPlotinfo = function(gd, index) {\n    var options = gd._fullLayout.selections[index] || {};\n\n    var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n    var hasPlotinfo = !!plotinfo;\n    if(hasPlotinfo) {\n        plotinfo._hadPlotinfo = true;\n    } else {\n        plotinfo = {};\n        if(options.xref) plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n        if(options.yref) plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n    }\n\n    return {\n        options: options,\n        plotinfo: plotinfo\n    };\n};\n\n\nexports.getPathString = function(gd, options) {\n    var type = options.type;\n    var xRefType = Axes.getRefType(options.xref);\n    var yRefType = Axes.getRefType(options.yref);\n    var xa = Axes.getFromId(gd, options.xref);\n    var ya = Axes.getFromId(gd, options.yref);\n    var gs = gd._fullLayout._size;\n    var x2r, x2p, y2r, y2p;\n    var x0, x1, y0, y1;\n\n    if(xa) {\n        if(xRefType === 'domain') {\n            x2p = function(v) { return xa._offset + xa._length * v; };\n        } else {\n            x2r = exports.shapePositionToRange(xa);\n            x2p = function(v) { return xa._offset + xa.r2p(x2r(v, true)); };\n        }\n    } else {\n        x2p = function(v) { return gs.l + gs.w * v; };\n    }\n\n    if(ya) {\n        if(yRefType === 'domain') {\n            y2p = function(v) { return ya._offset + ya._length * (1 - v); };\n        } else {\n            y2r = exports.shapePositionToRange(ya);\n            y2p = function(v) { return ya._offset + ya.r2p(y2r(v, true)); };\n        }\n    } else {\n        y2p = function(v) { return gs.t + gs.h * (1 - v); };\n    }\n\n    if(type === 'path') {\n        if(xa && xa.type === 'date') x2p = exports.decodeDate(x2p);\n        if(ya && ya.type === 'date') y2p = exports.decodeDate(y2p);\n        return convertPath(options, x2p, y2p);\n    }\n\n    if(options.xsizemode === 'pixel') {\n        var xAnchorPos = x2p(options.xanchor);\n        x0 = xAnchorPos + options.x0;\n        x1 = xAnchorPos + options.x1;\n    } else {\n        x0 = x2p(options.x0);\n        x1 = x2p(options.x1);\n    }\n\n    if(options.ysizemode === 'pixel') {\n        var yAnchorPos = y2p(options.yanchor);\n        y0 = yAnchorPos - options.y0;\n        y1 = yAnchorPos - options.y1;\n    } else {\n        y0 = y2p(options.y0);\n        y1 = y2p(options.y1);\n    }\n\n    if(type === 'line') return 'M' + x0 + ',' + y0 + 'L' + x1 + ',' + y1;\n    if(type === 'rect') return 'M' + x0 + ',' + y0 + 'H' + x1 + 'V' + y1 + 'H' + x0 + 'Z';\n\n    // circle\n    var cx = (x0 + x1) / 2;\n    var cy = (y0 + y1) / 2;\n    var rx = Math.abs(cx - x0);\n    var ry = Math.abs(cy - y0);\n    var rArc = 'A' + rx + ',' + ry;\n    var rightPt = (cx + rx) + ',' + cy;\n    var topPt = cx + ',' + (cy - ry);\n    return 'M' + rightPt + rArc + ' 0 1,1 ' + topPt +\n        rArc + ' 0 0,1 ' + rightPt + 'Z';\n};\n\n\nfunction convertPath(options, x2p, y2p) {\n    var pathIn = options.path;\n    var xSizemode = options.xsizemode;\n    var ySizemode = options.ysizemode;\n    var xAnchor = options.xanchor;\n    var yAnchor = options.yanchor;\n\n    return pathIn.replace(constants.segmentRE, function(segment) {\n        var paramNumber = 0;\n        var segmentType = segment.charAt(0);\n        var xParams = constants.paramIsX[segmentType];\n        var yParams = constants.paramIsY[segmentType];\n        var nParams = constants.numParams[segmentType];\n\n        var paramString = segment.substr(1).replace(constants.paramRE, function(param) {\n            if(xParams[paramNumber]) {\n                if(xSizemode === 'pixel') param = x2p(xAnchor) + Number(param);\n                else param = x2p(param);\n            } else if(yParams[paramNumber]) {\n                if(ySizemode === 'pixel') param = y2p(yAnchor) - Number(param);\n                else param = y2p(param);\n            }\n            paramNumber++;\n\n            if(paramNumber > nParams) param = 'X';\n            return param;\n        });\n\n        if(paramNumber > nParams) {\n            paramString = paramString.replace(/[\\s,]*X.*/, '');\n            Lib.log('Ignoring extra params in segment ' + segment);\n        }\n\n        return segmentType + paramString;\n    });\n}\n"],"mappings":"AAAA,YAAY;;AAACA,OAAA;AAEb,IAAIC,SAAS,GAAGD,OAAO,CAAC,aAAa,CAAC;AAEtC,IAAIE,GAAG,GAAGF,OAAO,CAAC,WAAW,CAAC;AAC9B,IAAIG,IAAI,GAAGH,OAAO,CAAC,4BAA4B,CAAC;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAI,OAAO,CAACC,oBAAoB,GAAG,UAASC,EAAE,EAAE;EACxC,OAAQA,EAAE,CAACC,IAAI,KAAK,KAAK,GAAID,EAAE,CAACE,GAAG,GAAG,UAASC,CAAC,EAAE;IAAE,OAAOA,CAAC;EAAE,CAAC;AACnE,CAAC;AAEDL,OAAO,CAACM,oBAAoB,GAAG,UAASJ,EAAE,EAAE;EACxC,OAAQA,EAAE,CAACC,IAAI,KAAK,KAAK,GAAID,EAAE,CAACK,GAAG,GAAG,UAASF,CAAC,EAAE;IAAE,OAAOA,CAAC;EAAE,CAAC;AACnE,CAAC;AAEDL,OAAO,CAACQ,UAAU,GAAG,UAASC,WAAW,EAAE;EACvC,OAAO,UAASJ,CAAC,EAAE;IACf,IAAGA,CAAC,CAACK,OAAO,EAAEL,CAAC,GAAGA,CAAC,CAACK,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC;IACrC,OAAOD,WAAW,CAACJ,CAAC,CAAC;EACzB,CAAC;AACL,CAAC;AAEDL,OAAO,CAACW,UAAU,GAAG,UAASC,aAAa,EAAE;EACzC,OAAO,UAASP,CAAC,EAAE;IAAE,OAAOO,aAAa,CAACP,CAAC,CAAC,CAACK,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC;EAAE,CAAC;AACrE,CAAC;AAEDV,OAAO,CAACa,iBAAiB,GAAG,UAASC,IAAI,EAAEC,WAAW,EAAEC,KAAK,EAAE;EAC3D,IAAIC,oBAAoB,GAAG,EAAE;EAE7B,IAAIC,QAAQ,GAAGJ,IAAI,CAACK,KAAK,CAACtB,SAAS,CAACuB,SAAS,CAAC;EAC9CF,QAAQ,CAACG,OAAO,CAAC,UAASC,OAAO,EAAE;IAC/B,IAAIC,gBAAgB,GAAGR,WAAW,CAACO,OAAO,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC,CAACC,KAAK;IAC3D,IAAGF,gBAAgB,KAAKG,SAAS,EAAE;IAEnC,IAAIC,MAAM,GAAGL,OAAO,CAACM,MAAM,CAAC,CAAC,CAAC,CAACT,KAAK,CAACtB,SAAS,CAACgC,OAAO,CAAC;IACvD,IAAG,CAACF,MAAM,IAAIA,MAAM,CAACG,MAAM,GAAGP,gBAAgB,EAAE;IAEhD,IAAIQ,GAAG,GAAGJ,MAAM,CAACJ,gBAAgB,CAAC;IAClC,IAAIS,GAAG,GAAGhB,KAAK,GAAGe,GAAG,GAAGjC,GAAG,CAACmC,WAAW,CAACF,GAAG,CAAC;IAE5Cd,oBAAoB,CAACiB,IAAI,CAACF,GAAG,CAAC;EAClC,CAAC,CAAC;EAEF,OAAOf,oBAAoB;AAC/B,CAAC;AAEDjB,OAAO,CAACmC,cAAc,GAAG,UAASC,EAAE,EAAEC,IAAI,EAAEC,UAAU,EAAEC,OAAO,EAAE;EAC7D,IAAIC,EAAE,GAAGJ,EAAE,CAACK,WAAW,CAACC,KAAK;EAC7B,IAAIC,WAAW;EAEf,IAAGN,IAAI,EAAE;IACL,IAAGE,OAAO,KAAK,QAAQ,EAAE;MACrBI,WAAW,GAAG,SAAAA,CAAStC,CAAC,EAAE;QACtB,OAAOgC,IAAI,CAACO,OAAO,IAAIN,UAAU,GAAI,CAAC,GAAGjC,CAAC,GAAIA,CAAC,CAAC,GAAGgC,IAAI,CAACQ,OAAO;MACnE,CAAC;IACL,CAAC,MAAM;MACH,IAAItC,GAAG,GAAGP,OAAO,CAACM,oBAAoB,CAAC+B,IAAI,CAAC;MAE5CM,WAAW,GAAG,SAAAA,CAAStC,CAAC,EAAE;QACtB,OAAOgC,IAAI,CAACQ,OAAO,GAAGR,IAAI,CAACS,GAAG,CAACvC,GAAG,CAACF,CAAC,EAAE,IAAI,CAAC,CAAC;MAChD,CAAC;MAED,IAAGgC,IAAI,CAAClC,IAAI,KAAK,MAAM,EAAEwC,WAAW,GAAG3C,OAAO,CAACQ,UAAU,CAACmC,WAAW,CAAC;IAC1E;EACJ,CAAC,MAAM,IAAGL,UAAU,EAAE;IAClBK,WAAW,GAAG,SAAAA,CAAStC,CAAC,EAAE;MAAE,OAAOmC,EAAE,CAACO,CAAC,GAAGP,EAAE,CAACQ,CAAC,IAAI,CAAC,GAAG3C,CAAC,CAAC;IAAE,CAAC;EAC/D,CAAC,MAAM;IACHsC,WAAW,GAAG,SAAAA,CAAStC,CAAC,EAAE;MAAE,OAAOmC,EAAE,CAACS,CAAC,GAAGT,EAAE,CAACU,CAAC,GAAG7C,CAAC;IAAE,CAAC;EACzD;EAEA,OAAOsC,WAAW;AACtB,CAAC;AAED3C,OAAO,CAACmD,cAAc,GAAG,UAASf,EAAE,EAAEC,IAAI,EAAEC,UAAU,EAAEc,GAAG,EAAE;EACzD,IAAIZ,EAAE,GAAGJ,EAAE,CAACK,WAAW,CAACC,KAAK;EAC7B,IAAIW,WAAW;EAEf,IAAGhB,IAAI,EAAE;IACL,IAAGe,GAAG,KAAK,QAAQ,EAAE;MACjBC,WAAW,GAAG,SAAAA,CAASC,CAAC,EAAE;QACtB,IAAIC,CAAC,GAAG,CAACD,CAAC,GAAGjB,IAAI,CAACQ,OAAO,IAAIR,IAAI,CAACO,OAAO;QACzC,OAAON,UAAU,GAAG,CAAC,GAAGiB,CAAC,GAAGA,CAAC;MACjC,CAAC;IACL,CAAC,MAAM;MACH,IAAInD,GAAG,GAAGJ,OAAO,CAACC,oBAAoB,CAACoC,IAAI,CAAC;MAC5CgB,WAAW,GAAG,SAAAA,CAASC,CAAC,EAAE;QAAE,OAAOlD,GAAG,CAACiC,IAAI,CAACmB,GAAG,CAACF,CAAC,GAAGjB,IAAI,CAACQ,OAAO,CAAC,CAAC;MAAE,CAAC;IACzE;EACJ,CAAC,MAAM,IAAGP,UAAU,EAAE;IAClBe,WAAW,GAAG,SAAAA,CAASC,CAAC,EAAE;MAAE,OAAO,CAAC,GAAG,CAACA,CAAC,GAAGd,EAAE,CAACO,CAAC,IAAIP,EAAE,CAACQ,CAAC;IAAE,CAAC;EAC/D,CAAC,MAAM;IACHK,WAAW,GAAG,SAAAA,CAASC,CAAC,EAAE;MAAE,OAAO,CAACA,CAAC,GAAGd,EAAE,CAACS,CAAC,IAAIT,EAAE,CAACU,CAAC;IAAE,CAAC;EAC3D;EAEA,OAAOG,WAAW;AACtB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACArD,OAAO,CAACyD,oCAAoC,GAAG,UAASzB,GAAG,EAAE0B,WAAW,EAAE;EACtE,IAAIC,gBAAgB,GAAGC,IAAI,CAACC,KAAK,CAACH,WAAW,GAAG,CAAC,CAAC,KAAK,CAAC;EACxD,IAAII,WAAW,GAAGF,IAAI,CAACC,KAAK,CAAC7B,GAAG,CAAC;EAEjC,OAAO2B,gBAAgB,GAAGG,WAAW,GAAG,GAAG,GAAGA,WAAW;AAC7D,CAAC;AAED9D,OAAO,CAAC+D,4BAA4B,GAAG,UAAS3B,EAAE,EAAE4B,KAAK,EAAE;EACvD,IAAIC,OAAO,GAAG7B,EAAE,CAACK,WAAW,CAACyB,MAAM,CAACF,KAAK,CAAC,IAAI,CAAC,CAAC;EAEhD,IAAIG,QAAQ,GAAG/B,EAAE,CAACK,WAAW,CAAC2B,MAAM,CAACH,OAAO,CAACI,IAAI,GAAGJ,OAAO,CAACK,IAAI,CAAC;EACjE,IAAIC,WAAW,GAAG,CAAC,CAACJ,QAAQ;EAC5B,IAAGI,WAAW,EAAE;IACZJ,QAAQ,CAACK,YAAY,GAAG,IAAI;EAChC,CAAC,MAAM;IACHL,QAAQ,GAAG,CAAC,CAAC;IACb,IAAGF,OAAO,CAACI,IAAI,IAAIJ,OAAO,CAACI,IAAI,KAAK,OAAO,EAAEF,QAAQ,CAACM,KAAK,GAAGrC,EAAE,CAACK,WAAW,CAACwB,OAAO,CAACI,IAAI,GAAG,MAAM,CAAC;IACnG,IAAGJ,OAAO,CAACK,IAAI,IAAIL,OAAO,CAACK,IAAI,KAAK,OAAO,EAAEH,QAAQ,CAACO,KAAK,GAAGtC,EAAE,CAACK,WAAW,CAACwB,OAAO,CAACK,IAAI,GAAG,MAAM,CAAC;EACvG;EAEAH,QAAQ,CAACQ,SAAS,GAAGV,OAAO,CAACU,SAAS;EACtCR,QAAQ,CAACS,SAAS,GAAGX,OAAO,CAACW,SAAS;EACtCT,QAAQ,CAACU,OAAO,GAAGZ,OAAO,CAACY,OAAO;EAClCV,QAAQ,CAACW,OAAO,GAAGb,OAAO,CAACa,OAAO;EAElC,OAAO;IACHb,OAAO,EAAEA,OAAO;IAChBE,QAAQ,EAAEA;EACd,CAAC;AACL,CAAC;;AAED;AACAnE,OAAO,CAAC+E,gCAAgC,GAAG,UAAS3C,EAAE,EAAE4B,KAAK,EAAE;EAC3D,IAAIC,OAAO,GAAG7B,EAAE,CAACK,WAAW,CAACuC,UAAU,CAAChB,KAAK,CAAC,IAAI,CAAC,CAAC;EAEpD,IAAIG,QAAQ,GAAG/B,EAAE,CAACK,WAAW,CAAC2B,MAAM,CAACH,OAAO,CAACI,IAAI,GAAGJ,OAAO,CAACK,IAAI,CAAC;EACjE,IAAIC,WAAW,GAAG,CAAC,CAACJ,QAAQ;EAC5B,IAAGI,WAAW,EAAE;IACZJ,QAAQ,CAACK,YAAY,GAAG,IAAI;EAChC,CAAC,MAAM;IACHL,QAAQ,GAAG,CAAC,CAAC;IACb,IAAGF,OAAO,CAACI,IAAI,EAAEF,QAAQ,CAACM,KAAK,GAAGrC,EAAE,CAACK,WAAW,CAACwB,OAAO,CAACI,IAAI,GAAG,MAAM,CAAC;IACvE,IAAGJ,OAAO,CAACK,IAAI,EAAEH,QAAQ,CAACO,KAAK,GAAGtC,EAAE,CAACK,WAAW,CAACwB,OAAO,CAACK,IAAI,GAAG,MAAM,CAAC;EAC3E;EAEA,OAAO;IACHL,OAAO,EAAEA,OAAO;IAChBE,QAAQ,EAAEA;EACd,CAAC;AACL,CAAC;AAGDnE,OAAO,CAACiF,aAAa,GAAG,UAAS7C,EAAE,EAAE6B,OAAO,EAAE;EAC1C,IAAI9D,IAAI,GAAG8D,OAAO,CAAC9D,IAAI;EACvB,IAAI+E,QAAQ,GAAGnF,IAAI,CAACoF,UAAU,CAAClB,OAAO,CAACI,IAAI,CAAC;EAC5C,IAAIe,QAAQ,GAAGrF,IAAI,CAACoF,UAAU,CAAClB,OAAO,CAACK,IAAI,CAAC;EAC5C,IAAIe,EAAE,GAAGtF,IAAI,CAACuF,SAAS,CAAClD,EAAE,EAAE6B,OAAO,CAACI,IAAI,CAAC;EACzC,IAAIkB,EAAE,GAAGxF,IAAI,CAACuF,SAAS,CAAClD,EAAE,EAAE6B,OAAO,CAACK,IAAI,CAAC;EACzC,IAAI9B,EAAE,GAAGJ,EAAE,CAACK,WAAW,CAACC,KAAK;EAC7B,IAAI8C,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG;EACtB,IAAIC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE;EAElB,IAAGV,EAAE,EAAE;IACH,IAAGH,QAAQ,KAAK,QAAQ,EAAE;MACtBO,GAAG,GAAG,SAAAA,CAASpF,CAAC,EAAE;QAAE,OAAOgF,EAAE,CAACxC,OAAO,GAAGwC,EAAE,CAACzC,OAAO,GAAGvC,CAAC;MAAE,CAAC;IAC7D,CAAC,MAAM;MACHmF,GAAG,GAAGxF,OAAO,CAACM,oBAAoB,CAAC+E,EAAE,CAAC;MACtCI,GAAG,GAAG,SAAAA,CAASpF,CAAC,EAAE;QAAE,OAAOgF,EAAE,CAACxC,OAAO,GAAGwC,EAAE,CAACvC,GAAG,CAAC0C,GAAG,CAACnF,CAAC,EAAE,IAAI,CAAC,CAAC;MAAE,CAAC;IACnE;EACJ,CAAC,MAAM;IACHoF,GAAG,GAAG,SAAAA,CAASpF,CAAC,EAAE;MAAE,OAAOmC,EAAE,CAACS,CAAC,GAAGT,EAAE,CAACU,CAAC,GAAG7C,CAAC;IAAE,CAAC;EACjD;EAEA,IAAGkF,EAAE,EAAE;IACH,IAAGH,QAAQ,KAAK,QAAQ,EAAE;MACtBO,GAAG,GAAG,SAAAA,CAAStF,CAAC,EAAE;QAAE,OAAOkF,EAAE,CAAC1C,OAAO,GAAG0C,EAAE,CAAC3C,OAAO,IAAI,CAAC,GAAGvC,CAAC,CAAC;MAAE,CAAC;IACnE,CAAC,MAAM;MACHqF,GAAG,GAAG1F,OAAO,CAACM,oBAAoB,CAACiF,EAAE,CAAC;MACtCI,GAAG,GAAG,SAAAA,CAAStF,CAAC,EAAE;QAAE,OAAOkF,EAAE,CAAC1C,OAAO,GAAG0C,EAAE,CAACzC,GAAG,CAAC4C,GAAG,CAACrF,CAAC,EAAE,IAAI,CAAC,CAAC;MAAE,CAAC;IACnE;EACJ,CAAC,MAAM;IACHsF,GAAG,GAAG,SAAAA,CAAStF,CAAC,EAAE;MAAE,OAAOmC,EAAE,CAACO,CAAC,GAAGP,EAAE,CAACQ,CAAC,IAAI,CAAC,GAAG3C,CAAC,CAAC;IAAE,CAAC;EACvD;EAEA,IAAGF,IAAI,KAAK,MAAM,EAAE;IAChB,IAAGkF,EAAE,IAAIA,EAAE,CAAClF,IAAI,KAAK,MAAM,EAAEsF,GAAG,GAAGzF,OAAO,CAACQ,UAAU,CAACiF,GAAG,CAAC;IAC1D,IAAGF,EAAE,IAAIA,EAAE,CAACpF,IAAI,KAAK,MAAM,EAAEwF,GAAG,GAAG3F,OAAO,CAACQ,UAAU,CAACmF,GAAG,CAAC;IAC1D,OAAOK,WAAW,CAAC/B,OAAO,EAAEwB,GAAG,EAAEE,GAAG,CAAC;EACzC;EAEA,IAAG1B,OAAO,CAACU,SAAS,KAAK,OAAO,EAAE;IAC9B,IAAIsB,UAAU,GAAGR,GAAG,CAACxB,OAAO,CAACY,OAAO,CAAC;IACrCe,EAAE,GAAGK,UAAU,GAAGhC,OAAO,CAAC2B,EAAE;IAC5BC,EAAE,GAAGI,UAAU,GAAGhC,OAAO,CAAC4B,EAAE;EAChC,CAAC,MAAM;IACHD,EAAE,GAAGH,GAAG,CAACxB,OAAO,CAAC2B,EAAE,CAAC;IACpBC,EAAE,GAAGJ,GAAG,CAACxB,OAAO,CAAC4B,EAAE,CAAC;EACxB;EAEA,IAAG5B,OAAO,CAACW,SAAS,KAAK,OAAO,EAAE;IAC9B,IAAIsB,UAAU,GAAGP,GAAG,CAAC1B,OAAO,CAACa,OAAO,CAAC;IACrCgB,EAAE,GAAGI,UAAU,GAAGjC,OAAO,CAAC6B,EAAE;IAC5BC,EAAE,GAAGG,UAAU,GAAGjC,OAAO,CAAC8B,EAAE;EAChC,CAAC,MAAM;IACHD,EAAE,GAAGH,GAAG,CAAC1B,OAAO,CAAC6B,EAAE,CAAC;IACpBC,EAAE,GAAGJ,GAAG,CAAC1B,OAAO,CAAC8B,EAAE,CAAC;EACxB;EAEA,IAAG5F,IAAI,KAAK,MAAM,EAAE,OAAO,GAAG,GAAGyF,EAAE,GAAG,GAAG,GAAGE,EAAE,GAAG,GAAG,GAAGD,EAAE,GAAG,GAAG,GAAGE,EAAE;EACpE,IAAG5F,IAAI,KAAK,MAAM,EAAE,OAAO,GAAG,GAAGyF,EAAE,GAAG,GAAG,GAAGE,EAAE,GAAG,GAAG,GAAGD,EAAE,GAAG,GAAG,GAAGE,EAAE,GAAG,GAAG,GAAGH,EAAE,GAAG,GAAG;;EAErF;EACA,IAAIO,EAAE,GAAG,CAACP,EAAE,GAAGC,EAAE,IAAI,CAAC;EACtB,IAAIO,EAAE,GAAG,CAACN,EAAE,GAAGC,EAAE,IAAI,CAAC;EACtB,IAAIM,EAAE,GAAGzC,IAAI,CAAC0C,GAAG,CAACH,EAAE,GAAGP,EAAE,CAAC;EAC1B,IAAIW,EAAE,GAAG3C,IAAI,CAAC0C,GAAG,CAACF,EAAE,GAAGN,EAAE,CAAC;EAC1B,IAAIU,IAAI,GAAG,GAAG,GAAGH,EAAE,GAAG,GAAG,GAAGE,EAAE;EAC9B,IAAIE,OAAO,GAAIN,EAAE,GAAGE,EAAE,GAAI,GAAG,GAAGD,EAAE;EAClC,IAAIM,KAAK,GAAGP,EAAE,GAAG,GAAG,IAAIC,EAAE,GAAGG,EAAE,CAAC;EAChC,OAAO,GAAG,GAAGE,OAAO,GAAGD,IAAI,GAAG,SAAS,GAAGE,KAAK,GAC3CF,IAAI,GAAG,SAAS,GAAGC,OAAO,GAAG,GAAG;AACxC,CAAC;AAGD,SAAST,WAAWA,CAAC/B,OAAO,EAAEwB,GAAG,EAAEE,GAAG,EAAE;EACpC,IAAIgB,MAAM,GAAG1C,OAAO,CAACnD,IAAI;EACzB,IAAI8F,SAAS,GAAG3C,OAAO,CAACU,SAAS;EACjC,IAAIkC,SAAS,GAAG5C,OAAO,CAACW,SAAS;EACjC,IAAIkC,OAAO,GAAG7C,OAAO,CAACY,OAAO;EAC7B,IAAIkC,OAAO,GAAG9C,OAAO,CAACa,OAAO;EAE7B,OAAO6B,MAAM,CAACjG,OAAO,CAACb,SAAS,CAACuB,SAAS,EAAE,UAASE,OAAO,EAAE;IACzD,IAAI0F,WAAW,GAAG,CAAC;IACnB,IAAIC,WAAW,GAAG3F,OAAO,CAACE,MAAM,CAAC,CAAC,CAAC;IACnC,IAAI0F,OAAO,GAAGrH,SAAS,CAACsH,QAAQ,CAACF,WAAW,CAAC;IAC7C,IAAIG,OAAO,GAAGvH,SAAS,CAACwH,QAAQ,CAACJ,WAAW,CAAC;IAC7C,IAAIK,OAAO,GAAGzH,SAAS,CAAC0H,SAAS,CAACN,WAAW,CAAC;IAE9C,IAAIO,WAAW,GAAGlG,OAAO,CAACM,MAAM,CAAC,CAAC,CAAC,CAAClB,OAAO,CAACb,SAAS,CAACgC,OAAO,EAAE,UAAS4F,KAAK,EAAE;MAC3E,IAAGP,OAAO,CAACF,WAAW,CAAC,EAAE;QACrB,IAAGJ,SAAS,KAAK,OAAO,EAAEa,KAAK,GAAGhC,GAAG,CAACqB,OAAO,CAAC,GAAGY,MAAM,CAACD,KAAK,CAAC,CAAC,KAC1DA,KAAK,GAAGhC,GAAG,CAACgC,KAAK,CAAC;MAC3B,CAAC,MAAM,IAAGL,OAAO,CAACJ,WAAW,CAAC,EAAE;QAC5B,IAAGH,SAAS,KAAK,OAAO,EAAEY,KAAK,GAAG9B,GAAG,CAACoB,OAAO,CAAC,GAAGW,MAAM,CAACD,KAAK,CAAC,CAAC,KAC1DA,KAAK,GAAG9B,GAAG,CAAC8B,KAAK,CAAC;MAC3B;MACAT,WAAW,EAAE;MAEb,IAAGA,WAAW,GAAGM,OAAO,EAAEG,KAAK,GAAG,GAAG;MACrC,OAAOA,KAAK;IAChB,CAAC,CAAC;IAEF,IAAGT,WAAW,GAAGM,OAAO,EAAE;MACtBE,WAAW,GAAGA,WAAW,CAAC9G,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC;MAClDZ,GAAG,CAAC6H,GAAG,CAAC,mCAAmC,GAAGrG,OAAO,CAAC;IAC1D;IAEA,OAAO2F,WAAW,GAAGO,WAAW;EACpC,CAAC,CAAC;AACN","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}