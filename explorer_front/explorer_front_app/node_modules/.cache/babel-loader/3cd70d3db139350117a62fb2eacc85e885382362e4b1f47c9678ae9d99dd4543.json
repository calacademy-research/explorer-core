{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Drawing = require('../drawing');\nvar readPaths = require('./draw_newshape/helpers').readPaths;\nvar helpers = require('./helpers');\nvar getPathString = helpers.getPathString;\nvar shapeLabelTexttemplateVars = require('./label_texttemplate');\nvar FROM_TL = require('../../constants/alignment').FROM_TL;\nmodule.exports = function drawLabel(gd, index, options, shapeGroup) {\n  // Remove existing label\n  shapeGroup.selectAll('.shape-label').remove();\n\n  // If no label text or texttemplate, return\n  if (!(options.label.text || options.label.texttemplate)) return;\n\n  // Text template overrides text\n  var text;\n  if (options.label.texttemplate) {\n    var templateValues = {};\n    if (options.type !== 'path') {\n      var _xa = Axes.getFromId(gd, options.xref);\n      var _ya = Axes.getFromId(gd, options.yref);\n      for (var key in shapeLabelTexttemplateVars) {\n        var val = shapeLabelTexttemplateVars[key](options, _xa, _ya);\n        if (val !== undefined) templateValues[key] = val;\n      }\n    }\n    text = Lib.texttemplateStringForShapes(options.label.texttemplate, {}, gd._fullLayout._d3locale, templateValues);\n  } else {\n    text = options.label.text;\n  }\n  var labelGroupAttrs = {\n    'data-index': index\n  };\n  var font = options.label.font;\n  var labelTextAttrs = {\n    'data-notex': 1\n  };\n  var labelGroup = shapeGroup.append('g').attr(labelGroupAttrs).classed('shape-label', true);\n  var labelText = labelGroup.append('text').attr(labelTextAttrs).classed('shape-label-text', true).text(text);\n\n  // Get x and y bounds of shape\n  var shapex0, shapex1, shapey0, shapey1;\n  if (options.path) {\n    // If shape is defined as a path, get the\n    // min and max bounds across all polygons in path\n    var d = getPathString(gd, options);\n    var polygons = readPaths(d, gd);\n    shapex0 = Infinity;\n    shapey0 = Infinity;\n    shapex1 = -Infinity;\n    shapey1 = -Infinity;\n    for (var i = 0; i < polygons.length; i++) {\n      for (var j = 0; j < polygons[i].length; j++) {\n        var p = polygons[i][j];\n        for (var k = 1; k < p.length; k += 2) {\n          var _x = p[k];\n          var _y = p[k + 1];\n          shapex0 = Math.min(shapex0, _x);\n          shapex1 = Math.max(shapex1, _x);\n          shapey0 = Math.min(shapey0, _y);\n          shapey1 = Math.max(shapey1, _y);\n        }\n      }\n    }\n  } else {\n    // Otherwise, we use the x and y bounds defined in the shape options\n    // and convert them to pixel coordinates\n    // Setup conversion functions\n    var xa = Axes.getFromId(gd, options.xref);\n    var xRefType = Axes.getRefType(options.xref);\n    var ya = Axes.getFromId(gd, options.yref);\n    var yRefType = Axes.getRefType(options.yref);\n    var x2p = helpers.getDataToPixel(gd, xa, false, xRefType);\n    var y2p = helpers.getDataToPixel(gd, ya, true, yRefType);\n    shapex0 = x2p(options.x0);\n    shapex1 = x2p(options.x1);\n    shapey0 = y2p(options.y0);\n    shapey1 = y2p(options.y1);\n  }\n\n  // Handle `auto` angle\n  var textangle = options.label.textangle;\n  if (textangle === 'auto') {\n    if (options.type === 'line') {\n      // Auto angle for line is same angle as line\n      textangle = calcTextAngle(shapex0, shapey0, shapex1, shapey1);\n    } else {\n      // Auto angle for all other shapes is 0\n      textangle = 0;\n    }\n  }\n\n  // Do an initial render so we can get the text bounding box height\n  labelText.call(function (s) {\n    s.call(Drawing.font, font).attr({});\n    svgTextUtils.convertToTspans(s, gd);\n    return s;\n  });\n  var textBB = Drawing.bBox(labelText.node());\n\n  // Calculate correct (x,y) for text\n  // We also determine true xanchor since xanchor depends on position when set to 'auto'\n  var textPos = calcTextPosition(shapex0, shapey0, shapex1, shapey1, options, textangle, textBB);\n  var textx = textPos.textx;\n  var texty = textPos.texty;\n  var xanchor = textPos.xanchor;\n\n  // Update (x,y) position, xanchor, and angle\n  labelText.attr({\n    'text-anchor': {\n      left: 'start',\n      center: 'middle',\n      right: 'end'\n    }[xanchor],\n    y: texty,\n    x: textx,\n    transform: 'rotate(' + textangle + ',' + textx + ',' + texty + ')'\n  }).call(svgTextUtils.positionText, textx, texty);\n};\nfunction calcTextAngle(shapex0, shapey0, shapex1, shapey1) {\n  var dy, dx;\n  dx = Math.abs(shapex1 - shapex0);\n  if (shapex1 >= shapex0) {\n    dy = shapey0 - shapey1;\n  } else {\n    dy = shapey1 - shapey0;\n  }\n  return -180 / Math.PI * Math.atan2(dy, dx);\n}\nfunction calcTextPosition(shapex0, shapey0, shapex1, shapey1, shapeOptions, actualTextAngle, textBB) {\n  var textPosition = shapeOptions.label.textposition;\n  var textAngle = shapeOptions.label.textangle;\n  var textPadding = shapeOptions.label.padding;\n  var shapeType = shapeOptions.type;\n  var textAngleRad = Math.PI / 180 * actualTextAngle;\n  var sinA = Math.sin(textAngleRad);\n  var cosA = Math.cos(textAngleRad);\n  var xanchor = shapeOptions.label.xanchor;\n  var yanchor = shapeOptions.label.yanchor;\n  var textx, texty, paddingX, paddingY;\n\n  // Text position functions differently for lines vs. other shapes\n  if (shapeType === 'line') {\n    // Set base position for start vs. center vs. end of line (default is 'center')\n    if (textPosition === 'start') {\n      textx = shapex0;\n      texty = shapey0;\n    } else if (textPosition === 'end') {\n      textx = shapex1;\n      texty = shapey1;\n    } else {\n      // Default: center\n      textx = (shapex0 + shapex1) / 2;\n      texty = (shapey0 + shapey1) / 2;\n    }\n\n    // Set xanchor if xanchor is 'auto'\n    if (xanchor === 'auto') {\n      if (textPosition === 'start') {\n        if (textAngle === 'auto') {\n          if (shapex1 > shapex0) xanchor = 'left';else if (shapex1 < shapex0) xanchor = 'right';else xanchor = 'center';\n        } else {\n          if (shapex1 > shapex0) xanchor = 'right';else if (shapex1 < shapex0) xanchor = 'left';else xanchor = 'center';\n        }\n      } else if (textPosition === 'end') {\n        if (textAngle === 'auto') {\n          if (shapex1 > shapex0) xanchor = 'right';else if (shapex1 < shapex0) xanchor = 'left';else xanchor = 'center';\n        } else {\n          if (shapex1 > shapex0) xanchor = 'left';else if (shapex1 < shapex0) xanchor = 'right';else xanchor = 'center';\n        }\n      } else {\n        xanchor = 'center';\n      }\n    }\n\n    // Special case for padding when angle is 'auto' for lines\n    // Padding should be treated as an orthogonal offset in this case\n    // Otherwise, padding is just a simple x and y offset\n    var paddingConstantsX = {\n      left: 1,\n      center: 0,\n      right: -1\n    };\n    var paddingConstantsY = {\n      bottom: -1,\n      middle: 0,\n      top: 1\n    };\n    if (textAngle === 'auto') {\n      // Set direction to apply padding (based on `yanchor` only)\n      var paddingDirection = paddingConstantsY[yanchor];\n      paddingX = -textPadding * sinA * paddingDirection;\n      paddingY = textPadding * cosA * paddingDirection;\n    } else {\n      // Set direction to apply padding (based on `xanchor` and `yanchor`)\n      var paddingDirectionX = paddingConstantsX[xanchor];\n      var paddingDirectionY = paddingConstantsY[yanchor];\n      paddingX = textPadding * paddingDirectionX;\n      paddingY = textPadding * paddingDirectionY;\n    }\n    textx = textx + paddingX;\n    texty = texty + paddingY;\n  } else {\n    // Text position for shapes that are not lines\n    // calc horizontal position\n    // Horizontal needs a little extra padding to look balanced\n    paddingX = textPadding + 3;\n    if (textPosition.indexOf('right') !== -1) {\n      textx = Math.max(shapex0, shapex1) - paddingX;\n      if (xanchor === 'auto') xanchor = 'right';\n    } else if (textPosition.indexOf('left') !== -1) {\n      textx = Math.min(shapex0, shapex1) + paddingX;\n      if (xanchor === 'auto') xanchor = 'left';\n    } else {\n      // Default: center\n      textx = (shapex0 + shapex1) / 2;\n      if (xanchor === 'auto') xanchor = 'center';\n    }\n\n    // calc vertical position\n    if (textPosition.indexOf('top') !== -1) {\n      texty = Math.min(shapey0, shapey1);\n    } else if (textPosition.indexOf('bottom') !== -1) {\n      texty = Math.max(shapey0, shapey1);\n    } else {\n      texty = (shapey0 + shapey1) / 2;\n    }\n    // Apply padding\n    paddingY = textPadding;\n    if (yanchor === 'bottom') {\n      texty = texty - paddingY;\n    } else if (yanchor === 'top') {\n      texty = texty + paddingY;\n    }\n  }\n\n  // Shift vertical (& horizontal) position according to `yanchor`\n  var shiftFraction = FROM_TL[yanchor];\n  // Adjust so that text is anchored at top of first line rather than at baseline of first line\n  var baselineAdjust = shapeOptions.label.font.size;\n  var textHeight = textBB.height;\n  var xshift = (textHeight * shiftFraction - baselineAdjust) * sinA;\n  var yshift = -(textHeight * shiftFraction - baselineAdjust) * cosA;\n  return {\n    textx: textx + xshift,\n    texty: texty + yshift,\n    xanchor: xanchor\n  };\n}","map":{"version":3,"names":["Lib","require","Axes","svgTextUtils","Drawing","readPaths","helpers","getPathString","shapeLabelTexttemplateVars","FROM_TL","module","exports","drawLabel","gd","index","options","shapeGroup","selectAll","remove","label","text","texttemplate","templateValues","type","_xa","getFromId","xref","_ya","yref","key","val","undefined","texttemplateStringForShapes","_fullLayout","_d3locale","labelGroupAttrs","font","labelTextAttrs","labelGroup","append","attr","classed","labelText","shapex0","shapex1","shapey0","shapey1","path","d","polygons","Infinity","i","length","j","p","k","_x","_y","Math","min","max","xa","xRefType","getRefType","ya","yRefType","x2p","getDataToPixel","y2p","x0","x1","y0","y1","textangle","calcTextAngle","call","s","convertToTspans","textBB","bBox","node","textPos","calcTextPosition","textx","texty","xanchor","left","center","right","y","x","transform","positionText","dy","dx","abs","PI","atan2","shapeOptions","actualTextAngle","textPosition","textposition","textAngle","textPadding","padding","shapeType","textAngleRad","sinA","sin","cosA","cos","yanchor","paddingX","paddingY","paddingConstantsX","paddingConstantsY","bottom","middle","top","paddingDirection","paddingDirectionX","paddingDirectionY","indexOf","shiftFraction","baselineAdjust","size","textHeight","height","xshift","yshift"],"sources":["/home/zhu/Documents/github/explorer_front/explorer_front_app/node_modules/plotly.js/src/components/shapes/display_labels.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Drawing = require('../drawing');\n\nvar readPaths = require('./draw_newshape/helpers').readPaths;\nvar helpers = require('./helpers');\nvar getPathString = helpers.getPathString;\nvar shapeLabelTexttemplateVars = require('./label_texttemplate');\n\nvar FROM_TL = require('../../constants/alignment').FROM_TL;\n\n\nmodule.exports = function drawLabel(gd, index, options, shapeGroup) {\n    // Remove existing label\n    shapeGroup.selectAll('.shape-label').remove();\n\n    // If no label text or texttemplate, return\n    if(!(options.label.text || options.label.texttemplate)) return;\n\n    // Text template overrides text\n    var text;\n    if(options.label.texttemplate) {\n        var templateValues = {};\n        if(options.type !== 'path') {\n            var _xa = Axes.getFromId(gd, options.xref);\n            var _ya = Axes.getFromId(gd, options.yref);\n            for(var key in shapeLabelTexttemplateVars) {\n                var val = shapeLabelTexttemplateVars[key](options, _xa, _ya);\n                if(val !== undefined) templateValues[key] = val;\n            }\n        }\n        text = Lib.texttemplateStringForShapes(options.label.texttemplate,\n            {},\n            gd._fullLayout._d3locale,\n            templateValues);\n    } else {\n        text = options.label.text;\n    }\n\n    var labelGroupAttrs = {\n        'data-index': index,\n    };\n    var font = options.label.font;\n\n    var labelTextAttrs = {\n        'data-notex': 1\n    };\n\n    var labelGroup = shapeGroup.append('g')\n        .attr(labelGroupAttrs)\n        .classed('shape-label', true);\n    var labelText = labelGroup.append('text')\n        .attr(labelTextAttrs)\n        .classed('shape-label-text', true)\n        .text(text);\n\n    // Get x and y bounds of shape\n    var shapex0, shapex1, shapey0, shapey1;\n    if(options.path) {\n        // If shape is defined as a path, get the\n        // min and max bounds across all polygons in path\n        var d = getPathString(gd, options);\n        var polygons = readPaths(d, gd);\n        shapex0 = Infinity;\n        shapey0 = Infinity;\n        shapex1 = -Infinity;\n        shapey1 = -Infinity;\n        for(var i = 0; i < polygons.length; i++) {\n            for(var j = 0; j < polygons[i].length; j++) {\n                var p = polygons[i][j];\n                for(var k = 1; k < p.length; k += 2) {\n                    var _x = p[k];\n                    var _y = p[k + 1];\n\n                    shapex0 = Math.min(shapex0, _x);\n                    shapex1 = Math.max(shapex1, _x);\n                    shapey0 = Math.min(shapey0, _y);\n                    shapey1 = Math.max(shapey1, _y);\n                }\n            }\n        }\n    } else {\n        // Otherwise, we use the x and y bounds defined in the shape options\n        // and convert them to pixel coordinates\n        // Setup conversion functions\n        var xa = Axes.getFromId(gd, options.xref);\n        var xRefType = Axes.getRefType(options.xref);\n        var ya = Axes.getFromId(gd, options.yref);\n        var yRefType = Axes.getRefType(options.yref);\n        var x2p = helpers.getDataToPixel(gd, xa, false, xRefType);\n        var y2p = helpers.getDataToPixel(gd, ya, true, yRefType);\n        shapex0 = x2p(options.x0);\n        shapex1 = x2p(options.x1);\n        shapey0 = y2p(options.y0);\n        shapey1 = y2p(options.y1);\n    }\n\n    // Handle `auto` angle\n    var textangle = options.label.textangle;\n    if(textangle === 'auto') {\n        if(options.type === 'line') {\n            // Auto angle for line is same angle as line\n            textangle = calcTextAngle(shapex0, shapey0, shapex1, shapey1);\n        } else {\n            // Auto angle for all other shapes is 0\n            textangle = 0;\n        }\n    }\n\n    // Do an initial render so we can get the text bounding box height\n    labelText.call(function(s) {\n        s.call(Drawing.font, font).attr({});\n        svgTextUtils.convertToTspans(s, gd);\n        return s;\n    });\n    var textBB = Drawing.bBox(labelText.node());\n\n    // Calculate correct (x,y) for text\n    // We also determine true xanchor since xanchor depends on position when set to 'auto'\n    var textPos = calcTextPosition(shapex0, shapey0, shapex1, shapey1, options, textangle, textBB);\n    var textx = textPos.textx;\n    var texty = textPos.texty;\n    var xanchor = textPos.xanchor;\n\n    // Update (x,y) position, xanchor, and angle\n    labelText.attr({\n        'text-anchor': {\n            left: 'start',\n            center: 'middle',\n            right: 'end'\n        }[xanchor],\n        y: texty,\n        x: textx,\n        transform: 'rotate(' + textangle + ',' + textx + ',' + texty + ')'\n    }).call(svgTextUtils.positionText, textx, texty);\n};\n\nfunction calcTextAngle(shapex0, shapey0, shapex1, shapey1) {\n    var dy, dx;\n    dx = Math.abs(shapex1 - shapex0);\n    if(shapex1 >= shapex0) {\n        dy = shapey0 - shapey1;\n    } else {\n        dy = shapey1 - shapey0;\n    }\n    return -180 / Math.PI * Math.atan2(dy, dx);\n}\n\nfunction calcTextPosition(shapex0, shapey0, shapex1, shapey1, shapeOptions, actualTextAngle, textBB) {\n    var textPosition = shapeOptions.label.textposition;\n    var textAngle = shapeOptions.label.textangle;\n    var textPadding = shapeOptions.label.padding;\n    var shapeType = shapeOptions.type;\n    var textAngleRad = Math.PI / 180 * actualTextAngle;\n    var sinA = Math.sin(textAngleRad);\n    var cosA = Math.cos(textAngleRad);\n    var xanchor = shapeOptions.label.xanchor;\n    var yanchor = shapeOptions.label.yanchor;\n\n    var textx, texty, paddingX, paddingY;\n\n    // Text position functions differently for lines vs. other shapes\n    if(shapeType === 'line') {\n        // Set base position for start vs. center vs. end of line (default is 'center')\n        if(textPosition === 'start') {\n            textx = shapex0;\n            texty = shapey0;\n        } else if(textPosition === 'end') {\n            textx = shapex1;\n            texty = shapey1;\n        } else { // Default: center\n            textx = (shapex0 + shapex1) / 2;\n            texty = (shapey0 + shapey1) / 2;\n        }\n\n        // Set xanchor if xanchor is 'auto'\n        if(xanchor === 'auto') {\n            if(textPosition === 'start') {\n                if(textAngle === 'auto') {\n                    if(shapex1 > shapex0) xanchor = 'left';\n                    else if(shapex1 < shapex0) xanchor = 'right';\n                    else xanchor = 'center';\n                } else {\n                    if(shapex1 > shapex0) xanchor = 'right';\n                    else if(shapex1 < shapex0) xanchor = 'left';\n                    else xanchor = 'center';\n                }\n            } else if(textPosition === 'end') {\n                if(textAngle === 'auto') {\n                    if(shapex1 > shapex0) xanchor = 'right';\n                    else if(shapex1 < shapex0) xanchor = 'left';\n                    else xanchor = 'center';\n                } else {\n                    if(shapex1 > shapex0) xanchor = 'left';\n                    else if(shapex1 < shapex0) xanchor = 'right';\n                    else xanchor = 'center';\n                }\n            } else {\n                xanchor = 'center';\n            }\n        }\n\n        // Special case for padding when angle is 'auto' for lines\n        // Padding should be treated as an orthogonal offset in this case\n        // Otherwise, padding is just a simple x and y offset\n        var paddingConstantsX = { left: 1, center: 0, right: -1 };\n        var paddingConstantsY = { bottom: -1, middle: 0, top: 1 };\n        if(textAngle === 'auto') {\n            // Set direction to apply padding (based on `yanchor` only)\n            var paddingDirection = paddingConstantsY[yanchor];\n            paddingX = -textPadding * sinA * paddingDirection;\n            paddingY = textPadding * cosA * paddingDirection;\n        } else {\n            // Set direction to apply padding (based on `xanchor` and `yanchor`)\n            var paddingDirectionX = paddingConstantsX[xanchor];\n            var paddingDirectionY = paddingConstantsY[yanchor];\n            paddingX = textPadding * paddingDirectionX;\n            paddingY = textPadding * paddingDirectionY;\n        }\n        textx = textx + paddingX;\n        texty = texty + paddingY;\n    } else {\n        // Text position for shapes that are not lines\n        // calc horizontal position\n        // Horizontal needs a little extra padding to look balanced\n        paddingX = textPadding + 3;\n        if(textPosition.indexOf('right') !== -1) {\n            textx = Math.max(shapex0, shapex1) - paddingX;\n            if(xanchor === 'auto') xanchor = 'right';\n        } else if(textPosition.indexOf('left') !== -1) {\n            textx = Math.min(shapex0, shapex1) + paddingX;\n            if(xanchor === 'auto') xanchor = 'left';\n        } else { // Default: center\n            textx = (shapex0 + shapex1) / 2;\n            if(xanchor === 'auto') xanchor = 'center';\n        }\n\n        // calc vertical position\n        if(textPosition.indexOf('top') !== -1) {\n            texty = Math.min(shapey0, shapey1);\n        } else if(textPosition.indexOf('bottom') !== -1) {\n            texty = Math.max(shapey0, shapey1);\n        } else {\n            texty = (shapey0 + shapey1) / 2;\n        }\n        // Apply padding\n        paddingY = textPadding;\n        if(yanchor === 'bottom') {\n            texty = texty - paddingY;\n        } else if(yanchor === 'top') {\n            texty = texty + paddingY;\n        }\n    }\n\n    // Shift vertical (& horizontal) position according to `yanchor`\n    var shiftFraction = FROM_TL[yanchor];\n    // Adjust so that text is anchored at top of first line rather than at baseline of first line\n    var baselineAdjust = shapeOptions.label.font.size;\n    var textHeight = textBB.height;\n    var xshift = (textHeight * shiftFraction - baselineAdjust) * sinA;\n    var yshift = -(textHeight * shiftFraction - baselineAdjust) * cosA;\n\n    return { textx: textx + xshift, texty: texty + yshift, xanchor: xanchor };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}