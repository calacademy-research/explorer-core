{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array-buffer.detached.js\");\nrequire(\"core-js/modules/es.array-buffer.transfer.js\");\nrequire(\"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\");\nrequire(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\nvar isNumeric = require('fast-isnumeric');\nvar svgSdf = require('svg-path-sdf');\nvar rgba = require('color-normalize');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\nvar Drawing = require('../../components/drawing');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\nvar formatColor = require('../../lib/gl_format_color').formatColor;\nvar subTypes = require('../scatter/subtypes');\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\nvar helpers = require('./helpers');\nvar constants = require('./constants');\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\nvar TEXTOFFSETSIGN = {\n  start: 1,\n  left: 1,\n  end: -1,\n  right: -1,\n  middle: 0,\n  center: 0,\n  bottom: 1,\n  top: -1\n};\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\nfunction convertStyle(gd, trace) {\n  var i;\n  var opts = {\n    marker: undefined,\n    markerSel: undefined,\n    markerUnsel: undefined,\n    line: undefined,\n    fill: undefined,\n    errorX: undefined,\n    errorY: undefined,\n    text: undefined,\n    textSel: undefined,\n    textUnsel: undefined\n  };\n  var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n  if (trace.visible !== true) return opts;\n  if (subTypes.hasText(trace)) {\n    opts.text = convertTextStyle(gd, trace);\n    opts.textSel = convertTextSelection(gd, trace, trace.selected);\n    opts.textUnsel = convertTextSelection(gd, trace, trace.unselected);\n  }\n  if (subTypes.hasMarkers(trace)) {\n    opts.marker = convertMarkerStyle(gd, trace);\n    opts.markerSel = convertMarkerSelection(gd, trace, trace.selected);\n    opts.markerUnsel = convertMarkerSelection(gd, trace, trace.unselected);\n    if (!trace.unselected && isArrayOrTypedArray(trace.marker.opacity)) {\n      var mo = trace.marker.opacity;\n      opts.markerUnsel.opacity = new Array(mo.length);\n      for (i = 0; i < mo.length; i++) {\n        opts.markerUnsel.opacity[i] = DESELECTDIM * mo[i];\n      }\n    }\n  }\n  if (subTypes.hasLines(trace)) {\n    opts.line = {\n      overlay: true,\n      thickness: trace.line.width * plotGlPixelRatio,\n      color: trace.line.color,\n      opacity: trace.opacity\n    };\n    var dashes = (constants.DASHES[trace.line.dash] || [1]).slice();\n    for (i = 0; i < dashes.length; ++i) {\n      dashes[i] *= trace.line.width * plotGlPixelRatio;\n    }\n    opts.line.dashes = dashes;\n  }\n  if (trace.error_x && trace.error_x.visible) {\n    opts.errorX = convertErrorBarStyle(trace, trace.error_x, plotGlPixelRatio);\n  }\n  if (trace.error_y && trace.error_y.visible) {\n    opts.errorY = convertErrorBarStyle(trace, trace.error_y, plotGlPixelRatio);\n  }\n  if (!!trace.fill && trace.fill !== 'none') {\n    opts.fill = {\n      closed: true,\n      fill: trace.fillcolor,\n      thickness: 0\n    };\n  }\n  return opts;\n}\nfunction convertTextStyle(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var count = trace._length;\n  var textfontIn = trace.textfont;\n  var textpositionIn = trace.textposition;\n  var textPos = isArrayOrTypedArray(textpositionIn) ? textpositionIn : [textpositionIn];\n  var tfc = textfontIn.color;\n  var tfs = textfontIn.size;\n  var tff = textfontIn.family;\n  var optsOut = {};\n  var i;\n  var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n  var texttemplate = trace.texttemplate;\n  if (texttemplate) {\n    optsOut.text = [];\n    var d3locale = fullLayout._d3locale;\n    var isArray = Array.isArray(texttemplate);\n    var N = isArray ? Math.min(texttemplate.length, count) : count;\n    var txt = isArray ? function (i) {\n      return texttemplate[i];\n    } : function () {\n      return texttemplate;\n    };\n    for (i = 0; i < N; i++) {\n      var d = {\n        i: i\n      };\n      var labels = trace._module.formatLabels(d, trace, fullLayout);\n      var pointValues = {};\n      appendArrayPointValue(pointValues, trace, i);\n      var meta = trace._meta || {};\n      optsOut.text.push(Lib.texttemplateString(txt(i), labels, d3locale, pointValues, d, meta));\n    }\n  } else {\n    if (isArrayOrTypedArray(trace.text) && trace.text.length < count) {\n      // if text array is shorter, we'll need to append to it, so let's slice to prevent mutating\n      optsOut.text = trace.text.slice();\n    } else {\n      optsOut.text = trace.text;\n    }\n  }\n  // pad text array with empty strings\n  if (isArrayOrTypedArray(optsOut.text)) {\n    for (i = optsOut.text.length; i < count; i++) {\n      optsOut.text[i] = '';\n    }\n  }\n  optsOut.opacity = trace.opacity;\n  optsOut.font = {};\n  optsOut.align = [];\n  optsOut.baseline = [];\n  for (i = 0; i < textPos.length; i++) {\n    var tp = textPos[i].split(/\\s+/);\n    switch (tp[1]) {\n      case 'left':\n        optsOut.align.push('right');\n        break;\n      case 'right':\n        optsOut.align.push('left');\n        break;\n      default:\n        optsOut.align.push(tp[1]);\n    }\n    switch (tp[0]) {\n      case 'top':\n        optsOut.baseline.push('bottom');\n        break;\n      case 'bottom':\n        optsOut.baseline.push('top');\n        break;\n      default:\n        optsOut.baseline.push(tp[0]);\n    }\n  }\n  if (isArrayOrTypedArray(tfc)) {\n    optsOut.color = new Array(count);\n    for (i = 0; i < count; i++) {\n      optsOut.color[i] = tfc[i];\n    }\n  } else {\n    optsOut.color = tfc;\n  }\n  if (isArrayOrTypedArray(tfs) || isArrayOrTypedArray(tff)) {\n    // if any textfont param is array - make render a batch\n    optsOut.font = new Array(count);\n    for (i = 0; i < count; i++) {\n      var fonti = optsOut.font[i] = {};\n      fonti.size = (Lib.isTypedArray(tfs) ? tfs[i] : isArrayOrTypedArray(tfs) ? isNumeric(tfs[i]) ? tfs[i] : 0 : tfs) * plotGlPixelRatio;\n      fonti.family = isArrayOrTypedArray(tff) ? tff[i] : tff;\n    }\n  } else {\n    // if both are single values, make render fast single-value\n    optsOut.font = {\n      size: tfs * plotGlPixelRatio,\n      family: tff\n    };\n  }\n  return optsOut;\n}\nfunction convertMarkerStyle(gd, trace) {\n  var count = trace._length;\n  var optsIn = trace.marker;\n  var optsOut = {};\n  var i;\n  var multiSymbol = isArrayOrTypedArray(optsIn.symbol);\n  var multiAngle = isArrayOrTypedArray(optsIn.angle);\n  var multiColor = isArrayOrTypedArray(optsIn.color);\n  var multiLineColor = isArrayOrTypedArray(optsIn.line.color);\n  var multiOpacity = isArrayOrTypedArray(optsIn.opacity);\n  var multiSize = isArrayOrTypedArray(optsIn.size);\n  var multiLineWidth = isArrayOrTypedArray(optsIn.line.width);\n  var isOpen;\n  if (!multiSymbol) isOpen = helpers.isOpenSymbol(optsIn.symbol);\n\n  // prepare colors\n  if (multiSymbol || multiColor || multiLineColor || multiOpacity || multiAngle) {\n    optsOut.symbols = new Array(count);\n    optsOut.angles = new Array(count);\n    optsOut.colors = new Array(count);\n    optsOut.borderColors = new Array(count);\n    var symbols = optsIn.symbol;\n    var angles = optsIn.angle;\n    var colors = formatColor(optsIn, optsIn.opacity, count);\n    var borderColors = formatColor(optsIn.line, optsIn.opacity, count);\n    if (!isArrayOrTypedArray(borderColors[0])) {\n      var borderColor = borderColors;\n      borderColors = Array(count);\n      for (i = 0; i < count; i++) {\n        borderColors[i] = borderColor;\n      }\n    }\n    if (!isArrayOrTypedArray(colors[0])) {\n      var color = colors;\n      colors = Array(count);\n      for (i = 0; i < count; i++) {\n        colors[i] = color;\n      }\n    }\n    if (!isArrayOrTypedArray(symbols)) {\n      var symbol = symbols;\n      symbols = Array(count);\n      for (i = 0; i < count; i++) {\n        symbols[i] = symbol;\n      }\n    }\n    if (!isArrayOrTypedArray(angles)) {\n      var angle = angles;\n      angles = Array(count);\n      for (i = 0; i < count; i++) {\n        angles[i] = angle;\n      }\n    }\n    optsOut.symbols = symbols;\n    optsOut.angles = angles;\n    optsOut.colors = colors;\n    optsOut.borderColors = borderColors;\n    for (i = 0; i < count; i++) {\n      if (multiSymbol) {\n        isOpen = helpers.isOpenSymbol(optsIn.symbol[i]);\n      }\n      if (isOpen) {\n        borderColors[i] = colors[i].slice();\n        colors[i] = colors[i].slice();\n        colors[i][3] = 0;\n      }\n    }\n    optsOut.opacity = trace.opacity;\n    optsOut.markers = new Array(count);\n    for (i = 0; i < count; i++) {\n      optsOut.markers[i] = getSymbolSdf({\n        mx: optsOut.symbols[i],\n        ma: optsOut.angles[i]\n      }, trace);\n    }\n  } else {\n    if (isOpen) {\n      optsOut.color = rgba(optsIn.color, 'uint8');\n      optsOut.color[3] = 0;\n      optsOut.borderColor = rgba(optsIn.color, 'uint8');\n    } else {\n      optsOut.color = rgba(optsIn.color, 'uint8');\n      optsOut.borderColor = rgba(optsIn.line.color, 'uint8');\n    }\n    optsOut.opacity = trace.opacity * optsIn.opacity;\n    optsOut.marker = getSymbolSdf({\n      mx: optsIn.symbol,\n      ma: optsIn.angle\n    }, trace);\n  }\n\n  // prepare sizes\n  var sizeFactor = 1;\n  var markerSizeFunc = makeBubbleSizeFn(trace, sizeFactor);\n  var s;\n  if (multiSize || multiLineWidth) {\n    var sizes = optsOut.sizes = new Array(count);\n    var borderSizes = optsOut.borderSizes = new Array(count);\n    var sizeTotal = 0;\n    var sizeAvg;\n    if (multiSize) {\n      for (i = 0; i < count; i++) {\n        sizes[i] = markerSizeFunc(optsIn.size[i]);\n        sizeTotal += sizes[i];\n      }\n      sizeAvg = sizeTotal / count;\n    } else {\n      s = markerSizeFunc(optsIn.size);\n      for (i = 0; i < count; i++) {\n        sizes[i] = s;\n      }\n    }\n\n    // See  https://github.com/plotly/plotly.js/pull/1781#discussion_r121820798\n    if (multiLineWidth) {\n      for (i = 0; i < count; i++) {\n        borderSizes[i] = optsIn.line.width[i];\n      }\n    } else {\n      s = optsIn.line.width;\n      for (i = 0; i < count; i++) {\n        borderSizes[i] = s;\n      }\n    }\n    optsOut.sizeAvg = sizeAvg;\n  } else {\n    optsOut.size = markerSizeFunc(optsIn && optsIn.size || 10);\n    optsOut.borderSizes = markerSizeFunc(optsIn.line.width);\n  }\n  return optsOut;\n}\nfunction convertMarkerSelection(gd, trace, target) {\n  var optsIn = trace.marker;\n  var optsOut = {};\n  if (!target) return optsOut;\n  if (target.marker && target.marker.symbol) {\n    optsOut = convertMarkerStyle(gd, Lib.extendFlat({}, optsIn, target.marker));\n  } else if (target.marker) {\n    if (target.marker.size) optsOut.size = target.marker.size;\n    if (target.marker.color) optsOut.colors = target.marker.color;\n    if (target.marker.opacity !== undefined) optsOut.opacity = target.marker.opacity;\n  }\n  return optsOut;\n}\nfunction convertTextSelection(gd, trace, target) {\n  var optsOut = {};\n  if (!target) return optsOut;\n  if (target.textfont) {\n    var optsIn = {\n      opacity: 1,\n      text: trace.text,\n      texttemplate: trace.texttemplate,\n      textposition: trace.textposition,\n      textfont: Lib.extendFlat({}, trace.textfont)\n    };\n    if (target.textfont) {\n      Lib.extendFlat(optsIn.textfont, target.textfont);\n    }\n    optsOut = convertTextStyle(gd, optsIn);\n  }\n  return optsOut;\n}\nfunction convertErrorBarStyle(trace, target, plotGlPixelRatio) {\n  var optsOut = {\n    capSize: target.width * 2 * plotGlPixelRatio,\n    lineWidth: target.thickness * plotGlPixelRatio,\n    color: target.color\n  };\n  if (target.copy_ystyle) {\n    optsOut = trace.error_y;\n  }\n  return optsOut;\n}\nvar SYMBOL_SDF_SIZE = constants.SYMBOL_SDF_SIZE;\nvar SYMBOL_SIZE = constants.SYMBOL_SIZE;\nvar SYMBOL_STROKE = constants.SYMBOL_STROKE;\nvar SYMBOL_SDF = {};\nvar SYMBOL_SVG_CIRCLE = Drawing.symbolFuncs[0](SYMBOL_SIZE * 0.05);\nfunction getSymbolSdf(d, trace) {\n  var symbol = d.mx;\n  if (symbol === 'circle') return null;\n  var symbolPath, symbolSdf;\n  var symbolNumber = Drawing.symbolNumber(symbol);\n  var symbolFunc = Drawing.symbolFuncs[symbolNumber % 100];\n  var symbolNoDot = !!Drawing.symbolNoDot[symbolNumber % 100];\n  var symbolNoFill = !!Drawing.symbolNoFill[symbolNumber % 100];\n  var isDot = helpers.isDotSymbol(symbol);\n\n  // until we may handle angles in shader?\n  if (d.ma) symbol += '_' + d.ma;\n\n  // get symbol sdf from cache or generate it\n  if (SYMBOL_SDF[symbol]) return SYMBOL_SDF[symbol];\n  var angle = Drawing.getMarkerAngle(d, trace);\n  if (isDot && !symbolNoDot) {\n    symbolPath = symbolFunc(SYMBOL_SIZE * 1.1, angle) + SYMBOL_SVG_CIRCLE;\n  } else {\n    symbolPath = symbolFunc(SYMBOL_SIZE, angle);\n  }\n  symbolSdf = svgSdf(symbolPath, {\n    w: SYMBOL_SDF_SIZE,\n    h: SYMBOL_SDF_SIZE,\n    viewBox: [-SYMBOL_SIZE, -SYMBOL_SIZE, SYMBOL_SIZE, SYMBOL_SIZE],\n    stroke: symbolNoFill ? SYMBOL_STROKE : -SYMBOL_STROKE\n  });\n  SYMBOL_SDF[symbol] = symbolSdf;\n  return symbolSdf || null;\n}\nfunction convertLinePositions(gd, trace, positions) {\n  var len = positions.length;\n  var count = len / 2;\n  var linePositions;\n  var i;\n  if (subTypes.hasLines(trace) && count) {\n    if (trace.line.shape === 'hv') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n          linePositions.push(NaN, NaN, NaN, NaN);\n        } else {\n          linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n            linePositions.push(positions[i * 2 + 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'hvh') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n          if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n          linePositions.push(NaN, NaN);\n        } else {\n          var midPtX = (positions[i * 2] + positions[i * 2 + 2]) / 2;\n          linePositions.push(positions[i * 2], positions[i * 2 + 1], midPtX, positions[i * 2 + 1], midPtX, positions[i * 2 + 3]);\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'vhv') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n          if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n          linePositions.push(NaN, NaN);\n        } else {\n          var midPtY = (positions[i * 2 + 1] + positions[i * 2 + 3]) / 2;\n          linePositions.push(positions[i * 2], positions[i * 2 + 1], positions[i * 2], midPtY, positions[i * 2 + 2], midPtY);\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'vh') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n          linePositions.push(NaN, NaN, NaN, NaN);\n        } else {\n          linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 3]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else {\n      linePositions = positions;\n    }\n  }\n\n  // If we have data with gaps, we ought to use rect joins\n  // FIXME: get rid of this\n  var hasNaN = false;\n  for (i = 0; i < linePositions.length; i++) {\n    if (isNaN(linePositions[i])) {\n      hasNaN = true;\n      break;\n    }\n  }\n  var join = hasNaN || linePositions.length > constants.TOO_MANY_POINTS ? 'rect' : subTypes.hasMarkers(trace) ? 'rect' : 'round';\n\n  // fill gaps\n  if (hasNaN && trace.connectgaps) {\n    var lastX = linePositions[0];\n    var lastY = linePositions[1];\n    for (i = 0; i < linePositions.length; i += 2) {\n      if (isNaN(linePositions[i]) || isNaN(linePositions[i + 1])) {\n        linePositions[i] = lastX;\n        linePositions[i + 1] = lastY;\n      } else {\n        lastX = linePositions[i];\n        lastY = linePositions[i + 1];\n      }\n    }\n  }\n  return {\n    join: join,\n    positions: linePositions\n  };\n}\nfunction convertErrorBarPositions(gd, trace, positions, x, y) {\n  var makeComputeError = Registry.getComponentMethod('errorbars', 'makeComputeError');\n  var xa = AxisIDs.getFromId(gd, trace.xaxis, 'x');\n  var ya = AxisIDs.getFromId(gd, trace.yaxis, 'y');\n  var count = positions.length / 2;\n  var out = {};\n  function convertOneAxis(coords, ax) {\n    var axLetter = ax._id.charAt(0);\n    var opts = trace['error_' + axLetter];\n    if (opts && opts.visible && (ax.type === 'linear' || ax.type === 'log')) {\n      var computeError = makeComputeError(opts);\n      var pOffset = {\n        x: 0,\n        y: 1\n      }[axLetter];\n      var eOffset = {\n        x: [0, 1, 2, 3],\n        y: [2, 3, 0, 1]\n      }[axLetter];\n      var errors = new Float64Array(4 * count);\n      var minShoe = Infinity;\n      var maxHat = -Infinity;\n      for (var i = 0, j = 0; i < count; i++, j += 4) {\n        var dc = coords[i];\n        if (isNumeric(dc)) {\n          var dl = positions[i * 2 + pOffset];\n          var vals = computeError(dc, i);\n          var lv = vals[0];\n          var hv = vals[1];\n          if (isNumeric(lv) && isNumeric(hv)) {\n            var shoe = dc - lv;\n            var hat = dc + hv;\n            errors[j + eOffset[0]] = dl - ax.c2l(shoe);\n            errors[j + eOffset[1]] = ax.c2l(hat) - dl;\n            errors[j + eOffset[2]] = 0;\n            errors[j + eOffset[3]] = 0;\n            minShoe = Math.min(minShoe, dc - lv);\n            maxHat = Math.max(maxHat, dc + hv);\n          }\n        }\n      }\n      out[axLetter] = {\n        positions: positions,\n        errors: errors,\n        _bnds: [minShoe, maxHat]\n      };\n    }\n  }\n  convertOneAxis(x, xa);\n  convertOneAxis(y, ya);\n  return out;\n}\nfunction convertTextPosition(gd, trace, textOpts, markerOpts) {\n  var count = trace._length;\n  var out = {};\n  var i;\n\n  // corresponds to textPointPosition from component.drawing\n  if (subTypes.hasMarkers(trace)) {\n    var fontOpts = textOpts.font;\n    var align = textOpts.align;\n    var baseline = textOpts.baseline;\n    out.offset = new Array(count);\n    for (i = 0; i < count; i++) {\n      var ms = markerOpts.sizes ? markerOpts.sizes[i] : markerOpts.size;\n      var fs = isArrayOrTypedArray(fontOpts) ? fontOpts[i].size : fontOpts.size;\n      var a = isArrayOrTypedArray(align) ? align.length > 1 ? align[i] : align[0] : align;\n      var b = isArrayOrTypedArray(baseline) ? baseline.length > 1 ? baseline[i] : baseline[0] : baseline;\n      var hSign = TEXTOFFSETSIGN[a];\n      var vSign = TEXTOFFSETSIGN[b];\n      var xPad = ms ? ms / 0.8 + 1 : 0;\n      var yPad = -vSign * xPad - vSign * 0.5;\n      out.offset[i] = [hSign * xPad / fs, yPad / fs];\n    }\n  }\n  return out;\n}\nmodule.exports = {\n  style: convertStyle,\n  markerStyle: convertMarkerStyle,\n  markerSelection: convertMarkerSelection,\n  linePositions: convertLinePositions,\n  errorBarPositions: convertErrorBarPositions,\n  textPosition: convertTextPosition\n};","map":{"version":3,"names":["require","isNumeric","svgSdf","rgba","Registry","Lib","isArrayOrTypedArray","Drawing","AxisIDs","formatColor","subTypes","makeBubbleSizeFn","helpers","constants","DESELECTDIM","TEXTOFFSETSIGN","start","left","end","right","middle","center","bottom","top","appendArrayPointValue","convertStyle","gd","trace","i","opts","marker","undefined","markerSel","markerUnsel","line","fill","errorX","errorY","text","textSel","textUnsel","plotGlPixelRatio","_context","visible","hasText","convertTextStyle","convertTextSelection","selected","unselected","hasMarkers","convertMarkerStyle","convertMarkerSelection","opacity","mo","Array","length","hasLines","overlay","thickness","width","color","dashes","DASHES","dash","slice","error_x","convertErrorBarStyle","error_y","closed","fillcolor","fullLayout","_fullLayout","count","_length","textfontIn","textfont","textpositionIn","textposition","textPos","tfc","tfs","size","tff","family","optsOut","texttemplate","d3locale","_d3locale","isArray","N","Math","min","txt","d","labels","_module","formatLabels","pointValues","meta","_meta","push","texttemplateString","font","align","baseline","tp","split","fonti","isTypedArray","optsIn","multiSymbol","symbol","multiAngle","angle","multiColor","multiLineColor","multiOpacity","multiSize","multiLineWidth","isOpen","isOpenSymbol","symbols","angles","colors","borderColors","borderColor","markers","getSymbolSdf","mx","ma","sizeFactor","markerSizeFunc","s","sizes","borderSizes","sizeTotal","sizeAvg","target","extendFlat","capSize","lineWidth","copy_ystyle","SYMBOL_SDF_SIZE","SYMBOL_SIZE","SYMBOL_STROKE","SYMBOL_SDF","SYMBOL_SVG_CIRCLE","symbolFuncs","symbolPath","symbolSdf","symbolNumber","symbolFunc","symbolNoDot","symbolNoFill","isDot","isDotSymbol","getMarkerAngle","w","h","viewBox","stroke","convertLinePositions","positions","len","linePositions","shape","isNaN","NaN","midPtX","midPtY","hasNaN","join","TOO_MANY_POINTS","connectgaps","lastX","lastY","convertErrorBarPositions","x","y","makeComputeError","getComponentMethod","xa","getFromId","xaxis","ya","yaxis","out","convertOneAxis","coords","ax","axLetter","_id","charAt","type","computeError","pOffset","eOffset","errors","Float64Array","minShoe","Infinity","maxHat","j","dc","dl","vals","lv","hv","shoe","hat","c2l","max","_bnds","convertTextPosition","textOpts","markerOpts","fontOpts","offset","ms","fs","a","b","hSign","vSign","xPad","yPad","module","exports","style","markerStyle","markerSelection","errorBarPositions","textPosition"],"sources":["/home/zhu/Documents/github/explorer_front/explorer_front_app/node_modules/plotly.js/src/traces/scattergl/convert.js"],"sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar svgSdf = require('svg-path-sdf');\nvar rgba = require('color-normalize');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\nvar Drawing = require('../../components/drawing');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nvar formatColor = require('../../lib/gl_format_color').formatColor;\nvar subTypes = require('../scatter/subtypes');\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\n\nvar helpers = require('./helpers');\nvar constants = require('./constants');\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nvar TEXTOFFSETSIGN = {\n    start: 1, left: 1, end: -1, right: -1, middle: 0, center: 0, bottom: 1, top: -1\n};\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nfunction convertStyle(gd, trace) {\n    var i;\n\n    var opts = {\n        marker: undefined,\n        markerSel: undefined,\n        markerUnsel: undefined,\n        line: undefined,\n        fill: undefined,\n        errorX: undefined,\n        errorY: undefined,\n        text: undefined,\n        textSel: undefined,\n        textUnsel: undefined\n    };\n\n    var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n\n    if(trace.visible !== true) return opts;\n\n    if(subTypes.hasText(trace)) {\n        opts.text = convertTextStyle(gd, trace);\n        opts.textSel = convertTextSelection(gd, trace, trace.selected);\n        opts.textUnsel = convertTextSelection(gd, trace, trace.unselected);\n    }\n\n    if(subTypes.hasMarkers(trace)) {\n        opts.marker = convertMarkerStyle(gd, trace);\n        opts.markerSel = convertMarkerSelection(gd, trace, trace.selected);\n        opts.markerUnsel = convertMarkerSelection(gd, trace, trace.unselected);\n\n        if(!trace.unselected && isArrayOrTypedArray(trace.marker.opacity)) {\n            var mo = trace.marker.opacity;\n            opts.markerUnsel.opacity = new Array(mo.length);\n            for(i = 0; i < mo.length; i++) {\n                opts.markerUnsel.opacity[i] = DESELECTDIM * mo[i];\n            }\n        }\n    }\n\n    if(subTypes.hasLines(trace)) {\n        opts.line = {\n            overlay: true,\n            thickness: trace.line.width * plotGlPixelRatio,\n            color: trace.line.color,\n            opacity: trace.opacity\n        };\n\n        var dashes = (constants.DASHES[trace.line.dash] || [1]).slice();\n        for(i = 0; i < dashes.length; ++i) {\n            dashes[i] *= trace.line.width * plotGlPixelRatio;\n        }\n        opts.line.dashes = dashes;\n    }\n\n    if(trace.error_x && trace.error_x.visible) {\n        opts.errorX = convertErrorBarStyle(trace, trace.error_x, plotGlPixelRatio);\n    }\n\n    if(trace.error_y && trace.error_y.visible) {\n        opts.errorY = convertErrorBarStyle(trace, trace.error_y, plotGlPixelRatio);\n    }\n\n    if(!!trace.fill && trace.fill !== 'none') {\n        opts.fill = {\n            closed: true,\n            fill: trace.fillcolor,\n            thickness: 0\n        };\n    }\n\n    return opts;\n}\n\nfunction convertTextStyle(gd, trace) {\n    var fullLayout = gd._fullLayout;\n    var count = trace._length;\n    var textfontIn = trace.textfont;\n    var textpositionIn = trace.textposition;\n    var textPos = isArrayOrTypedArray(textpositionIn) ? textpositionIn : [textpositionIn];\n    var tfc = textfontIn.color;\n    var tfs = textfontIn.size;\n    var tff = textfontIn.family;\n    var optsOut = {};\n    var i;\n    var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n\n    var texttemplate = trace.texttemplate;\n    if(texttemplate) {\n        optsOut.text = [];\n\n        var d3locale = fullLayout._d3locale;\n        var isArray = Array.isArray(texttemplate);\n        var N = isArray ? Math.min(texttemplate.length, count) : count;\n        var txt = isArray ?\n            function(i) { return texttemplate[i]; } :\n            function() { return texttemplate; };\n\n        for(i = 0; i < N; i++) {\n            var d = {i: i};\n            var labels = trace._module.formatLabels(d, trace, fullLayout);\n            var pointValues = {};\n            appendArrayPointValue(pointValues, trace, i);\n            var meta = trace._meta || {};\n            optsOut.text.push(Lib.texttemplateString(txt(i), labels, d3locale, pointValues, d, meta));\n        }\n    } else {\n        if(isArrayOrTypedArray(trace.text) && trace.text.length < count) {\n            // if text array is shorter, we'll need to append to it, so let's slice to prevent mutating\n            optsOut.text = trace.text.slice();\n        } else {\n            optsOut.text = trace.text;\n        }\n    }\n    // pad text array with empty strings\n    if(isArrayOrTypedArray(optsOut.text)) {\n        for(i = optsOut.text.length; i < count; i++) {\n            optsOut.text[i] = '';\n        }\n    }\n\n    optsOut.opacity = trace.opacity;\n    optsOut.font = {};\n    optsOut.align = [];\n    optsOut.baseline = [];\n\n    for(i = 0; i < textPos.length; i++) {\n        var tp = textPos[i].split(/\\s+/);\n\n        switch(tp[1]) {\n            case 'left':\n                optsOut.align.push('right');\n                break;\n            case 'right':\n                optsOut.align.push('left');\n                break;\n            default:\n                optsOut.align.push(tp[1]);\n        }\n        switch(tp[0]) {\n            case 'top':\n                optsOut.baseline.push('bottom');\n                break;\n            case 'bottom':\n                optsOut.baseline.push('top');\n                break;\n            default:\n                optsOut.baseline.push(tp[0]);\n        }\n    }\n\n    if(isArrayOrTypedArray(tfc)) {\n        optsOut.color = new Array(count);\n        for(i = 0; i < count; i++) {\n            optsOut.color[i] = tfc[i];\n        }\n    } else {\n        optsOut.color = tfc;\n    }\n\n    if(isArrayOrTypedArray(tfs) || isArrayOrTypedArray(tff)) {\n        // if any textfont param is array - make render a batch\n        optsOut.font = new Array(count);\n        for(i = 0; i < count; i++) {\n            var fonti = optsOut.font[i] = {};\n\n            fonti.size = (\n                Lib.isTypedArray(tfs) ? tfs[i] :\n                isArrayOrTypedArray(tfs) ? (\n                    isNumeric(tfs[i]) ? tfs[i] : 0\n                ) : tfs\n            ) * plotGlPixelRatio;\n\n            fonti.family = isArrayOrTypedArray(tff) ? tff[i] : tff;\n        }\n    } else {\n        // if both are single values, make render fast single-value\n        optsOut.font = {size: tfs * plotGlPixelRatio, family: tff};\n    }\n\n    return optsOut;\n}\n\n\nfunction convertMarkerStyle(gd, trace) {\n    var count = trace._length;\n    var optsIn = trace.marker;\n    var optsOut = {};\n    var i;\n\n    var multiSymbol = isArrayOrTypedArray(optsIn.symbol);\n    var multiAngle = isArrayOrTypedArray(optsIn.angle);\n    var multiColor = isArrayOrTypedArray(optsIn.color);\n    var multiLineColor = isArrayOrTypedArray(optsIn.line.color);\n    var multiOpacity = isArrayOrTypedArray(optsIn.opacity);\n    var multiSize = isArrayOrTypedArray(optsIn.size);\n    var multiLineWidth = isArrayOrTypedArray(optsIn.line.width);\n\n    var isOpen;\n    if(!multiSymbol) isOpen = helpers.isOpenSymbol(optsIn.symbol);\n\n    // prepare colors\n    if(multiSymbol || multiColor || multiLineColor || multiOpacity || multiAngle) {\n        optsOut.symbols = new Array(count);\n        optsOut.angles = new Array(count);\n        optsOut.colors = new Array(count);\n        optsOut.borderColors = new Array(count);\n\n        var symbols = optsIn.symbol;\n        var angles = optsIn.angle;\n        var colors = formatColor(optsIn, optsIn.opacity, count);\n        var borderColors = formatColor(optsIn.line, optsIn.opacity, count);\n\n        if(!isArrayOrTypedArray(borderColors[0])) {\n            var borderColor = borderColors;\n            borderColors = Array(count);\n            for(i = 0; i < count; i++) {\n                borderColors[i] = borderColor;\n            }\n        }\n        if(!isArrayOrTypedArray(colors[0])) {\n            var color = colors;\n            colors = Array(count);\n            for(i = 0; i < count; i++) {\n                colors[i] = color;\n            }\n        }\n        if(!isArrayOrTypedArray(symbols)) {\n            var symbol = symbols;\n            symbols = Array(count);\n            for(i = 0; i < count; i++) {\n                symbols[i] = symbol;\n            }\n        }\n        if(!isArrayOrTypedArray(angles)) {\n            var angle = angles;\n            angles = Array(count);\n            for(i = 0; i < count; i++) {\n                angles[i] = angle;\n            }\n        }\n\n        optsOut.symbols = symbols;\n        optsOut.angles = angles;\n        optsOut.colors = colors;\n        optsOut.borderColors = borderColors;\n\n        for(i = 0; i < count; i++) {\n            if(multiSymbol) {\n                isOpen = helpers.isOpenSymbol(optsIn.symbol[i]);\n            }\n            if(isOpen) {\n                borderColors[i] = colors[i].slice();\n                colors[i] = colors[i].slice();\n                colors[i][3] = 0;\n            }\n        }\n\n        optsOut.opacity = trace.opacity;\n\n        optsOut.markers = new Array(count);\n        for(i = 0; i < count; i++) {\n            optsOut.markers[i] = getSymbolSdf({\n                mx: optsOut.symbols[i],\n                ma: optsOut.angles[i]\n            }, trace);\n        }\n    } else {\n        if(isOpen) {\n            optsOut.color = rgba(optsIn.color, 'uint8');\n            optsOut.color[3] = 0;\n            optsOut.borderColor = rgba(optsIn.color, 'uint8');\n        } else {\n            optsOut.color = rgba(optsIn.color, 'uint8');\n            optsOut.borderColor = rgba(optsIn.line.color, 'uint8');\n        }\n\n        optsOut.opacity = trace.opacity * optsIn.opacity;\n\n        optsOut.marker = getSymbolSdf({\n            mx: optsIn.symbol,\n            ma: optsIn.angle\n        }, trace);\n    }\n\n    // prepare sizes\n    var sizeFactor = 1;\n    var markerSizeFunc = makeBubbleSizeFn(trace, sizeFactor);\n    var s;\n\n    if(multiSize || multiLineWidth) {\n        var sizes = optsOut.sizes = new Array(count);\n        var borderSizes = optsOut.borderSizes = new Array(count);\n        var sizeTotal = 0;\n        var sizeAvg;\n\n        if(multiSize) {\n            for(i = 0; i < count; i++) {\n                sizes[i] = markerSizeFunc(optsIn.size[i]);\n                sizeTotal += sizes[i];\n            }\n            sizeAvg = sizeTotal / count;\n        } else {\n            s = markerSizeFunc(optsIn.size);\n            for(i = 0; i < count; i++) {\n                sizes[i] = s;\n            }\n        }\n\n        // See  https://github.com/plotly/plotly.js/pull/1781#discussion_r121820798\n        if(multiLineWidth) {\n            for(i = 0; i < count; i++) {\n                borderSizes[i] = optsIn.line.width[i];\n            }\n        } else {\n            s = optsIn.line.width;\n            for(i = 0; i < count; i++) {\n                borderSizes[i] = s;\n            }\n        }\n\n        optsOut.sizeAvg = sizeAvg;\n    } else {\n        optsOut.size = markerSizeFunc(optsIn && optsIn.size || 10);\n        optsOut.borderSizes = markerSizeFunc(optsIn.line.width);\n    }\n\n    return optsOut;\n}\n\nfunction convertMarkerSelection(gd, trace, target) {\n    var optsIn = trace.marker;\n    var optsOut = {};\n\n    if(!target) return optsOut;\n\n    if(target.marker && target.marker.symbol) {\n        optsOut = convertMarkerStyle(gd, Lib.extendFlat({}, optsIn, target.marker));\n    } else if(target.marker) {\n        if(target.marker.size) optsOut.size = target.marker.size;\n        if(target.marker.color) optsOut.colors = target.marker.color;\n        if(target.marker.opacity !== undefined) optsOut.opacity = target.marker.opacity;\n    }\n\n    return optsOut;\n}\n\nfunction convertTextSelection(gd, trace, target) {\n    var optsOut = {};\n\n    if(!target) return optsOut;\n\n    if(target.textfont) {\n        var optsIn = {\n            opacity: 1,\n            text: trace.text,\n            texttemplate: trace.texttemplate,\n            textposition: trace.textposition,\n            textfont: Lib.extendFlat({}, trace.textfont)\n        };\n        if(target.textfont) {\n            Lib.extendFlat(optsIn.textfont, target.textfont);\n        }\n        optsOut = convertTextStyle(gd, optsIn);\n    }\n\n    return optsOut;\n}\n\nfunction convertErrorBarStyle(trace, target, plotGlPixelRatio) {\n    var optsOut = {\n        capSize: target.width * 2 * plotGlPixelRatio,\n        lineWidth: target.thickness * plotGlPixelRatio,\n        color: target.color\n    };\n\n    if(target.copy_ystyle) {\n        optsOut = trace.error_y;\n    }\n\n    return optsOut;\n}\n\nvar SYMBOL_SDF_SIZE = constants.SYMBOL_SDF_SIZE;\nvar SYMBOL_SIZE = constants.SYMBOL_SIZE;\nvar SYMBOL_STROKE = constants.SYMBOL_STROKE;\nvar SYMBOL_SDF = {};\nvar SYMBOL_SVG_CIRCLE = Drawing.symbolFuncs[0](SYMBOL_SIZE * 0.05);\n\nfunction getSymbolSdf(d, trace) {\n    var symbol = d.mx;\n    if(symbol === 'circle') return null;\n\n    var symbolPath, symbolSdf;\n    var symbolNumber = Drawing.symbolNumber(symbol);\n    var symbolFunc = Drawing.symbolFuncs[symbolNumber % 100];\n    var symbolNoDot = !!Drawing.symbolNoDot[symbolNumber % 100];\n    var symbolNoFill = !!Drawing.symbolNoFill[symbolNumber % 100];\n\n    var isDot = helpers.isDotSymbol(symbol);\n\n    // until we may handle angles in shader?\n    if(d.ma) symbol += '_' + d.ma;\n\n    // get symbol sdf from cache or generate it\n    if(SYMBOL_SDF[symbol]) return SYMBOL_SDF[symbol];\n\n    var angle = Drawing.getMarkerAngle(d, trace);\n    if(isDot && !symbolNoDot) {\n        symbolPath = symbolFunc(SYMBOL_SIZE * 1.1, angle) + SYMBOL_SVG_CIRCLE;\n    } else {\n        symbolPath = symbolFunc(SYMBOL_SIZE, angle);\n    }\n\n    symbolSdf = svgSdf(symbolPath, {\n        w: SYMBOL_SDF_SIZE,\n        h: SYMBOL_SDF_SIZE,\n        viewBox: [-SYMBOL_SIZE, -SYMBOL_SIZE, SYMBOL_SIZE, SYMBOL_SIZE],\n        stroke: symbolNoFill ? SYMBOL_STROKE : -SYMBOL_STROKE\n    });\n\n    SYMBOL_SDF[symbol] = symbolSdf;\n\n    return symbolSdf || null;\n}\n\nfunction convertLinePositions(gd, trace, positions) {\n    var len = positions.length;\n    var count = len / 2;\n    var linePositions;\n    var i;\n\n    if(subTypes.hasLines(trace) && count) {\n        if(trace.line.shape === 'hv') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n                    linePositions.push(NaN, NaN, NaN, NaN);\n                } else {\n                    linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    if(!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n                        linePositions.push(positions[i * 2 + 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'hvh') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n                    if(!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                    linePositions.push(NaN, NaN);\n                } else {\n                    var midPtX = (positions[i * 2] + positions[i * 2 + 2]) / 2;\n                    linePositions.push(\n                        positions[i * 2],\n                        positions[i * 2 + 1],\n                        midPtX,\n                        positions[i * 2 + 1],\n                        midPtX,\n                        positions[i * 2 + 3]\n                    );\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'vhv') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n                    if(!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                    linePositions.push(NaN, NaN);\n                } else {\n                    var midPtY = (positions[i * 2 + 1] + positions[i * 2 + 3]) / 2;\n                    linePositions.push(\n                        positions[i * 2],\n                        positions[i * 2 + 1],\n                        positions[i * 2],\n                        midPtY,\n                        positions[i * 2 + 2],\n                        midPtY\n                    );\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'vh') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n                    linePositions.push(NaN, NaN, NaN, NaN);\n                } else {\n                    linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    if(!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 3]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else {\n            linePositions = positions;\n        }\n    }\n\n    // If we have data with gaps, we ought to use rect joins\n    // FIXME: get rid of this\n    var hasNaN = false;\n    for(i = 0; i < linePositions.length; i++) {\n        if(isNaN(linePositions[i])) {\n            hasNaN = true;\n            break;\n        }\n    }\n\n    var join = (hasNaN || linePositions.length > constants.TOO_MANY_POINTS) ? 'rect' :\n        subTypes.hasMarkers(trace) ? 'rect' : 'round';\n\n    // fill gaps\n    if(hasNaN && trace.connectgaps) {\n        var lastX = linePositions[0];\n        var lastY = linePositions[1];\n\n        for(i = 0; i < linePositions.length; i += 2) {\n            if(isNaN(linePositions[i]) || isNaN(linePositions[i + 1])) {\n                linePositions[i] = lastX;\n                linePositions[i + 1] = lastY;\n            } else {\n                lastX = linePositions[i];\n                lastY = linePositions[i + 1];\n            }\n        }\n    }\n\n    return {\n        join: join,\n        positions: linePositions\n    };\n}\n\nfunction convertErrorBarPositions(gd, trace, positions, x, y) {\n    var makeComputeError = Registry.getComponentMethod('errorbars', 'makeComputeError');\n    var xa = AxisIDs.getFromId(gd, trace.xaxis, 'x');\n    var ya = AxisIDs.getFromId(gd, trace.yaxis, 'y');\n    var count = positions.length / 2;\n    var out = {};\n\n    function convertOneAxis(coords, ax) {\n        var axLetter = ax._id.charAt(0);\n        var opts = trace['error_' + axLetter];\n\n        if(opts && opts.visible && (ax.type === 'linear' || ax.type === 'log')) {\n            var computeError = makeComputeError(opts);\n            var pOffset = {x: 0, y: 1}[axLetter];\n            var eOffset = {x: [0, 1, 2, 3], y: [2, 3, 0, 1]}[axLetter];\n            var errors = new Float64Array(4 * count);\n            var minShoe = Infinity;\n            var maxHat = -Infinity;\n\n            for(var i = 0, j = 0; i < count; i++, j += 4) {\n                var dc = coords[i];\n\n                if(isNumeric(dc)) {\n                    var dl = positions[i * 2 + pOffset];\n                    var vals = computeError(dc, i);\n                    var lv = vals[0];\n                    var hv = vals[1];\n\n                    if(isNumeric(lv) && isNumeric(hv)) {\n                        var shoe = dc - lv;\n                        var hat = dc + hv;\n\n                        errors[j + eOffset[0]] = dl - ax.c2l(shoe);\n                        errors[j + eOffset[1]] = ax.c2l(hat) - dl;\n                        errors[j + eOffset[2]] = 0;\n                        errors[j + eOffset[3]] = 0;\n\n                        minShoe = Math.min(minShoe, dc - lv);\n                        maxHat = Math.max(maxHat, dc + hv);\n                    }\n                }\n            }\n\n            out[axLetter] = {\n                positions: positions,\n                errors: errors,\n                _bnds: [minShoe, maxHat]\n            };\n        }\n    }\n\n    convertOneAxis(x, xa);\n    convertOneAxis(y, ya);\n    return out;\n}\n\nfunction convertTextPosition(gd, trace, textOpts, markerOpts) {\n    var count = trace._length;\n    var out = {};\n    var i;\n\n    // corresponds to textPointPosition from component.drawing\n    if(subTypes.hasMarkers(trace)) {\n        var fontOpts = textOpts.font;\n        var align = textOpts.align;\n        var baseline = textOpts.baseline;\n        out.offset = new Array(count);\n\n        for(i = 0; i < count; i++) {\n            var ms = markerOpts.sizes ? markerOpts.sizes[i] : markerOpts.size;\n            var fs = isArrayOrTypedArray(fontOpts) ? fontOpts[i].size : fontOpts.size;\n\n            var a = isArrayOrTypedArray(align) ?\n                (align.length > 1 ? align[i] : align[0]) :\n                align;\n            var b = isArrayOrTypedArray(baseline) ?\n                (baseline.length > 1 ? baseline[i] : baseline[0]) :\n                baseline;\n\n            var hSign = TEXTOFFSETSIGN[a];\n            var vSign = TEXTOFFSETSIGN[b];\n            var xPad = ms ? ms / 0.8 + 1 : 0;\n            var yPad = -vSign * xPad - vSign * 0.5;\n            out.offset[i] = [hSign * xPad / fs, yPad / fs];\n        }\n    }\n\n    return out;\n}\n\nmodule.exports = {\n    style: convertStyle,\n\n    markerStyle: convertMarkerStyle,\n    markerSelection: convertMarkerSelection,\n\n    linePositions: convertLinePositions,\n    errorBarPositions: convertErrorBarPositions,\n    textPosition: convertTextPosition\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}