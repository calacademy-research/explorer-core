{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar constants = require('./constants');\nvar helpers = require('./helpers');\nmodule.exports = function calcAutorange(gd) {\n  var fullLayout = gd._fullLayout;\n  var shapeList = Lib.filterVisible(fullLayout.shapes);\n  if (!shapeList.length || !gd._fullData.length) return;\n  for (var i = 0; i < shapeList.length; i++) {\n    var shape = shapeList[i];\n    shape._extremes = {};\n    var ax;\n    var bounds;\n    var xRefType = Axes.getRefType(shape.xref);\n    var yRefType = Axes.getRefType(shape.yref);\n\n    // paper and axis domain referenced shapes don't affect autorange\n    if (shape.xref !== 'paper' && xRefType !== 'domain') {\n      var vx0 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x0;\n      var vx1 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x1;\n      ax = Axes.getFromId(gd, shape.xref);\n      bounds = shapeBounds(ax, vx0, vx1, shape.path, constants.paramIsX);\n      if (bounds) {\n        shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcXPaddingOptions(shape));\n      }\n    }\n    if (shape.yref !== 'paper' && yRefType !== 'domain') {\n      var vy0 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y0;\n      var vy1 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y1;\n      ax = Axes.getFromId(gd, shape.yref);\n      bounds = shapeBounds(ax, vy0, vy1, shape.path, constants.paramIsY);\n      if (bounds) {\n        shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcYPaddingOptions(shape));\n      }\n    }\n  }\n};\nfunction calcXPaddingOptions(shape) {\n  return calcPaddingOptions(shape.line.width, shape.xsizemode, shape.x0, shape.x1, shape.path, false);\n}\nfunction calcYPaddingOptions(shape) {\n  return calcPaddingOptions(shape.line.width, shape.ysizemode, shape.y0, shape.y1, shape.path, true);\n}\nfunction calcPaddingOptions(lineWidth, sizeMode, v0, v1, path, isYAxis) {\n  var ppad = lineWidth / 2;\n  var axisDirectionReverted = isYAxis;\n  if (sizeMode === 'pixel') {\n    var coords = path ? helpers.extractPathCoords(path, isYAxis ? constants.paramIsY : constants.paramIsX) : [v0, v1];\n    var maxValue = Lib.aggNums(Math.max, null, coords);\n    var minValue = Lib.aggNums(Math.min, null, coords);\n    var beforePad = minValue < 0 ? Math.abs(minValue) + ppad : ppad;\n    var afterPad = maxValue > 0 ? maxValue + ppad : ppad;\n    return {\n      ppad: ppad,\n      ppadplus: axisDirectionReverted ? beforePad : afterPad,\n      ppadminus: axisDirectionReverted ? afterPad : beforePad\n    };\n  } else {\n    return {\n      ppad: ppad\n    };\n  }\n}\nfunction shapeBounds(ax, v0, v1, path, paramsToUse) {\n  var convertVal = ax.type === 'category' || ax.type === 'multicategory' ? ax.r2c : ax.d2c;\n  if (v0 !== undefined) return [convertVal(v0), convertVal(v1)];\n  if (!path) return;\n  var min = Infinity;\n  var max = -Infinity;\n  var segments = path.match(constants.segmentRE);\n  var i;\n  var segment;\n  var drawnParam;\n  var params;\n  var val;\n  if (ax.type === 'date') convertVal = helpers.decodeDate(convertVal);\n  for (i = 0; i < segments.length; i++) {\n    segment = segments[i];\n    drawnParam = paramsToUse[segment.charAt(0)].drawn;\n    if (drawnParam === undefined) continue;\n    params = segments[i].substr(1).match(constants.paramRE);\n    if (!params || params.length < drawnParam) continue;\n    val = convertVal(params[drawnParam]);\n    if (val < min) min = val;\n    if (val > max) max = val;\n  }\n  if (max >= min) return [min, max];\n}","map":{"version":3,"names":["Lib","require","Axes","constants","helpers","module","exports","calcAutorange","gd","fullLayout","_fullLayout","shapeList","filterVisible","shapes","length","_fullData","i","shape","_extremes","ax","bounds","xRefType","getRefType","xref","yRefType","yref","vx0","xsizemode","xanchor","x0","vx1","x1","getFromId","shapeBounds","path","paramIsX","_id","findExtremes","calcXPaddingOptions","vy0","ysizemode","yanchor","y0","vy1","y1","paramIsY","calcYPaddingOptions","calcPaddingOptions","line","width","lineWidth","sizeMode","v0","v1","isYAxis","ppad","axisDirectionReverted","coords","extractPathCoords","maxValue","aggNums","Math","max","minValue","min","beforePad","abs","afterPad","ppadplus","ppadminus","paramsToUse","convertVal","type","r2c","d2c","undefined","Infinity","segments","match","segmentRE","segment","drawnParam","params","val","decodeDate","charAt","drawn","substr","paramRE"],"sources":["/home/zhu/Documents/github/explorer_front/explorer_front_app/node_modules/plotly.js/src/components/shapes/calc_autorange.js"],"sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar constants = require('./constants');\nvar helpers = require('./helpers');\n\n\nmodule.exports = function calcAutorange(gd) {\n    var fullLayout = gd._fullLayout;\n    var shapeList = Lib.filterVisible(fullLayout.shapes);\n\n    if(!shapeList.length || !gd._fullData.length) return;\n\n    for(var i = 0; i < shapeList.length; i++) {\n        var shape = shapeList[i];\n        shape._extremes = {};\n\n        var ax; var bounds;\n        var xRefType = Axes.getRefType(shape.xref);\n        var yRefType = Axes.getRefType(shape.yref);\n\n        // paper and axis domain referenced shapes don't affect autorange\n        if(shape.xref !== 'paper' && xRefType !== 'domain') {\n            var vx0 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x0;\n            var vx1 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x1;\n            ax = Axes.getFromId(gd, shape.xref);\n\n            bounds = shapeBounds(ax, vx0, vx1, shape.path, constants.paramIsX);\n            if(bounds) {\n                shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcXPaddingOptions(shape));\n            }\n        }\n\n        if(shape.yref !== 'paper' && yRefType !== 'domain') {\n            var vy0 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y0;\n            var vy1 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y1;\n            ax = Axes.getFromId(gd, shape.yref);\n\n            bounds = shapeBounds(ax, vy0, vy1, shape.path, constants.paramIsY);\n            if(bounds) {\n                shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcYPaddingOptions(shape));\n            }\n        }\n    }\n};\n\nfunction calcXPaddingOptions(shape) {\n    return calcPaddingOptions(shape.line.width, shape.xsizemode, shape.x0, shape.x1, shape.path, false);\n}\n\nfunction calcYPaddingOptions(shape) {\n    return calcPaddingOptions(shape.line.width, shape.ysizemode, shape.y0, shape.y1, shape.path, true);\n}\n\nfunction calcPaddingOptions(lineWidth, sizeMode, v0, v1, path, isYAxis) {\n    var ppad = lineWidth / 2;\n    var axisDirectionReverted = isYAxis;\n\n    if(sizeMode === 'pixel') {\n        var coords = path ?\n            helpers.extractPathCoords(path, isYAxis ? constants.paramIsY : constants.paramIsX) :\n            [v0, v1];\n        var maxValue = Lib.aggNums(Math.max, null, coords);\n        var minValue = Lib.aggNums(Math.min, null, coords);\n        var beforePad = minValue < 0 ? Math.abs(minValue) + ppad : ppad;\n        var afterPad = maxValue > 0 ? maxValue + ppad : ppad;\n\n        return {\n            ppad: ppad,\n            ppadplus: axisDirectionReverted ? beforePad : afterPad,\n            ppadminus: axisDirectionReverted ? afterPad : beforePad\n        };\n    } else {\n        return {ppad: ppad};\n    }\n}\n\nfunction shapeBounds(ax, v0, v1, path, paramsToUse) {\n    var convertVal = (ax.type === 'category' || ax.type === 'multicategory') ? ax.r2c : ax.d2c;\n\n    if(v0 !== undefined) return [convertVal(v0), convertVal(v1)];\n    if(!path) return;\n\n    var min = Infinity;\n    var max = -Infinity;\n    var segments = path.match(constants.segmentRE);\n    var i;\n    var segment;\n    var drawnParam;\n    var params;\n    var val;\n\n    if(ax.type === 'date') convertVal = helpers.decodeDate(convertVal);\n\n    for(i = 0; i < segments.length; i++) {\n        segment = segments[i];\n        drawnParam = paramsToUse[segment.charAt(0)].drawn;\n        if(drawnParam === undefined) continue;\n\n        params = segments[i].substr(1).match(constants.paramRE);\n        if(!params || params.length < drawnParam) continue;\n\n        val = convertVal(params[drawnParam]);\n        if(val < min) min = val;\n        if(val > max) max = val;\n    }\n    if(max >= min) return [min, max];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}