{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar numberFormat = Lib.numberFormat;\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\nvar Registry = require('../../registry');\nvar Color = require('../color');\nvar Colorscale = require('../colorscale');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nvar alignment = require('../../constants/alignment');\nvar LINE_SPACING = alignment.LINE_SPACING;\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\nvar subTypes = require('../../traces/scatter/subtypes');\nvar makeBubbleSizeFn = require('../../traces/scatter/make_bubble_size_func');\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\nvar drawing = module.exports = {};\n\n// -----------------------------------------------------\n// styling functions for plot elements\n// -----------------------------------------------------\n\ndrawing.font = function (s, family, size, color) {\n  // also allow the form font(s, {family, size, color})\n  if (Lib.isPlainObject(family)) {\n    color = family.color;\n    size = family.size;\n    family = family.family;\n  }\n  if (family) s.style('font-family', family);\n  if (size + 1) s.style('font-size', size + 'px');\n  if (color) s.call(Color.fill, color);\n};\n\n/*\n * Positioning helpers\n * Note: do not use `setPosition` with <text> nodes modified by\n * `svgTextUtils.convertToTspans`. Use `svgTextUtils.positionText`\n * instead, so that <tspan.line> elements get updated to match.\n */\ndrawing.setPosition = function (s, x, y) {\n  s.attr('x', x).attr('y', y);\n};\ndrawing.setSize = function (s, w, h) {\n  s.attr('width', w).attr('height', h);\n};\ndrawing.setRect = function (s, x, y, w, h) {\n  s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);\n};\n\n/** Translate node\n *\n * @param {object} d : calcdata point item\n * @param {sel} sel : d3 selction of node to translate\n * @param {object} xa : corresponding full xaxis object\n * @param {object} ya : corresponding full yaxis object\n *\n * @return {boolean} :\n *  true if selection got translated\n *  false if selection could not get translated\n */\ndrawing.translatePoint = function (d, sel, xa, ya) {\n  var x = xa.c2p(d.x);\n  var y = ya.c2p(d.y);\n  if (isNumeric(x) && isNumeric(y) && sel.node()) {\n    // for multiline text this works better\n    if (sel.node().nodeName === 'text') {\n      sel.attr('x', x).attr('y', y);\n    } else {\n      sel.attr('transform', strTranslate(x, y));\n    }\n  } else {\n    return false;\n  }\n  return true;\n};\ndrawing.translatePoints = function (s, xa, ya) {\n  s.each(function (d) {\n    var sel = d3.select(this);\n    drawing.translatePoint(d, sel, xa, ya);\n  });\n};\ndrawing.hideOutsideRangePoint = function (d, sel, xa, ya, xcalendar, ycalendar) {\n  sel.attr('display', xa.isPtWithinRange(d, xcalendar) && ya.isPtWithinRange(d, ycalendar) ? null : 'none');\n};\ndrawing.hideOutsideRangePoints = function (traceGroups, subplot) {\n  if (!subplot._hasClipOnAxisFalse) return;\n  var xa = subplot.xaxis;\n  var ya = subplot.yaxis;\n  traceGroups.each(function (d) {\n    var trace = d[0].trace;\n    var xcalendar = trace.xcalendar;\n    var ycalendar = trace.ycalendar;\n    var selector = Registry.traceIs(trace, 'bar-like') ? '.bartext' : '.point,.textpoint';\n    traceGroups.selectAll(selector).each(function (d) {\n      drawing.hideOutsideRangePoint(d, d3.select(this), xa, ya, xcalendar, ycalendar);\n    });\n  });\n};\ndrawing.crispRound = function (gd, lineWidth, dflt) {\n  // for lines that disable antialiasing we want to\n  // make sure the width is an integer, and at least 1 if it's nonzero\n\n  if (!lineWidth || !isNumeric(lineWidth)) return dflt || 0;\n\n  // but not for static plots - these don't get antialiased anyway.\n  if (gd._context.staticPlot) return lineWidth;\n  if (lineWidth < 1) return 1;\n  return Math.round(lineWidth);\n};\ndrawing.singleLineStyle = function (d, s, lw, lc, ld) {\n  s.style('fill', 'none');\n  var line = (((d || [])[0] || {}).trace || {}).line || {};\n  var lw1 = lw || line.width || 0;\n  var dash = ld || line.dash || '';\n  Color.stroke(s, lc || line.color);\n  drawing.dashLine(s, dash, lw1);\n};\ndrawing.lineGroupStyle = function (s, lw, lc, ld) {\n  s.style('fill', 'none').each(function (d) {\n    var line = (((d || [])[0] || {}).trace || {}).line || {};\n    var lw1 = lw || line.width || 0;\n    var dash = ld || line.dash || '';\n    d3.select(this).call(Color.stroke, lc || line.color).call(drawing.dashLine, dash, lw1);\n  });\n};\ndrawing.dashLine = function (s, dash, lineWidth) {\n  lineWidth = +lineWidth || 0;\n  dash = drawing.dashStyle(dash, lineWidth);\n  s.style({\n    'stroke-dasharray': dash,\n    'stroke-width': lineWidth + 'px'\n  });\n};\ndrawing.dashStyle = function (dash, lineWidth) {\n  lineWidth = +lineWidth || 1;\n  var dlw = Math.max(lineWidth, 3);\n  if (dash === 'solid') dash = '';else if (dash === 'dot') dash = dlw + 'px,' + dlw + 'px';else if (dash === 'dash') dash = 3 * dlw + 'px,' + 3 * dlw + 'px';else if (dash === 'longdash') dash = 5 * dlw + 'px,' + 5 * dlw + 'px';else if (dash === 'dashdot') {\n    dash = 3 * dlw + 'px,' + dlw + 'px,' + dlw + 'px,' + dlw + 'px';\n  } else if (dash === 'longdashdot') {\n    dash = 5 * dlw + 'px,' + 2 * dlw + 'px,' + dlw + 'px,' + 2 * dlw + 'px';\n  }\n  // otherwise user wrote the dasharray themselves - leave it be\n\n  return dash;\n};\nfunction setFillStyle(sel, trace, gd, forLegend) {\n  var markerPattern = trace.fillpattern;\n  var fillgradient = trace.fillgradient;\n  var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, 0, '');\n  if (patternShape) {\n    var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, 0, null);\n    var patternFGColor = drawing.getPatternAttr(markerPattern.fgcolor, 0, null);\n    var patternFGOpacity = markerPattern.fgopacity;\n    var patternSize = drawing.getPatternAttr(markerPattern.size, 0, 8);\n    var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, 0, 0.3);\n    var patternID = trace.uid;\n    drawing.pattern(sel, 'point', gd, patternID, patternShape, patternSize, patternSolidity, undefined, markerPattern.fillmode, patternBGColor, patternFGColor, patternFGOpacity);\n  } else if (fillgradient && fillgradient.type !== 'none') {\n    var direction = fillgradient.type;\n    var gradientID = 'scatterfill-' + trace.uid;\n    if (forLegend) {\n      gradientID = 'legendfill-' + trace.uid;\n    }\n    if (!forLegend && (fillgradient.start !== undefined || fillgradient.stop !== undefined)) {\n      var start, stop;\n      if (direction === 'horizontal') {\n        start = {\n          x: fillgradient.start,\n          y: 0\n        };\n        stop = {\n          x: fillgradient.stop,\n          y: 0\n        };\n      } else if (direction === 'vertical') {\n        start = {\n          x: 0,\n          y: fillgradient.start\n        };\n        stop = {\n          x: 0,\n          y: fillgradient.stop\n        };\n      }\n      start.x = trace._xA.c2p(start.x === undefined ? trace._extremes.x.min[0].val : start.x, true);\n      start.y = trace._yA.c2p(start.y === undefined ? trace._extremes.y.min[0].val : start.y, true);\n      stop.x = trace._xA.c2p(stop.x === undefined ? trace._extremes.x.max[0].val : stop.x, true);\n      stop.y = trace._yA.c2p(stop.y === undefined ? trace._extremes.y.max[0].val : stop.y, true);\n      sel.call(gradientWithBounds, gd, gradientID, 'linear', fillgradient.colorscale, 'fill', start, stop, true, false);\n    } else {\n      if (direction === 'horizontal') {\n        direction = direction + 'reversed';\n      }\n      sel.call(drawing.gradient, gd, gradientID, direction, fillgradient.colorscale, 'fill');\n    }\n  } else if (trace.fillcolor) {\n    sel.call(Color.fill, trace.fillcolor);\n  }\n}\n\n// Same as fillGroupStyle, except in this case the selection may be a transition\ndrawing.singleFillStyle = function (sel, gd) {\n  var node = d3.select(sel.node());\n  var data = node.data();\n  var trace = ((data[0] || [])[0] || {}).trace || {};\n  setFillStyle(sel, trace, gd, false);\n};\ndrawing.fillGroupStyle = function (s, gd, forLegend) {\n  s.style('stroke-width', 0).each(function (d) {\n    var shape = d3.select(this);\n    // N.B. 'd' won't be a calcdata item when\n    // fill !== 'none' on a segment-less and marker-less trace\n    if (d[0].trace) {\n      setFillStyle(shape, d[0].trace, gd, forLegend);\n    }\n  });\n};\nvar SYMBOLDEFS = require('./symbol_defs');\ndrawing.symbolNames = [];\ndrawing.symbolFuncs = [];\ndrawing.symbolBackOffs = [];\ndrawing.symbolNeedLines = {};\ndrawing.symbolNoDot = {};\ndrawing.symbolNoFill = {};\ndrawing.symbolList = [];\nObject.keys(SYMBOLDEFS).forEach(function (k) {\n  var symDef = SYMBOLDEFS[k];\n  var n = symDef.n;\n  drawing.symbolList.push(n, String(n), k, n + 100, String(n + 100), k + '-open');\n  drawing.symbolNames[n] = k;\n  drawing.symbolFuncs[n] = symDef.f;\n  drawing.symbolBackOffs[n] = symDef.backoff || 0;\n  if (symDef.needLine) {\n    drawing.symbolNeedLines[n] = true;\n  }\n  if (symDef.noDot) {\n    drawing.symbolNoDot[n] = true;\n  } else {\n    drawing.symbolList.push(n + 200, String(n + 200), k + '-dot', n + 300, String(n + 300), k + '-open-dot');\n  }\n  if (symDef.noFill) {\n    drawing.symbolNoFill[n] = true;\n  }\n});\nvar MAXSYMBOL = drawing.symbolNames.length;\n// add a dot in the middle of the symbol\nvar DOTPATH = 'M0,0.5L0.5,0L0,-0.5L-0.5,0Z';\ndrawing.symbolNumber = function (v) {\n  if (isNumeric(v)) {\n    v = +v;\n  } else if (typeof v === 'string') {\n    var vbase = 0;\n    if (v.indexOf('-open') > 0) {\n      vbase = 100;\n      v = v.replace('-open', '');\n    }\n    if (v.indexOf('-dot') > 0) {\n      vbase += 200;\n      v = v.replace('-dot', '');\n    }\n    v = drawing.symbolNames.indexOf(v);\n    if (v >= 0) {\n      v += vbase;\n    }\n  }\n  return v % 100 >= MAXSYMBOL || v >= 400 ? 0 : Math.floor(Math.max(v, 0));\n};\nfunction makePointPath(symbolNumber, r, t, s) {\n  var base = symbolNumber % 100;\n  return drawing.symbolFuncs[base](r, t, s) + (symbolNumber >= 200 ? DOTPATH : '');\n}\nvar stopFormatter = numberFormat('~f');\nvar gradientInfo = {\n  radial: {\n    type: 'radial'\n  },\n  radialreversed: {\n    type: 'radial',\n    reversed: true\n  },\n  horizontal: {\n    type: 'linear',\n    start: {\n      x: 1,\n      y: 0\n    },\n    stop: {\n      x: 0,\n      y: 0\n    }\n  },\n  horizontalreversed: {\n    type: 'linear',\n    start: {\n      x: 1,\n      y: 0\n    },\n    stop: {\n      x: 0,\n      y: 0\n    },\n    reversed: true\n  },\n  vertical: {\n    type: 'linear',\n    start: {\n      x: 0,\n      y: 1\n    },\n    stop: {\n      x: 0,\n      y: 0\n    }\n  },\n  verticalreversed: {\n    type: 'linear',\n    start: {\n      x: 0,\n      y: 1\n    },\n    stop: {\n      x: 0,\n      y: 0\n    },\n    reversed: true\n  }\n};\n\n/**\n * gradient: create and apply a gradient fill\n *\n * @param {object} sel: d3 selection to apply this gradient to\n *     You can use `selection.call(Drawing.gradient, ...)`\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} gradientID: a unique (within this plot) identifier\n *     for this gradient, so that we don't create unnecessary definitions\n * @param {string} type: 'radial', 'horizontal', or 'vertical', optionally with\n *     'reversed' at the end. Normally radial goes center to edge,\n *     horizontal goes right to left, and vertical goes bottom to top\n * @param {array} colorscale: as in attribute values, [[fraction, color], ...]\n * @param {string} prop: the property to apply to, 'fill' or 'stroke'\n */\ndrawing.gradient = function (sel, gd, gradientID, type, colorscale, prop) {\n  var info = gradientInfo[type];\n  return gradientWithBounds(sel, gd, gradientID, info.type, colorscale, prop, info.start, info.stop, false, info.reversed);\n};\n\n/**\n * gradient_with_bounds: create and apply a gradient fill for defined start and stop positions\n *\n * @param {object} sel: d3 selection to apply this gradient to\n *     You can use `selection.call(Drawing.gradient, ...)`\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} gradientID: a unique (within this plot) identifier\n *     for this gradient, so that we don't create unnecessary definitions\n * @param {string} type: 'radial' or 'linear'. Radial goes center to edge,\n *     horizontal goes as defined by start and stop\n * @param {array} colorscale: as in attribute values, [[fraction, color], ...]\n * @param {string} prop: the property to apply to, 'fill' or 'stroke'\n * @param {object} start: start point for linear gradients, { x: number, y: number }.\n *     Ignored if type is 'radial'.\n * @param {object} stop: stop point for linear gradients, { x: number, y: number }.\n *     Ignored if type is 'radial'.\n * @param {boolean} inUserSpace: If true, start and stop give absolute values in the plot.\n *     If false, start and stop are fractions of the traces extent along each axis.\n * @param {boolean} reversed: If true, the gradient is reversed between normal start and stop,\n *     i.e., the colorscale is applied in order from stop to start for linear, from edge\n *     to center for radial gradients.\n */\nfunction gradientWithBounds(sel, gd, gradientID, type, colorscale, prop, start, stop, inUserSpace, reversed) {\n  var len = colorscale.length;\n  var info;\n  if (type === 'linear') {\n    info = {\n      node: 'linearGradient',\n      attrs: {\n        x1: start.x,\n        y1: start.y,\n        x2: stop.x,\n        y2: stop.y,\n        gradientUnits: inUserSpace ? 'userSpaceOnUse' : 'objectBoundingBox'\n      },\n      reversed: reversed\n    };\n  } else if (type === 'radial') {\n    info = {\n      node: 'radialGradient',\n      reversed: reversed\n    };\n  }\n  var colorStops = new Array(len);\n  for (var i = 0; i < len; i++) {\n    if (info.reversed) {\n      colorStops[len - 1 - i] = [stopFormatter((1 - colorscale[i][0]) * 100), colorscale[i][1]];\n    } else {\n      colorStops[i] = [stopFormatter(colorscale[i][0] * 100), colorscale[i][1]];\n    }\n  }\n  var fullLayout = gd._fullLayout;\n  var fullID = 'g' + fullLayout._uid + '-' + gradientID;\n  var gradient = fullLayout._defs.select('.gradients').selectAll('#' + fullID).data([type + colorStops.join(';')], Lib.identity);\n  gradient.exit().remove();\n  gradient.enter().append(info.node).each(function () {\n    var el = d3.select(this);\n    if (info.attrs) el.attr(info.attrs);\n    el.attr('id', fullID);\n    var stops = el.selectAll('stop').data(colorStops);\n    stops.exit().remove();\n    stops.enter().append('stop');\n    stops.each(function (d) {\n      var tc = tinycolor(d[1]);\n      d3.select(this).attr({\n        offset: d[0] + '%',\n        'stop-color': Color.tinyRGB(tc),\n        'stop-opacity': tc.getAlpha()\n      });\n    });\n  });\n  sel.style(prop, getFullUrl(fullID, gd)).style(prop + '-opacity', null);\n  sel.classed('gradient_filled', true);\n}\n\n/**\n * pattern: create and apply a pattern fill\n *\n * @param {object} sel: d3 selection to apply this pattern to\n *     You can use `selection.call(Drawing.pattern, ...)`\n * @param {string} calledBy: option to know the caller component\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} patternID: a unique (within this plot) identifier\n *     for this pattern, so that we don't create unnecessary definitions\n * @param {number} size: size of unit squares for repetition of this pattern\n * @param {number} solidity: how solid lines of this pattern are\n * @param {string} mcc: color when painted with colorscale\n * @param {string} fillmode: fillmode for this pattern\n * @param {string} bgcolor: background color for this pattern\n * @param {string} fgcolor: foreground color for this pattern\n * @param {number} fgopacity: foreground opacity for this pattern\n */\ndrawing.pattern = function (sel, calledBy, gd, patternID, shape, size, solidity, mcc, fillmode, bgcolor, fgcolor, fgopacity) {\n  var isLegend = calledBy === 'legend';\n  if (mcc) {\n    if (fillmode === 'overlay') {\n      bgcolor = mcc;\n      fgcolor = Color.contrast(bgcolor);\n    } else {\n      bgcolor = undefined;\n      fgcolor = mcc;\n    }\n  }\n  var fullLayout = gd._fullLayout;\n  var fullID = 'p' + fullLayout._uid + '-' + patternID;\n  var width, height;\n\n  // linear interpolation\n  var linearFn = function (x, x0, x1, y0, y1) {\n    return y0 + (y1 - y0) * (x - x0) / (x1 - x0);\n  };\n  var path, linewidth, radius;\n  var patternTag;\n  var patternAttrs = {};\n  var fgC = tinycolor(fgcolor);\n  var fgRGB = Color.tinyRGB(fgC);\n  var fgAlpha = fgC.getAlpha();\n  var opacity = fgopacity * fgAlpha;\n  switch (shape) {\n    case '/':\n      width = size * Math.sqrt(2);\n      height = size * Math.sqrt(2);\n      path = 'M-' + width / 4 + ',' + height / 4 + 'l' + width / 2 + ',-' + height / 2 + 'M0,' + height + 'L' + width + ',0' + 'M' + width / 4 * 3 + ',' + height / 4 * 5 + 'l' + width / 2 + ',-' + height / 2;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '\\\\':\n      width = size * Math.sqrt(2);\n      height = size * Math.sqrt(2);\n      path = 'M' + width / 4 * 3 + ',-' + height / 4 + 'l' + width / 2 + ',' + height / 2 + 'M0,0L' + width + ',' + height + 'M-' + width / 4 + ',' + height / 4 * 3 + 'l' + width / 2 + ',' + height / 2;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case 'x':\n      width = size * Math.sqrt(2);\n      height = size * Math.sqrt(2);\n      path = 'M-' + width / 4 + ',' + height / 4 + 'l' + width / 2 + ',-' + height / 2 + 'M0,' + height + 'L' + width + ',0' + 'M' + width / 4 * 3 + ',' + height / 4 * 5 + 'l' + width / 2 + ',-' + height / 2 + 'M' + width / 4 * 3 + ',-' + height / 4 + 'l' + width / 2 + ',' + height / 2 + 'M0,0L' + width + ',' + height + 'M-' + width / 4 + ',' + height / 4 * 3 + 'l' + width / 2 + ',' + height / 2;\n      linewidth = size - size * Math.sqrt(1.0 - solidity);\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '|':\n      width = size;\n      height = size;\n      patternTag = 'path';\n      path = 'M' + width / 2 + ',0L' + width / 2 + ',' + height;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '-':\n      width = size;\n      height = size;\n      patternTag = 'path';\n      path = 'M0,' + height / 2 + 'L' + width + ',' + height / 2;\n      linewidth = solidity * size;\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '+':\n      width = size;\n      height = size;\n      patternTag = 'path';\n      path = 'M' + width / 2 + ',0L' + width / 2 + ',' + height + 'M0,' + height / 2 + 'L' + width + ',' + height / 2;\n      linewidth = size - size * Math.sqrt(1.0 - solidity);\n      patternTag = 'path';\n      patternAttrs = {\n        d: path,\n        opacity: opacity,\n        stroke: fgRGB,\n        'stroke-width': linewidth + 'px'\n      };\n      break;\n    case '.':\n      width = size;\n      height = size;\n      if (solidity < Math.PI / 4) {\n        radius = Math.sqrt(solidity * size * size / Math.PI);\n      } else {\n        radius = linearFn(solidity, Math.PI / 4, 1.0, size / 2, size / Math.sqrt(2));\n      }\n      patternTag = 'circle';\n      patternAttrs = {\n        cx: width / 2,\n        cy: height / 2,\n        r: radius,\n        opacity: opacity,\n        fill: fgRGB\n      };\n      break;\n  }\n  var str = [shape || 'noSh', bgcolor || 'noBg', fgcolor || 'noFg', size, solidity].join(';');\n  var pattern = fullLayout._defs.select('.patterns').selectAll('#' + fullID).data([str], Lib.identity);\n  pattern.exit().remove();\n  pattern.enter().append('pattern').each(function () {\n    var el = d3.select(this);\n    el.attr({\n      id: fullID,\n      width: width + 'px',\n      height: height + 'px',\n      patternUnits: 'userSpaceOnUse',\n      // for legends scale down patterns just a bit so that default size (i.e 8) nicely fit in small icons\n      patternTransform: isLegend ? 'scale(0.8)' : ''\n    });\n    if (bgcolor) {\n      var bgC = tinycolor(bgcolor);\n      var bgRGB = Color.tinyRGB(bgC);\n      var bgAlpha = bgC.getAlpha();\n      var rects = el.selectAll('rect').data([0]);\n      rects.exit().remove();\n      rects.enter().append('rect').attr({\n        width: width + 'px',\n        height: height + 'px',\n        fill: bgRGB,\n        'fill-opacity': bgAlpha\n      });\n    }\n    var patterns = el.selectAll(patternTag).data([0]);\n    patterns.exit().remove();\n    patterns.enter().append(patternTag).attr(patternAttrs);\n  });\n  sel.style('fill', getFullUrl(fullID, gd)).style('fill-opacity', null);\n  sel.classed('pattern_filled', true);\n};\n\n/*\n * Make the gradients container and clear out any previous gradients.\n * We never collect all the gradients we need in one place,\n * so we can't ever remove gradients that have stopped being useful,\n * except all at once before a full redraw.\n * The upside of this is arbitrary points can share gradient defs\n */\ndrawing.initGradients = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var gradientsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'gradients');\n  gradientsGroup.selectAll('linearGradient,radialGradient').remove();\n  d3.select(gd).selectAll('.gradient_filled').classed('gradient_filled', false);\n};\ndrawing.initPatterns = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var patternsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'patterns');\n  patternsGroup.selectAll('pattern').remove();\n  d3.select(gd).selectAll('.pattern_filled').classed('pattern_filled', false);\n};\ndrawing.getPatternAttr = function (mp, i, dflt) {\n  if (mp && Lib.isArrayOrTypedArray(mp)) {\n    return i < mp.length ? mp[i] : dflt;\n  }\n  return mp;\n};\ndrawing.pointStyle = function (s, trace, gd, pt) {\n  if (!s.size()) return;\n  var fns = drawing.makePointStyleFns(trace);\n  s.each(function (d) {\n    drawing.singlePointStyle(d, d3.select(this), trace, fns, gd, pt);\n  });\n};\ndrawing.singlePointStyle = function (d, sel, trace, fns, gd, pt) {\n  var marker = trace.marker;\n  var markerLine = marker.line;\n  if (pt && pt.i >= 0 && d.i === undefined) d.i = pt.i;\n  sel.style('opacity', fns.selectedOpacityFn ? fns.selectedOpacityFn(d) : d.mo === undefined ? marker.opacity : d.mo);\n  if (fns.ms2mrc) {\n    var r;\n\n    // handle multi-trace graph edit case\n    if (d.ms === 'various' || marker.size === 'various') {\n      r = 3;\n    } else {\n      r = fns.ms2mrc(d.ms);\n    }\n\n    // store the calculated size so hover can use it\n    d.mrc = r;\n    if (fns.selectedSizeFn) {\n      r = d.mrc = fns.selectedSizeFn(d);\n    }\n\n    // turn the symbol into a sanitized number\n    var x = drawing.symbolNumber(d.mx || marker.symbol) || 0;\n\n    // save if this marker is open\n    // because that impacts how to handle colors\n    d.om = x % 200 >= 100;\n    var angle = getMarkerAngle(d, trace);\n    var standoff = getMarkerStandoff(d, trace);\n    sel.attr('d', makePointPath(x, r, angle, standoff));\n  }\n  var perPointGradient = false;\n  var fillColor, lineColor, lineWidth;\n\n  // 'so' is suspected outliers, for box plots\n  if (d.so) {\n    lineWidth = markerLine.outlierwidth;\n    lineColor = markerLine.outliercolor;\n    fillColor = marker.outliercolor;\n  } else {\n    var markerLineWidth = (markerLine || {}).width;\n    lineWidth = (d.mlw + 1 || markerLineWidth + 1 ||\n    // TODO: we need the latter for legends... can we get rid of it?\n    (d.trace ? (d.trace.marker.line || {}).width : 0) + 1) - 1 || 0;\n    if ('mlc' in d) lineColor = d.mlcc = fns.lineScale(d.mlc);\n    // weird case: array wasn't long enough to apply to every point\n    else if (Lib.isArrayOrTypedArray(markerLine.color)) lineColor = Color.defaultLine;else lineColor = markerLine.color;\n    if (Lib.isArrayOrTypedArray(marker.color)) {\n      fillColor = Color.defaultLine;\n      perPointGradient = true;\n    }\n    if ('mc' in d) {\n      fillColor = d.mcc = fns.markerScale(d.mc);\n    } else {\n      fillColor = marker.color || marker.colors || 'rgba(0,0,0,0)';\n    }\n    if (fns.selectedColorFn) {\n      fillColor = fns.selectedColorFn(d);\n    }\n  }\n  if (d.om) {\n    // open markers can't have zero linewidth, default to 1px,\n    // and use fill color as stroke color\n    sel.call(Color.stroke, fillColor).style({\n      'stroke-width': (lineWidth || 1) + 'px',\n      fill: 'none'\n    });\n  } else {\n    sel.style('stroke-width', (d.isBlank ? 0 : lineWidth) + 'px');\n    var markerGradient = marker.gradient;\n    var gradientType = d.mgt;\n    if (gradientType) perPointGradient = true;else gradientType = markerGradient && markerGradient.type;\n\n    // for legend - arrays will propagate through here, but we don't need\n    // to treat it as per-point.\n    if (Lib.isArrayOrTypedArray(gradientType)) {\n      gradientType = gradientType[0];\n      if (!gradientInfo[gradientType]) gradientType = 0;\n    }\n    var markerPattern = marker.pattern;\n    var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, d.i, '');\n    if (gradientType && gradientType !== 'none') {\n      var gradientColor = d.mgc;\n      if (gradientColor) perPointGradient = true;else gradientColor = markerGradient.color;\n      var gradientID = trace.uid;\n      if (perPointGradient) gradientID += '-' + d.i;\n      drawing.gradient(sel, gd, gradientID, gradientType, [[0, gradientColor], [1, fillColor]], 'fill');\n    } else if (patternShape) {\n      var perPointPattern = false;\n      var fgcolor = markerPattern.fgcolor;\n      if (!fgcolor && pt && pt.color) {\n        fgcolor = pt.color;\n        perPointPattern = true;\n      }\n      var patternFGColor = drawing.getPatternAttr(fgcolor, d.i, pt && pt.color || null);\n      var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, d.i, null);\n      var patternFGOpacity = markerPattern.fgopacity;\n      var patternSize = drawing.getPatternAttr(markerPattern.size, d.i, 8);\n      var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, d.i, 0.3);\n      perPointPattern = perPointPattern || d.mcc || Lib.isArrayOrTypedArray(markerPattern.shape) || Lib.isArrayOrTypedArray(markerPattern.bgcolor) || Lib.isArrayOrTypedArray(markerPattern.fgcolor) || Lib.isArrayOrTypedArray(markerPattern.size) || Lib.isArrayOrTypedArray(markerPattern.solidity);\n      var patternID = trace.uid;\n      if (perPointPattern) patternID += '-' + d.i;\n      drawing.pattern(sel, 'point', gd, patternID, patternShape, patternSize, patternSolidity, d.mcc, markerPattern.fillmode, patternBGColor, patternFGColor, patternFGOpacity);\n    } else {\n      Lib.isArrayOrTypedArray(fillColor) ? Color.fill(sel, fillColor[d.i]) : Color.fill(sel, fillColor);\n    }\n    if (lineWidth) {\n      Color.stroke(sel, lineColor);\n    }\n  }\n};\ndrawing.makePointStyleFns = function (trace) {\n  var out = {};\n  var marker = trace.marker;\n\n  // allow array marker and marker line colors to be\n  // scaled by given max and min to colorscales\n  out.markerScale = drawing.tryColorscale(marker, '');\n  out.lineScale = drawing.tryColorscale(marker, 'line');\n  if (Registry.traceIs(trace, 'symbols')) {\n    out.ms2mrc = subTypes.isBubble(trace) ? makeBubbleSizeFn(trace) : function () {\n      return (marker.size || 6) / 2;\n    };\n  }\n  if (trace.selectedpoints) {\n    Lib.extendFlat(out, drawing.makeSelectedPointStyleFns(trace));\n  }\n  return out;\n};\ndrawing.makeSelectedPointStyleFns = function (trace) {\n  var out = {};\n  var selectedAttrs = trace.selected || {};\n  var unselectedAttrs = trace.unselected || {};\n  var marker = trace.marker || {};\n  var selectedMarker = selectedAttrs.marker || {};\n  var unselectedMarker = unselectedAttrs.marker || {};\n  var mo = marker.opacity;\n  var smo = selectedMarker.opacity;\n  var usmo = unselectedMarker.opacity;\n  var smoIsDefined = smo !== undefined;\n  var usmoIsDefined = usmo !== undefined;\n  if (Lib.isArrayOrTypedArray(mo) || smoIsDefined || usmoIsDefined) {\n    out.selectedOpacityFn = function (d) {\n      var base = d.mo === undefined ? marker.opacity : d.mo;\n      if (d.selected) {\n        return smoIsDefined ? smo : base;\n      } else {\n        return usmoIsDefined ? usmo : DESELECTDIM * base;\n      }\n    };\n  }\n  var mc = marker.color;\n  var smc = selectedMarker.color;\n  var usmc = unselectedMarker.color;\n  if (smc || usmc) {\n    out.selectedColorFn = function (d) {\n      var base = d.mcc || mc;\n      if (d.selected) {\n        return smc || base;\n      } else {\n        return usmc || base;\n      }\n    };\n  }\n  var ms = marker.size;\n  var sms = selectedMarker.size;\n  var usms = unselectedMarker.size;\n  var smsIsDefined = sms !== undefined;\n  var usmsIsDefined = usms !== undefined;\n  if (Registry.traceIs(trace, 'symbols') && (smsIsDefined || usmsIsDefined)) {\n    out.selectedSizeFn = function (d) {\n      var base = d.mrc || ms / 2;\n      if (d.selected) {\n        return smsIsDefined ? sms / 2 : base;\n      } else {\n        return usmsIsDefined ? usms / 2 : base;\n      }\n    };\n  }\n  return out;\n};\ndrawing.makeSelectedTextStyleFns = function (trace) {\n  var out = {};\n  var selectedAttrs = trace.selected || {};\n  var unselectedAttrs = trace.unselected || {};\n  var textFont = trace.textfont || {};\n  var selectedTextFont = selectedAttrs.textfont || {};\n  var unselectedTextFont = unselectedAttrs.textfont || {};\n  var tc = textFont.color;\n  var stc = selectedTextFont.color;\n  var utc = unselectedTextFont.color;\n  out.selectedTextColorFn = function (d) {\n    var base = d.tc || tc;\n    if (d.selected) {\n      return stc || base;\n    } else {\n      if (utc) return utc;else return stc ? base : Color.addOpacity(base, DESELECTDIM);\n    }\n  };\n  return out;\n};\ndrawing.selectedPointStyle = function (s, trace) {\n  if (!s.size() || !trace.selectedpoints) return;\n  var fns = drawing.makeSelectedPointStyleFns(trace);\n  var marker = trace.marker || {};\n  var seq = [];\n  if (fns.selectedOpacityFn) {\n    seq.push(function (pt, d) {\n      pt.style('opacity', fns.selectedOpacityFn(d));\n    });\n  }\n  if (fns.selectedColorFn) {\n    seq.push(function (pt, d) {\n      Color.fill(pt, fns.selectedColorFn(d));\n    });\n  }\n  if (fns.selectedSizeFn) {\n    seq.push(function (pt, d) {\n      var mx = d.mx || marker.symbol || 0;\n      var mrc2 = fns.selectedSizeFn(d);\n      pt.attr('d', makePointPath(drawing.symbolNumber(mx), mrc2, getMarkerAngle(d, trace), getMarkerStandoff(d, trace)));\n\n      // save for Drawing.selectedTextStyle\n      d.mrc2 = mrc2;\n    });\n  }\n  if (seq.length) {\n    s.each(function (d) {\n      var pt = d3.select(this);\n      for (var i = 0; i < seq.length; i++) {\n        seq[i](pt, d);\n      }\n    });\n  }\n};\ndrawing.tryColorscale = function (marker, prefix) {\n  var cont = prefix ? Lib.nestedProperty(marker, prefix).get() : marker;\n  if (cont) {\n    var colorArray = cont.color;\n    if ((cont.colorscale || cont._colorAx) && Lib.isArrayOrTypedArray(colorArray)) {\n      return Colorscale.makeColorScaleFuncFromTrace(cont);\n    }\n  }\n  return Lib.identity;\n};\nvar TEXTOFFSETSIGN = {\n  start: 1,\n  end: -1,\n  middle: 0,\n  bottom: 1,\n  top: -1\n};\nfunction textPointPosition(s, textPosition, fontSize, markerRadius, dontTouchParent) {\n  var group = d3.select(s.node().parentNode);\n  var v = textPosition.indexOf('top') !== -1 ? 'top' : textPosition.indexOf('bottom') !== -1 ? 'bottom' : 'middle';\n  var h = textPosition.indexOf('left') !== -1 ? 'end' : textPosition.indexOf('right') !== -1 ? 'start' : 'middle';\n\n  // if markers are shown, offset a little more than\n  // the nominal marker size\n  // ie 2/1.6 * nominal, bcs some markers are a bit bigger\n  var r = markerRadius ? markerRadius / 0.8 + 1 : 0;\n  var numLines = (svgTextUtils.lineCount(s) - 1) * LINE_SPACING + 1;\n  var dx = TEXTOFFSETSIGN[h] * r;\n  var dy = fontSize * 0.75 + TEXTOFFSETSIGN[v] * r + (TEXTOFFSETSIGN[v] - 1) * numLines * fontSize / 2;\n\n  // fix the overall text group position\n  s.attr('text-anchor', h);\n  if (!dontTouchParent) {\n    group.attr('transform', strTranslate(dx, dy));\n  }\n}\nfunction extracTextFontSize(d, trace) {\n  var fontSize = d.ts || trace.textfont.size;\n  return isNumeric(fontSize) && fontSize > 0 ? fontSize : 0;\n}\n\n// draw text at points\ndrawing.textPointStyle = function (s, trace, gd) {\n  if (!s.size()) return;\n  var selectedTextColorFn;\n  if (trace.selectedpoints) {\n    var fns = drawing.makeSelectedTextStyleFns(trace);\n    selectedTextColorFn = fns.selectedTextColorFn;\n  }\n  var texttemplate = trace.texttemplate;\n  var fullLayout = gd._fullLayout;\n  s.each(function (d) {\n    var p = d3.select(this);\n    var text = texttemplate ? Lib.extractOption(d, trace, 'txt', 'texttemplate') : Lib.extractOption(d, trace, 'tx', 'text');\n    if (!text && text !== 0) {\n      p.remove();\n      return;\n    }\n    if (texttemplate) {\n      var fn = trace._module.formatLabels;\n      var labels = fn ? fn(d, trace, fullLayout) : {};\n      var pointValues = {};\n      appendArrayPointValue(pointValues, trace, d.i);\n      var meta = trace._meta || {};\n      text = Lib.texttemplateString(text, labels, fullLayout._d3locale, pointValues, d, meta);\n    }\n    var pos = d.tp || trace.textposition;\n    var fontSize = extracTextFontSize(d, trace);\n    var fontColor = selectedTextColorFn ? selectedTextColorFn(d) : d.tc || trace.textfont.color;\n    p.call(drawing.font, d.tf || trace.textfont.family, fontSize, fontColor).text(text).call(svgTextUtils.convertToTspans, gd).call(textPointPosition, pos, fontSize, d.mrc);\n  });\n};\ndrawing.selectedTextStyle = function (s, trace) {\n  if (!s.size() || !trace.selectedpoints) return;\n  var fns = drawing.makeSelectedTextStyleFns(trace);\n  s.each(function (d) {\n    var tx = d3.select(this);\n    var tc = fns.selectedTextColorFn(d);\n    var tp = d.tp || trace.textposition;\n    var fontSize = extracTextFontSize(d, trace);\n    Color.fill(tx, tc);\n    var dontTouchParent = Registry.traceIs(trace, 'bar-like');\n    textPointPosition(tx, tp, fontSize, d.mrc2 || d.mrc, dontTouchParent);\n  });\n};\n\n// generalized Catmull-Rom splines, per\n// http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\nvar CatmullRomExp = 0.5;\ndrawing.smoothopen = function (pts, smoothness) {\n  if (pts.length < 3) {\n    return 'M' + pts.join('L');\n  }\n  var path = 'M' + pts[0];\n  var tangents = [];\n  var i;\n  for (i = 1; i < pts.length - 1; i++) {\n    tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n  }\n  path += 'Q' + tangents[0][0] + ' ' + pts[1];\n  for (i = 2; i < pts.length - 1; i++) {\n    path += 'C' + tangents[i - 2][1] + ' ' + tangents[i - 1][0] + ' ' + pts[i];\n  }\n  path += 'Q' + tangents[pts.length - 3][1] + ' ' + pts[pts.length - 1];\n  return path;\n};\ndrawing.smoothclosed = function (pts, smoothness) {\n  if (pts.length < 3) {\n    return 'M' + pts.join('L') + 'Z';\n  }\n  var path = 'M' + pts[0];\n  var pLast = pts.length - 1;\n  var tangents = [makeTangent(pts[pLast], pts[0], pts[1], smoothness)];\n  var i;\n  for (i = 1; i < pLast; i++) {\n    tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n  }\n  tangents.push(makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness));\n  for (i = 1; i <= pLast; i++) {\n    path += 'C' + tangents[i - 1][1] + ' ' + tangents[i][0] + ' ' + pts[i];\n  }\n  path += 'C' + tangents[pLast][1] + ' ' + tangents[0][0] + ' ' + pts[0] + 'Z';\n  return path;\n};\nvar lastDrawnX, lastDrawnY;\nfunction roundEnd(pt, isY, isLastPoint) {\n  if (isLastPoint) pt = applyBackoff(pt);\n  return isY ? roundY(pt[1]) : roundX(pt[0]);\n}\nfunction roundX(p) {\n  var v = d3.round(p, 2);\n  lastDrawnX = v;\n  return v;\n}\nfunction roundY(p) {\n  var v = d3.round(p, 2);\n  lastDrawnY = v;\n  return v;\n}\nfunction makeTangent(prevpt, thispt, nextpt, smoothness) {\n  var d1x = prevpt[0] - thispt[0];\n  var d1y = prevpt[1] - thispt[1];\n  var d2x = nextpt[0] - thispt[0];\n  var d2y = nextpt[1] - thispt[1];\n  var d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2);\n  var d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2);\n  var numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness;\n  var numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness;\n  var denom1 = 3 * d2a * (d1a + d2a);\n  var denom2 = 3 * d1a * (d1a + d2a);\n  return [[roundX(thispt[0] + (denom1 && numx / denom1)), roundY(thispt[1] + (denom1 && numy / denom1))], [roundX(thispt[0] - (denom2 && numx / denom2)), roundY(thispt[1] - (denom2 && numy / denom2))]];\n}\n\n// step paths - returns a generator function for paths\n// with the given step shape\nvar STEPPATH = {\n  hv: function (p0, p1, isLastPoint) {\n    return 'H' + roundX(p1[0]) + 'V' + roundEnd(p1, 1, isLastPoint);\n  },\n  vh: function (p0, p1, isLastPoint) {\n    return 'V' + roundY(p1[1]) + 'H' + roundEnd(p1, 0, isLastPoint);\n  },\n  hvh: function (p0, p1, isLastPoint) {\n    return 'H' + roundX((p0[0] + p1[0]) / 2) + 'V' + roundY(p1[1]) + 'H' + roundEnd(p1, 0, isLastPoint);\n  },\n  vhv: function (p0, p1, isLastPoint) {\n    return 'V' + roundY((p0[1] + p1[1]) / 2) + 'H' + roundX(p1[0]) + 'V' + roundEnd(p1, 1, isLastPoint);\n  }\n};\nvar STEPLINEAR = function (p0, p1, isLastPoint) {\n  return 'L' + roundEnd(p1, 0, isLastPoint) + ',' + roundEnd(p1, 1, isLastPoint);\n};\ndrawing.steps = function (shape) {\n  var onestep = STEPPATH[shape] || STEPLINEAR;\n  return function (pts) {\n    var path = 'M' + roundX(pts[0][0]) + ',' + roundY(pts[0][1]);\n    var len = pts.length;\n    for (var i = 1; i < len; i++) {\n      path += onestep(pts[i - 1], pts[i], i === len - 1);\n    }\n    return path;\n  };\n};\nfunction applyBackoff(pt, start) {\n  var backoff = pt.backoff;\n  var trace = pt.trace;\n  var d = pt.d;\n  var i = pt.i;\n  if (backoff && trace && trace.marker && trace.marker.angle % 360 === 0 && trace.line && trace.line.shape !== 'spline') {\n    var arrayBackoff = Lib.isArrayOrTypedArray(backoff);\n    var end = pt;\n    var x1 = start ? start[0] : lastDrawnX || 0;\n    var y1 = start ? start[1] : lastDrawnY || 0;\n    var x2 = end[0];\n    var y2 = end[1];\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    var t = Math.atan2(dy, dx);\n    var b = arrayBackoff ? backoff[i] : backoff;\n    if (b === 'auto') {\n      var endI = end.i;\n      if (trace.type === 'scatter') endI--; // Why we need this hack?\n\n      var endMarker = end.marker;\n      var endMarkerSymbol = endMarker.symbol;\n      if (Lib.isArrayOrTypedArray(endMarkerSymbol)) endMarkerSymbol = endMarkerSymbol[endI];\n      var endMarkerSize = endMarker.size;\n      if (Lib.isArrayOrTypedArray(endMarkerSize)) endMarkerSize = endMarkerSize[endI];\n      b = endMarker ? drawing.symbolBackOffs[drawing.symbolNumber(endMarkerSymbol)] * endMarkerSize : 0;\n      b += drawing.getMarkerStandoff(d[endI], trace) || 0;\n    }\n    var x = x2 - b * Math.cos(t);\n    var y = y2 - b * Math.sin(t);\n    if ((x <= x2 && x >= x1 || x >= x2 && x <= x1) && (y <= y2 && y >= y1 || y >= y2 && y <= y1)) {\n      pt = [x, y];\n    }\n  }\n  return pt;\n}\ndrawing.applyBackoff = applyBackoff;\n\n// off-screen svg render testing element, shared by the whole page\n// uses the id 'js-plotly-tester' and stores it in drawing.tester\ndrawing.makeTester = function () {\n  var tester = Lib.ensureSingleById(d3.select('body'), 'svg', 'js-plotly-tester', function (s) {\n    s.attr(xmlnsNamespaces.svgAttrs).style({\n      position: 'absolute',\n      left: '-10000px',\n      top: '-10000px',\n      width: '9000px',\n      height: '9000px',\n      'z-index': '1'\n    });\n  });\n\n  // browsers differ on how they describe the bounding rect of\n  // the svg if its contents spill over... so make a 1x1px\n  // reference point we can measure off of.\n  var testref = Lib.ensureSingle(tester, 'path', 'js-reference-point', function (s) {\n    s.attr('d', 'M0,0H1V1H0Z').style({\n      'stroke-width': 0,\n      fill: 'black'\n    });\n  });\n  drawing.tester = tester;\n  drawing.testref = testref;\n};\n\n/*\n * use our offscreen tester to get a clientRect for an element,\n * in a reference frame where it isn't translated (or transformed) and\n * its anchor point is at (0,0)\n * always returns a copy of the bbox, so the caller can modify it safely\n *\n * @param {SVGElement} node: the element to measure. If possible this should be\n *   a <text> or MathJax <g> element that's already passed through\n *   `convertToTspans` because in that case we can cache the results, but it's\n *   possible to pass in any svg element.\n *\n * @param {boolean} inTester: is this element already in `drawing.tester`?\n *   If you are measuring a dummy element, rather than one you really intend\n *   to use on the plot, making it in `drawing.tester` in the first place\n *   allows us to test faster because it cuts out cloning and appending it.\n *\n * @param {string} hash: for internal use only, if we already know the cache key\n *   for this element beforehand.\n *\n * @return {object}: a plain object containing the width, height, left, right,\n *   top, and bottom of `node`\n */\ndrawing.savedBBoxes = {};\nvar savedBBoxesCount = 0;\nvar maxSavedBBoxes = 10000;\ndrawing.bBox = function (node, inTester, hash) {\n  /*\n   * Cache elements we've already measured so we don't have to\n   * remeasure the same thing many times\n   * We have a few bBox callers though who pass a node larger than\n   * a <text> or a MathJax <g>, such as an axis group containing many labels.\n   * These will not generate a hash (unless we figure out an appropriate\n   * hash key for them) and thus we will not hash them.\n   */\n  if (!hash) hash = nodeHash(node);\n  var out;\n  if (hash) {\n    out = drawing.savedBBoxes[hash];\n    if (out) return Lib.extendFlat({}, out);\n  } else if (node.childNodes.length === 1) {\n    /*\n     * If we have only one child element, which is itself hashable, make\n     * a new hash from this element plus its x,y,transform\n     * These bounding boxes *include* x,y,transform - mostly for use by\n     * callers trying to avoid overlaps (ie titles)\n     */\n    var innerNode = node.childNodes[0];\n    hash = nodeHash(innerNode);\n    if (hash) {\n      var x = +innerNode.getAttribute('x') || 0;\n      var y = +innerNode.getAttribute('y') || 0;\n      var transform = innerNode.getAttribute('transform');\n      if (!transform) {\n        // in this case, just varying x and y, don't bother caching\n        // the final bBox because the alteration is quick.\n        var innerBB = drawing.bBox(innerNode, false, hash);\n        if (x) {\n          innerBB.left += x;\n          innerBB.right += x;\n        }\n        if (y) {\n          innerBB.top += y;\n          innerBB.bottom += y;\n        }\n        return innerBB;\n      }\n      /*\n       * else we have a transform - rather than make a complicated\n       * (and error-prone and probably slow) transform parser/calculator,\n       * just continue on calculating the boundingClientRect of the group\n       * and use the new composite hash to cache it.\n       * That said, `innerNode.transform.baseVal` is an array of\n       * `SVGTransform` objects, that *do* seem to have a nice matrix\n       * multiplication interface that we could use to avoid making\n       * another getBoundingClientRect call...\n       */\n      hash += '~' + x + '~' + y + '~' + transform;\n      out = drawing.savedBBoxes[hash];\n      if (out) return Lib.extendFlat({}, out);\n    }\n  }\n  var testNode, tester;\n  if (inTester) {\n    testNode = node;\n  } else {\n    tester = drawing.tester.node();\n\n    // copy the node to test into the tester\n    testNode = node.cloneNode(true);\n    tester.appendChild(testNode);\n  }\n\n  // standardize its position (and newline tspans if any)\n  d3.select(testNode).attr('transform', null).call(svgTextUtils.positionText, 0, 0);\n  var testRect = testNode.getBoundingClientRect();\n  var refRect = drawing.testref.node().getBoundingClientRect();\n  if (!inTester) tester.removeChild(testNode);\n  var bb = {\n    height: testRect.height,\n    width: testRect.width,\n    left: testRect.left - refRect.left,\n    top: testRect.top - refRect.top,\n    right: testRect.right - refRect.left,\n    bottom: testRect.bottom - refRect.top\n  };\n\n  // make sure we don't have too many saved boxes,\n  // or a long session could overload on memory\n  // by saving boxes for long-gone elements\n  if (savedBBoxesCount >= maxSavedBBoxes) {\n    drawing.savedBBoxes = {};\n    savedBBoxesCount = 0;\n  }\n\n  // cache this bbox\n  if (hash) drawing.savedBBoxes[hash] = bb;\n  savedBBoxesCount++;\n  return Lib.extendFlat({}, bb);\n};\n\n// capture everything about a node (at least in our usage) that\n// impacts its bounding box, given that bBox clears x, y, and transform\nfunction nodeHash(node) {\n  var inputText = node.getAttribute('data-unformatted');\n  if (inputText === null) return;\n  return inputText + node.getAttribute('data-math') + node.getAttribute('text-anchor') + node.getAttribute('style');\n}\n\n/**\n * Set clipPath URL in a way that work for all situations.\n *\n * In details, graphs on pages with <base> HTML tags need to prepend\n * the clip path ids with the page's base url EXCEPT during toImage exports.\n *\n * @param {d3 selection} s : node to add clip-path attribute\n * @param {string} localId : local clip-path (w/o base url) id\n * @param {DOM element || object} gd\n * - context._baseUrl {string}\n * - context._exportedPlot {boolean}\n */\ndrawing.setClipUrl = function (s, localId, gd) {\n  s.attr('clip-path', getFullUrl(localId, gd));\n};\nfunction getFullUrl(localId, gd) {\n  if (!localId) return null;\n  var context = gd._context;\n  var baseUrl = context._exportedPlot ? '' : context._baseUrl || '';\n  return baseUrl ? 'url(\\'' + baseUrl + '#' + localId + '\\')' : 'url(#' + localId + ')';\n}\ndrawing.getTranslate = function (element) {\n  // Note the separator [^\\d] between x and y in this regex\n  // We generally use ',' but IE will convert it to ' '\n  var re = /.*\\btranslate\\((-?\\d*\\.?\\d*)[^-\\d]*(-?\\d*\\.?\\d*)[^\\d].*/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var transform = element[getter]('transform') || '';\n  var translate = transform.replace(re, function (match, p1, p2) {\n    return [p1, p2].join(' ');\n  }).split(' ');\n  return {\n    x: +translate[0] || 0,\n    y: +translate[1] || 0\n  };\n};\ndrawing.setTranslate = function (element, x, y) {\n  var re = /(\\btranslate\\(.*?\\);?)/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var setter = element.attr ? 'attr' : 'setAttribute';\n  var transform = element[getter]('transform') || '';\n  x = x || 0;\n  y = y || 0;\n  transform = transform.replace(re, '').trim();\n  transform += strTranslate(x, y);\n  transform = transform.trim();\n  element[setter]('transform', transform);\n  return transform;\n};\ndrawing.getScale = function (element) {\n  var re = /.*\\bscale\\((\\d*\\.?\\d*)[^\\d]*(\\d*\\.?\\d*)[^\\d].*/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var transform = element[getter]('transform') || '';\n  var translate = transform.replace(re, function (match, p1, p2) {\n    return [p1, p2].join(' ');\n  }).split(' ');\n  return {\n    x: +translate[0] || 1,\n    y: +translate[1] || 1\n  };\n};\ndrawing.setScale = function (element, x, y) {\n  var re = /(\\bscale\\(.*?\\);?)/;\n  var getter = element.attr ? 'attr' : 'getAttribute';\n  var setter = element.attr ? 'attr' : 'setAttribute';\n  var transform = element[getter]('transform') || '';\n  x = x || 1;\n  y = y || 1;\n  transform = transform.replace(re, '').trim();\n  transform += 'scale(' + x + ',' + y + ')';\n  transform = transform.trim();\n  element[setter]('transform', transform);\n  return transform;\n};\nvar SCALE_RE = /\\s*sc.*/;\ndrawing.setPointGroupScale = function (selection, xScale, yScale) {\n  xScale = xScale || 1;\n  yScale = yScale || 1;\n  if (!selection) return;\n\n  // The same scale transform for every point:\n  var scale = xScale === 1 && yScale === 1 ? '' : 'scale(' + xScale + ',' + yScale + ')';\n  selection.each(function () {\n    var t = (this.getAttribute('transform') || '').replace(SCALE_RE, '');\n    t += scale;\n    t = t.trim();\n    this.setAttribute('transform', t);\n  });\n};\nvar TEXT_POINT_LAST_TRANSLATION_RE = /translate\\([^)]*\\)\\s*$/;\ndrawing.setTextPointsScale = function (selection, xScale, yScale) {\n  if (!selection) return;\n  selection.each(function () {\n    var transforms;\n    var el = d3.select(this);\n    var text = el.select('text');\n    if (!text.node()) return;\n    var x = parseFloat(text.attr('x') || 0);\n    var y = parseFloat(text.attr('y') || 0);\n    var existingTransform = (el.attr('transform') || '').match(TEXT_POINT_LAST_TRANSLATION_RE);\n    if (xScale === 1 && yScale === 1) {\n      transforms = [];\n    } else {\n      transforms = [strTranslate(x, y), 'scale(' + xScale + ',' + yScale + ')', strTranslate(-x, -y)];\n    }\n    if (existingTransform) {\n      transforms.push(existingTransform);\n    }\n    el.attr('transform', transforms.join(''));\n  });\n};\nfunction getMarkerStandoff(d, trace) {\n  var standoff;\n  if (d) standoff = d.mf;\n  if (standoff === undefined) {\n    standoff = trace.marker ? trace.marker.standoff || 0 : 0;\n  }\n  if (!trace._geo && !trace._xA) {\n    // case of legends\n    return -standoff;\n  }\n  return standoff;\n}\ndrawing.getMarkerStandoff = getMarkerStandoff;\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\nvar sin = Math.sin;\nfunction rotate(t, xy) {\n  var x = xy[0];\n  var y = xy[1];\n  return [x * cos(t) - y * sin(t), x * sin(t) + y * cos(t)];\n}\nvar previousLon;\nvar previousLat;\nvar previousX;\nvar previousY;\nvar previousI;\nvar previousTraceUid;\nfunction getMarkerAngle(d, trace) {\n  var angle = d.ma;\n  if (angle === undefined) {\n    angle = trace.marker.angle;\n    if (!angle || Lib.isArrayOrTypedArray(angle)) {\n      angle = 0;\n    }\n  }\n  var x, y;\n  var ref = trace.marker.angleref;\n  if (ref === 'previous' || ref === 'north') {\n    if (trace._geo) {\n      var p = trace._geo.project(d.lonlat);\n      x = p[0];\n      y = p[1];\n    } else {\n      var xa = trace._xA;\n      var ya = trace._yA;\n      if (xa && ya) {\n        x = xa.c2p(d.x);\n        y = ya.c2p(d.y);\n      } else {\n        // case of legends\n        return 90;\n      }\n    }\n    if (trace._geo) {\n      var lon = d.lonlat[0];\n      var lat = d.lonlat[1];\n      var north = trace._geo.project([lon, lat + 1e-5 // epsilon\n      ]);\n      var east = trace._geo.project([lon + 1e-5,\n      // epsilon\n      lat]);\n      var u = atan2(east[1] - y, east[0] - x);\n      var v = atan2(north[1] - y, north[0] - x);\n      var t;\n      if (ref === 'north') {\n        t = angle / 180 * Math.PI;\n        // To use counter-clockwise angles i.e.\n        // East: 90, West: -90\n        // to facilitate wind visualisations\n        // in future we should use t = -t here.\n      } else if (ref === 'previous') {\n        var lon1 = lon / 180 * Math.PI;\n        var lat1 = lat / 180 * Math.PI;\n        var lon2 = previousLon / 180 * Math.PI;\n        var lat2 = previousLat / 180 * Math.PI;\n        var dLon = lon2 - lon1;\n        var deltaY = cos(lat2) * sin(dLon);\n        var deltaX = sin(lat2) * cos(lat1) - cos(lat2) * sin(lat1) * cos(dLon);\n        t = -atan2(deltaY, deltaX) - Math.PI;\n        previousLon = lon;\n        previousLat = lat;\n      }\n      var A = rotate(u, [cos(t), 0]);\n      var B = rotate(v, [sin(t), 0]);\n      angle = atan2(A[1] + B[1], A[0] + B[0]) / Math.PI * 180;\n      if (ref === 'previous' && !(previousTraceUid === trace.uid && d.i === previousI + 1)) {\n        angle = null;\n      }\n    }\n    if (ref === 'previous' && !trace._geo) {\n      if (previousTraceUid === trace.uid && d.i === previousI + 1 && isNumeric(x) && isNumeric(y)) {\n        var dX = x - previousX;\n        var dY = y - previousY;\n        var shape = trace.line ? trace.line.shape || '' : '';\n        var lastShapeChar = shape.slice(shape.length - 1);\n        if (lastShapeChar === 'h') dY = 0;\n        if (lastShapeChar === 'v') dX = 0;\n        angle += atan2(dY, dX) / Math.PI * 180 + 90;\n      } else {\n        angle = null;\n      }\n    }\n  }\n  previousX = x;\n  previousY = y;\n  previousI = d.i;\n  previousTraceUid = trace.uid;\n  return angle;\n}\ndrawing.getMarkerAngle = getMarkerAngle;","map":{"version":3,"names":["require","d3","Lib","numberFormat","isNumeric","tinycolor","Registry","Color","Colorscale","strTranslate","svgTextUtils","xmlnsNamespaces","alignment","LINE_SPACING","DESELECTDIM","subTypes","makeBubbleSizeFn","appendArrayPointValue","drawing","module","exports","font","s","family","size","color","isPlainObject","style","call","fill","setPosition","x","y","attr","setSize","w","h","setRect","translatePoint","d","sel","xa","ya","c2p","node","nodeName","translatePoints","each","select","hideOutsideRangePoint","xcalendar","ycalendar","isPtWithinRange","hideOutsideRangePoints","traceGroups","subplot","_hasClipOnAxisFalse","xaxis","yaxis","trace","selector","traceIs","selectAll","crispRound","gd","lineWidth","dflt","_context","staticPlot","Math","round","singleLineStyle","lw","lc","ld","line","lw1","width","dash","stroke","dashLine","lineGroupStyle","dashStyle","dlw","max","setFillStyle","forLegend","markerPattern","fillpattern","fillgradient","patternShape","getPatternAttr","shape","patternBGColor","bgcolor","patternFGColor","fgcolor","patternFGOpacity","fgopacity","patternSize","patternSolidity","solidity","patternID","uid","pattern","undefined","fillmode","type","direction","gradientID","start","stop","_xA","_extremes","min","val","_yA","gradientWithBounds","colorscale","gradient","fillcolor","singleFillStyle","data","fillGroupStyle","SYMBOLDEFS","symbolNames","symbolFuncs","symbolBackOffs","symbolNeedLines","symbolNoDot","symbolNoFill","symbolList","Object","keys","forEach","k","symDef","n","push","String","f","backoff","needLine","noDot","noFill","MAXSYMBOL","length","DOTPATH","symbolNumber","v","vbase","indexOf","replace","floor","makePointPath","r","t","base","stopFormatter","gradientInfo","radial","radialreversed","reversed","horizontal","horizontalreversed","vertical","verticalreversed","prop","info","inUserSpace","len","attrs","x1","y1","x2","y2","gradientUnits","colorStops","Array","i","fullLayout","_fullLayout","fullID","_uid","_defs","join","identity","exit","remove","enter","append","el","stops","tc","offset","tinyRGB","getAlpha","getFullUrl","classed","calledBy","mcc","isLegend","contrast","height","linearFn","x0","y0","path","linewidth","radius","patternTag","patternAttrs","fgC","fgRGB","fgAlpha","opacity","sqrt","PI","cx","cy","str","id","patternUnits","patternTransform","bgC","bgRGB","bgAlpha","rects","patterns","initGradients","gradientsGroup","ensureSingle","initPatterns","patternsGroup","mp","isArrayOrTypedArray","pointStyle","pt","fns","makePointStyleFns","singlePointStyle","marker","markerLine","selectedOpacityFn","mo","ms2mrc","ms","mrc","selectedSizeFn","mx","symbol","om","angle","getMarkerAngle","standoff","getMarkerStandoff","perPointGradient","fillColor","lineColor","so","outlierwidth","outliercolor","markerLineWidth","mlw","mlcc","lineScale","mlc","defaultLine","markerScale","mc","colors","selectedColorFn","isBlank","markerGradient","gradientType","mgt","gradientColor","mgc","perPointPattern","out","tryColorscale","isBubble","selectedpoints","extendFlat","makeSelectedPointStyleFns","selectedAttrs","selected","unselectedAttrs","unselected","selectedMarker","unselectedMarker","smo","usmo","smoIsDefined","usmoIsDefined","smc","usmc","sms","usms","smsIsDefined","usmsIsDefined","makeSelectedTextStyleFns","textFont","textfont","selectedTextFont","unselectedTextFont","stc","utc","selectedTextColorFn","addOpacity","selectedPointStyle","seq","mrc2","prefix","cont","nestedProperty","get","colorArray","_colorAx","makeColorScaleFuncFromTrace","TEXTOFFSETSIGN","end","middle","bottom","top","textPointPosition","textPosition","fontSize","markerRadius","dontTouchParent","group","parentNode","numLines","lineCount","dx","dy","extracTextFontSize","ts","textPointStyle","texttemplate","p","text","extractOption","fn","_module","formatLabels","labels","pointValues","meta","_meta","texttemplateString","_d3locale","pos","tp","textposition","fontColor","tf","convertToTspans","selectedTextStyle","tx","CatmullRomExp","smoothopen","pts","smoothness","tangents","makeTangent","smoothclosed","pLast","lastDrawnX","lastDrawnY","roundEnd","isY","isLastPoint","applyBackoff","roundY","roundX","prevpt","thispt","nextpt","d1x","d1y","d2x","d2y","d1a","pow","d2a","numx","numy","denom1","denom2","STEPPATH","hv","p0","p1","vh","hvh","vhv","STEPLINEAR","steps","onestep","arrayBackoff","atan2","b","endI","endMarker","endMarkerSymbol","endMarkerSize","cos","sin","makeTester","tester","ensureSingleById","svgAttrs","position","left","testref","savedBBoxes","savedBBoxesCount","maxSavedBBoxes","bBox","inTester","hash","nodeHash","childNodes","innerNode","getAttribute","transform","innerBB","right","testNode","cloneNode","appendChild","positionText","testRect","getBoundingClientRect","refRect","removeChild","bb","inputText","setClipUrl","localId","context","baseUrl","_exportedPlot","_baseUrl","getTranslate","element","re","getter","translate","match","p2","split","setTranslate","setter","trim","getScale","setScale","SCALE_RE","setPointGroupScale","selection","xScale","yScale","scale","setAttribute","TEXT_POINT_LAST_TRANSLATION_RE","setTextPointsScale","transforms","parseFloat","existingTransform","mf","_geo","rotate","xy","previousLon","previousLat","previousX","previousY","previousI","previousTraceUid","ma","ref","angleref","project","lonlat","lon","lat","north","east","u","lon1","lat1","lon2","lat2","dLon","deltaY","deltaX","A","B","dX","dY","lastShapeChar","slice"],"sources":["/home/zhu/Documents/github/explorer_front/explorer_front_app/node_modules/plotly.js/src/components/drawing/index.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar numberFormat = Lib.numberFormat;\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\n\nvar Registry = require('../../registry');\nvar Color = require('../color');\nvar Colorscale = require('../colorscale');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nvar alignment = require('../../constants/alignment');\nvar LINE_SPACING = alignment.LINE_SPACING;\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nvar subTypes = require('../../traces/scatter/subtypes');\nvar makeBubbleSizeFn = require('../../traces/scatter/make_bubble_size_func');\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar drawing = module.exports = {};\n\n// -----------------------------------------------------\n// styling functions for plot elements\n// -----------------------------------------------------\n\ndrawing.font = function(s, family, size, color) {\n    // also allow the form font(s, {family, size, color})\n    if(Lib.isPlainObject(family)) {\n        color = family.color;\n        size = family.size;\n        family = family.family;\n    }\n    if(family) s.style('font-family', family);\n    if(size + 1) s.style('font-size', size + 'px');\n    if(color) s.call(Color.fill, color);\n};\n\n/*\n * Positioning helpers\n * Note: do not use `setPosition` with <text> nodes modified by\n * `svgTextUtils.convertToTspans`. Use `svgTextUtils.positionText`\n * instead, so that <tspan.line> elements get updated to match.\n */\ndrawing.setPosition = function(s, x, y) { s.attr('x', x).attr('y', y); };\ndrawing.setSize = function(s, w, h) { s.attr('width', w).attr('height', h); };\ndrawing.setRect = function(s, x, y, w, h) {\n    s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);\n};\n\n/** Translate node\n *\n * @param {object} d : calcdata point item\n * @param {sel} sel : d3 selction of node to translate\n * @param {object} xa : corresponding full xaxis object\n * @param {object} ya : corresponding full yaxis object\n *\n * @return {boolean} :\n *  true if selection got translated\n *  false if selection could not get translated\n */\ndrawing.translatePoint = function(d, sel, xa, ya) {\n    var x = xa.c2p(d.x);\n    var y = ya.c2p(d.y);\n\n    if(isNumeric(x) && isNumeric(y) && sel.node()) {\n        // for multiline text this works better\n        if(sel.node().nodeName === 'text') {\n            sel.attr('x', x).attr('y', y);\n        } else {\n            sel.attr('transform', strTranslate(x, y));\n        }\n    } else {\n        return false;\n    }\n\n    return true;\n};\n\ndrawing.translatePoints = function(s, xa, ya) {\n    s.each(function(d) {\n        var sel = d3.select(this);\n        drawing.translatePoint(d, sel, xa, ya);\n    });\n};\n\ndrawing.hideOutsideRangePoint = function(d, sel, xa, ya, xcalendar, ycalendar) {\n    sel.attr(\n        'display',\n        (xa.isPtWithinRange(d, xcalendar) && ya.isPtWithinRange(d, ycalendar)) ? null : 'none'\n    );\n};\n\ndrawing.hideOutsideRangePoints = function(traceGroups, subplot) {\n    if(!subplot._hasClipOnAxisFalse) return;\n\n    var xa = subplot.xaxis;\n    var ya = subplot.yaxis;\n\n    traceGroups.each(function(d) {\n        var trace = d[0].trace;\n        var xcalendar = trace.xcalendar;\n        var ycalendar = trace.ycalendar;\n        var selector = Registry.traceIs(trace, 'bar-like') ? '.bartext' : '.point,.textpoint';\n\n        traceGroups.selectAll(selector).each(function(d) {\n            drawing.hideOutsideRangePoint(d, d3.select(this), xa, ya, xcalendar, ycalendar);\n        });\n    });\n};\n\ndrawing.crispRound = function(gd, lineWidth, dflt) {\n    // for lines that disable antialiasing we want to\n    // make sure the width is an integer, and at least 1 if it's nonzero\n\n    if(!lineWidth || !isNumeric(lineWidth)) return dflt || 0;\n\n    // but not for static plots - these don't get antialiased anyway.\n    if(gd._context.staticPlot) return lineWidth;\n\n    if(lineWidth < 1) return 1;\n    return Math.round(lineWidth);\n};\n\ndrawing.singleLineStyle = function(d, s, lw, lc, ld) {\n    s.style('fill', 'none');\n    var line = (((d || [])[0] || {}).trace || {}).line || {};\n    var lw1 = lw || line.width || 0;\n    var dash = ld || line.dash || '';\n\n    Color.stroke(s, lc || line.color);\n    drawing.dashLine(s, dash, lw1);\n};\n\ndrawing.lineGroupStyle = function(s, lw, lc, ld) {\n    s.style('fill', 'none')\n    .each(function(d) {\n        var line = (((d || [])[0] || {}).trace || {}).line || {};\n        var lw1 = lw || line.width || 0;\n        var dash = ld || line.dash || '';\n\n        d3.select(this)\n            .call(Color.stroke, lc || line.color)\n            .call(drawing.dashLine, dash, lw1);\n    });\n};\n\ndrawing.dashLine = function(s, dash, lineWidth) {\n    lineWidth = +lineWidth || 0;\n\n    dash = drawing.dashStyle(dash, lineWidth);\n\n    s.style({\n        'stroke-dasharray': dash,\n        'stroke-width': lineWidth + 'px'\n    });\n};\n\ndrawing.dashStyle = function(dash, lineWidth) {\n    lineWidth = +lineWidth || 1;\n    var dlw = Math.max(lineWidth, 3);\n\n    if(dash === 'solid') dash = '';\n    else if(dash === 'dot') dash = dlw + 'px,' + dlw + 'px';\n    else if(dash === 'dash') dash = (3 * dlw) + 'px,' + (3 * dlw) + 'px';\n    else if(dash === 'longdash') dash = (5 * dlw) + 'px,' + (5 * dlw) + 'px';\n    else if(dash === 'dashdot') {\n        dash = (3 * dlw) + 'px,' + dlw + 'px,' + dlw + 'px,' + dlw + 'px';\n    } else if(dash === 'longdashdot') {\n        dash = (5 * dlw) + 'px,' + (2 * dlw) + 'px,' + dlw + 'px,' + (2 * dlw) + 'px';\n    }\n    // otherwise user wrote the dasharray themselves - leave it be\n\n    return dash;\n};\n\nfunction setFillStyle(sel, trace, gd, forLegend) {\n    var markerPattern = trace.fillpattern;\n    var fillgradient = trace.fillgradient;\n    var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, 0, '');\n    if(patternShape) {\n        var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, 0, null);\n        var patternFGColor = drawing.getPatternAttr(markerPattern.fgcolor, 0, null);\n        var patternFGOpacity = markerPattern.fgopacity;\n        var patternSize = drawing.getPatternAttr(markerPattern.size, 0, 8);\n        var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, 0, 0.3);\n        var patternID = trace.uid;\n        drawing.pattern(sel, 'point', gd, patternID,\n            patternShape, patternSize, patternSolidity,\n            undefined, markerPattern.fillmode,\n            patternBGColor, patternFGColor, patternFGOpacity\n        );\n    } else if(fillgradient && fillgradient.type !== 'none') {\n        var direction = fillgradient.type;\n        var gradientID = 'scatterfill-' + trace.uid;\n        if(forLegend) {\n            gradientID = 'legendfill-' + trace.uid;\n        }\n\n        if(!forLegend && (fillgradient.start !== undefined || fillgradient.stop !== undefined)) {\n            var start, stop;\n            if(direction === 'horizontal') {\n                start = {\n                    x: fillgradient.start,\n                    y: 0,\n                };\n                stop = {\n                    x: fillgradient.stop,\n                    y: 0,\n                };\n            } else if(direction === 'vertical') {\n                start = {\n                    x: 0,\n                    y: fillgradient.start,\n                };\n                stop = {\n                    x: 0,\n                    y: fillgradient.stop,\n                };\n            }\n\n            start.x = trace._xA.c2p(\n                (start.x === undefined) ? trace._extremes.x.min[0].val : start.x, true\n            );\n            start.y = trace._yA.c2p(\n                (start.y === undefined) ? trace._extremes.y.min[0].val : start.y, true\n            );\n\n            stop.x = trace._xA.c2p(\n                (stop.x === undefined) ? trace._extremes.x.max[0].val : stop.x, true\n            );\n            stop.y = trace._yA.c2p(\n                (stop.y === undefined) ? trace._extremes.y.max[0].val : stop.y, true\n            );\n            sel.call(gradientWithBounds, gd, gradientID, 'linear', fillgradient.colorscale, 'fill', start, stop, true, false);\n        } else {\n            if(direction === 'horizontal') {\n                direction = direction + 'reversed';\n            }\n            sel.call(drawing.gradient, gd, gradientID, direction, fillgradient.colorscale, 'fill');\n        }\n    } else if(trace.fillcolor) {\n        sel.call(Color.fill, trace.fillcolor);\n    }\n}\n\n// Same as fillGroupStyle, except in this case the selection may be a transition\ndrawing.singleFillStyle = function(sel, gd) {\n    var node = d3.select(sel.node());\n    var data = node.data();\n    var trace = ((data[0] || [])[0] || {}).trace || {};\n    setFillStyle(sel, trace, gd, false);\n};\n\ndrawing.fillGroupStyle = function(s, gd, forLegend) {\n    s.style('stroke-width', 0)\n    .each(function(d) {\n        var shape = d3.select(this);\n        // N.B. 'd' won't be a calcdata item when\n        // fill !== 'none' on a segment-less and marker-less trace\n        if(d[0].trace) {\n            setFillStyle(shape, d[0].trace, gd, forLegend);\n        }\n    });\n};\n\nvar SYMBOLDEFS = require('./symbol_defs');\n\ndrawing.symbolNames = [];\ndrawing.symbolFuncs = [];\ndrawing.symbolBackOffs = [];\ndrawing.symbolNeedLines = {};\ndrawing.symbolNoDot = {};\ndrawing.symbolNoFill = {};\ndrawing.symbolList = [];\n\nObject.keys(SYMBOLDEFS).forEach(function(k) {\n    var symDef = SYMBOLDEFS[k];\n    var n = symDef.n;\n    drawing.symbolList.push(\n        n,\n        String(n),\n        k,\n\n        n + 100,\n        String(n + 100),\n        k + '-open'\n    );\n    drawing.symbolNames[n] = k;\n    drawing.symbolFuncs[n] = symDef.f;\n    drawing.symbolBackOffs[n] = symDef.backoff || 0;\n\n    if(symDef.needLine) {\n        drawing.symbolNeedLines[n] = true;\n    }\n    if(symDef.noDot) {\n        drawing.symbolNoDot[n] = true;\n    } else {\n        drawing.symbolList.push(\n            n + 200,\n            String(n + 200),\n            k + '-dot',\n\n            n + 300,\n            String(n + 300),\n            k + '-open-dot'\n        );\n    }\n    if(symDef.noFill) {\n        drawing.symbolNoFill[n] = true;\n    }\n});\n\nvar MAXSYMBOL = drawing.symbolNames.length;\n// add a dot in the middle of the symbol\nvar DOTPATH = 'M0,0.5L0.5,0L0,-0.5L-0.5,0Z';\n\ndrawing.symbolNumber = function(v) {\n    if(isNumeric(v)) {\n        v = +v;\n    } else if(typeof v === 'string') {\n        var vbase = 0;\n        if(v.indexOf('-open') > 0) {\n            vbase = 100;\n            v = v.replace('-open', '');\n        }\n        if(v.indexOf('-dot') > 0) {\n            vbase += 200;\n            v = v.replace('-dot', '');\n        }\n        v = drawing.symbolNames.indexOf(v);\n        if(v >= 0) { v += vbase; }\n    }\n\n    return (v % 100 >= MAXSYMBOL || v >= 400) ?\n        0 : Math.floor(Math.max(v, 0));\n};\n\nfunction makePointPath(symbolNumber, r, t, s) {\n    var base = symbolNumber % 100;\n    return drawing.symbolFuncs[base](r, t, s) + (symbolNumber >= 200 ? DOTPATH : '');\n}\n\nvar stopFormatter = numberFormat('~f');\nvar gradientInfo = {\n    radial: {type: 'radial'},\n    radialreversed: {type: 'radial', reversed: true},\n    horizontal: {type: 'linear', start: {x: 1, y: 0}, stop: {x: 0, y: 0}},\n    horizontalreversed: {type: 'linear', start: {x: 1, y: 0}, stop: {x: 0, y: 0}, reversed: true},\n    vertical: {type: 'linear', start: {x: 0, y: 1}, stop: {x: 0, y: 0}},\n    verticalreversed: {type: 'linear', start: {x: 0, y: 1}, stop: {x: 0, y: 0}, reversed: true}\n};\n\n/**\n * gradient: create and apply a gradient fill\n *\n * @param {object} sel: d3 selection to apply this gradient to\n *     You can use `selection.call(Drawing.gradient, ...)`\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} gradientID: a unique (within this plot) identifier\n *     for this gradient, so that we don't create unnecessary definitions\n * @param {string} type: 'radial', 'horizontal', or 'vertical', optionally with\n *     'reversed' at the end. Normally radial goes center to edge,\n *     horizontal goes right to left, and vertical goes bottom to top\n * @param {array} colorscale: as in attribute values, [[fraction, color], ...]\n * @param {string} prop: the property to apply to, 'fill' or 'stroke'\n */\ndrawing.gradient = function(sel, gd, gradientID, type, colorscale, prop) {\n    var info = gradientInfo[type];\n    return gradientWithBounds(\n        sel, gd, gradientID, info.type, colorscale, prop, info.start, info.stop, false, info.reversed\n    );\n};\n\n/**\n * gradient_with_bounds: create and apply a gradient fill for defined start and stop positions\n *\n * @param {object} sel: d3 selection to apply this gradient to\n *     You can use `selection.call(Drawing.gradient, ...)`\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} gradientID: a unique (within this plot) identifier\n *     for this gradient, so that we don't create unnecessary definitions\n * @param {string} type: 'radial' or 'linear'. Radial goes center to edge,\n *     horizontal goes as defined by start and stop\n * @param {array} colorscale: as in attribute values, [[fraction, color], ...]\n * @param {string} prop: the property to apply to, 'fill' or 'stroke'\n * @param {object} start: start point for linear gradients, { x: number, y: number }.\n *     Ignored if type is 'radial'.\n * @param {object} stop: stop point for linear gradients, { x: number, y: number }.\n *     Ignored if type is 'radial'.\n * @param {boolean} inUserSpace: If true, start and stop give absolute values in the plot.\n *     If false, start and stop are fractions of the traces extent along each axis.\n * @param {boolean} reversed: If true, the gradient is reversed between normal start and stop,\n *     i.e., the colorscale is applied in order from stop to start for linear, from edge\n *     to center for radial gradients.\n */\nfunction gradientWithBounds(sel, gd, gradientID, type, colorscale, prop, start, stop, inUserSpace, reversed) {\n    var len = colorscale.length;\n\n    var info;\n    if(type === 'linear') {\n        info = {\n            node: 'linearGradient',\n            attrs: {\n                x1: start.x,\n                y1: start.y,\n                x2: stop.x,\n                y2: stop.y,\n                gradientUnits: inUserSpace ? 'userSpaceOnUse' : 'objectBoundingBox',\n            },\n            reversed: reversed,\n        };\n    } else if(type === 'radial') {\n        info = {\n            node: 'radialGradient',\n            reversed: reversed,\n        };\n    }\n\n    var colorStops = new Array(len);\n    for(var i = 0; i < len; i++) {\n        if(info.reversed) {\n            colorStops[len - 1 - i] = [stopFormatter((1 - colorscale[i][0]) * 100), colorscale[i][1]];\n        } else {\n            colorStops[i] = [stopFormatter(colorscale[i][0] * 100), colorscale[i][1]];\n        }\n    }\n\n    var fullLayout = gd._fullLayout;\n    var fullID = 'g' + fullLayout._uid + '-' + gradientID;\n\n    var gradient = fullLayout._defs.select('.gradients')\n        .selectAll('#' + fullID)\n        .data([type + colorStops.join(';')], Lib.identity);\n\n    gradient.exit().remove();\n\n    gradient.enter()\n        .append(info.node)\n        .each(function() {\n            var el = d3.select(this);\n            if(info.attrs) el.attr(info.attrs);\n\n            el.attr('id', fullID);\n\n            var stops = el.selectAll('stop')\n                .data(colorStops);\n            stops.exit().remove();\n            stops.enter().append('stop');\n\n            stops.each(function(d) {\n                var tc = tinycolor(d[1]);\n                d3.select(this).attr({\n                    offset: d[0] + '%',\n                    'stop-color': Color.tinyRGB(tc),\n                    'stop-opacity': tc.getAlpha()\n                });\n            });\n        });\n\n    sel.style(prop, getFullUrl(fullID, gd))\n        .style(prop + '-opacity', null);\n\n    sel.classed('gradient_filled', true);\n}\n\n/**\n * pattern: create and apply a pattern fill\n *\n * @param {object} sel: d3 selection to apply this pattern to\n *     You can use `selection.call(Drawing.pattern, ...)`\n * @param {string} calledBy: option to know the caller component\n * @param {DOM element} gd: the graph div `sel` is part of\n * @param {string} patternID: a unique (within this plot) identifier\n *     for this pattern, so that we don't create unnecessary definitions\n * @param {number} size: size of unit squares for repetition of this pattern\n * @param {number} solidity: how solid lines of this pattern are\n * @param {string} mcc: color when painted with colorscale\n * @param {string} fillmode: fillmode for this pattern\n * @param {string} bgcolor: background color for this pattern\n * @param {string} fgcolor: foreground color for this pattern\n * @param {number} fgopacity: foreground opacity for this pattern\n */\ndrawing.pattern = function(sel, calledBy, gd, patternID, shape, size, solidity, mcc, fillmode, bgcolor, fgcolor, fgopacity) {\n    var isLegend = calledBy === 'legend';\n\n    if(mcc) {\n        if(fillmode === 'overlay') {\n            bgcolor = mcc;\n            fgcolor = Color.contrast(bgcolor);\n        } else {\n            bgcolor = undefined;\n            fgcolor = mcc;\n        }\n    }\n\n    var fullLayout = gd._fullLayout;\n    var fullID = 'p' + fullLayout._uid + '-' + patternID;\n    var width, height;\n\n    // linear interpolation\n    var linearFn = function(x, x0, x1, y0, y1) {\n        return y0 + (y1 - y0) * (x - x0) / (x1 - x0);\n    };\n\n    var path, linewidth, radius;\n    var patternTag;\n    var patternAttrs = {};\n\n    var fgC = tinycolor(fgcolor);\n    var fgRGB = Color.tinyRGB(fgC);\n    var fgAlpha = fgC.getAlpha();\n    var opacity = fgopacity * fgAlpha;\n\n    switch(shape) {\n        case '/':\n            width = size * Math.sqrt(2);\n            height = size * Math.sqrt(2);\n            path = 'M-' + (width / 4) + ',' + (height / 4) + 'l' + (width / 2) + ',-' + (height / 2) +\n                   'M0,' + height + 'L' + width + ',0' +\n                   'M' + (width / 4 * 3) + ',' + (height / 4 * 5) + 'l' + (width / 2) + ',-' + (height / 2);\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '\\\\':\n            width = size * Math.sqrt(2);\n            height = size * Math.sqrt(2);\n            path = 'M' + (width / 4 * 3) + ',-' + (height / 4) + 'l' + (width / 2) + ',' + (height / 2) +\n                   'M0,0L' + width + ',' + height +\n                   'M-' + (width / 4) + ',' + (height / 4 * 3) + 'l' + (width / 2) + ',' + (height / 2);\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case 'x':\n            width = size * Math.sqrt(2);\n            height = size * Math.sqrt(2);\n            path = 'M-' + (width / 4) + ',' + (height / 4) + 'l' + (width / 2) + ',-' + (height / 2) +\n                   'M0,' + height + 'L' + width + ',0' +\n                   'M' + (width / 4 * 3) + ',' + (height / 4 * 5) + 'l' + (width / 2) + ',-' + (height / 2) +\n                   'M' + (width / 4 * 3) + ',-' + (height / 4) + 'l' + (width / 2) + ',' + (height / 2) +\n                   'M0,0L' + width + ',' + height +\n                   'M-' + (width / 4) + ',' + (height / 4 * 3) + 'l' + (width / 2) + ',' + (height / 2);\n            linewidth = size - size * Math.sqrt(1.0 - solidity);\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '|':\n            width = size;\n            height = size;\n            patternTag = 'path';\n            path = 'M' + (width / 2) + ',0L' + (width / 2) + ',' + height;\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '-':\n            width = size;\n            height = size;\n            patternTag = 'path';\n            path = 'M0,' + (height / 2) + 'L' + width + ',' + (height / 2);\n            linewidth = solidity * size;\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '+':\n            width = size;\n            height = size;\n            patternTag = 'path';\n            path = 'M' + (width / 2) + ',0L' + (width / 2) + ',' + height +\n                   'M0,' + (height / 2) + 'L' + width + ',' + (height / 2);\n            linewidth = size - size * Math.sqrt(1.0 - solidity);\n            patternTag = 'path';\n            patternAttrs = {\n                d: path,\n                opacity: opacity,\n                stroke: fgRGB,\n                'stroke-width': linewidth + 'px'\n            };\n            break;\n        case '.':\n            width = size;\n            height = size;\n            if(solidity < Math.PI / 4) {\n                radius = Math.sqrt(solidity * size * size / Math.PI);\n            } else {\n                radius = linearFn(solidity, Math.PI / 4, 1.0, size / 2, size / Math.sqrt(2));\n            }\n            patternTag = 'circle';\n            patternAttrs = {\n                cx: width / 2,\n                cy: height / 2,\n                r: radius,\n                opacity: opacity,\n                fill: fgRGB\n            };\n            break;\n    }\n\n    var str = [\n        shape || 'noSh',\n        bgcolor || 'noBg',\n        fgcolor || 'noFg',\n        size,\n        solidity\n    ].join(';');\n\n    var pattern = fullLayout._defs.select('.patterns')\n        .selectAll('#' + fullID)\n        .data([str], Lib.identity);\n\n    pattern.exit().remove();\n\n    pattern.enter()\n        .append('pattern')\n        .each(function() {\n            var el = d3.select(this);\n\n            el.attr({\n                id: fullID,\n                width: width + 'px',\n                height: height + 'px',\n                patternUnits: 'userSpaceOnUse',\n                // for legends scale down patterns just a bit so that default size (i.e 8) nicely fit in small icons\n                patternTransform: isLegend ? 'scale(0.8)' : ''\n            });\n\n            if(bgcolor) {\n                var bgC = tinycolor(bgcolor);\n                var bgRGB = Color.tinyRGB(bgC);\n                var bgAlpha = bgC.getAlpha();\n\n                var rects = el.selectAll('rect').data([0]);\n                rects.exit().remove();\n                rects.enter()\n                    .append('rect')\n                    .attr({\n                        width: width + 'px',\n                        height: height + 'px',\n                        fill: bgRGB,\n                        'fill-opacity': bgAlpha,\n                    });\n            }\n\n            var patterns = el.selectAll(patternTag).data([0]);\n            patterns.exit().remove();\n            patterns.enter()\n                .append(patternTag)\n                .attr(patternAttrs);\n        });\n\n    sel.style('fill', getFullUrl(fullID, gd))\n        .style('fill-opacity', null);\n\n    sel.classed('pattern_filled', true);\n};\n\n/*\n * Make the gradients container and clear out any previous gradients.\n * We never collect all the gradients we need in one place,\n * so we can't ever remove gradients that have stopped being useful,\n * except all at once before a full redraw.\n * The upside of this is arbitrary points can share gradient defs\n */\ndrawing.initGradients = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    var gradientsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'gradients');\n    gradientsGroup.selectAll('linearGradient,radialGradient').remove();\n\n    d3.select(gd).selectAll('.gradient_filled').classed('gradient_filled', false);\n};\n\ndrawing.initPatterns = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    var patternsGroup = Lib.ensureSingle(fullLayout._defs, 'g', 'patterns');\n    patternsGroup.selectAll('pattern').remove();\n\n    d3.select(gd).selectAll('.pattern_filled').classed('pattern_filled', false);\n};\n\ndrawing.getPatternAttr = function(mp, i, dflt) {\n    if(mp && Lib.isArrayOrTypedArray(mp)) {\n        return i < mp.length ? mp[i] : dflt;\n    }\n    return mp;\n};\n\ndrawing.pointStyle = function(s, trace, gd, pt) {\n    if(!s.size()) return;\n\n    var fns = drawing.makePointStyleFns(trace);\n\n    s.each(function(d) {\n        drawing.singlePointStyle(d, d3.select(this), trace, fns, gd, pt);\n    });\n};\n\ndrawing.singlePointStyle = function(d, sel, trace, fns, gd, pt) {\n    var marker = trace.marker;\n    var markerLine = marker.line;\n\n    if(pt && pt.i >= 0 && d.i === undefined) d.i = pt.i;\n\n    sel.style('opacity',\n        fns.selectedOpacityFn ? fns.selectedOpacityFn(d) :\n            (d.mo === undefined ? marker.opacity : d.mo)\n    );\n\n    if(fns.ms2mrc) {\n        var r;\n\n        // handle multi-trace graph edit case\n        if(d.ms === 'various' || marker.size === 'various') {\n            r = 3;\n        } else {\n            r = fns.ms2mrc(d.ms);\n        }\n\n        // store the calculated size so hover can use it\n        d.mrc = r;\n\n        if(fns.selectedSizeFn) {\n            r = d.mrc = fns.selectedSizeFn(d);\n        }\n\n        // turn the symbol into a sanitized number\n        var x = drawing.symbolNumber(d.mx || marker.symbol) || 0;\n\n        // save if this marker is open\n        // because that impacts how to handle colors\n        d.om = x % 200 >= 100;\n\n        var angle = getMarkerAngle(d, trace);\n        var standoff = getMarkerStandoff(d, trace);\n\n        sel.attr('d', makePointPath(x, r, angle, standoff));\n    }\n\n    var perPointGradient = false;\n    var fillColor, lineColor, lineWidth;\n\n    // 'so' is suspected outliers, for box plots\n    if(d.so) {\n        lineWidth = markerLine.outlierwidth;\n        lineColor = markerLine.outliercolor;\n        fillColor = marker.outliercolor;\n    } else {\n        var markerLineWidth = (markerLine || {}).width;\n\n        lineWidth = (\n            d.mlw + 1 ||\n            markerLineWidth + 1 ||\n            // TODO: we need the latter for legends... can we get rid of it?\n            (d.trace ? (d.trace.marker.line || {}).width : 0) + 1\n        ) - 1 || 0;\n\n        if('mlc' in d) lineColor = d.mlcc = fns.lineScale(d.mlc);\n        // weird case: array wasn't long enough to apply to every point\n        else if(Lib.isArrayOrTypedArray(markerLine.color)) lineColor = Color.defaultLine;\n        else lineColor = markerLine.color;\n\n        if(Lib.isArrayOrTypedArray(marker.color)) {\n            fillColor = Color.defaultLine;\n            perPointGradient = true;\n        }\n\n        if('mc' in d) {\n            fillColor = d.mcc = fns.markerScale(d.mc);\n        } else {\n            fillColor = marker.color || marker.colors || 'rgba(0,0,0,0)';\n        }\n\n        if(fns.selectedColorFn) {\n            fillColor = fns.selectedColorFn(d);\n        }\n    }\n\n    if(d.om) {\n        // open markers can't have zero linewidth, default to 1px,\n        // and use fill color as stroke color\n        sel.call(Color.stroke, fillColor)\n            .style({\n                'stroke-width': (lineWidth || 1) + 'px',\n                fill: 'none'\n            });\n    } else {\n        sel.style('stroke-width', (d.isBlank ? 0 : lineWidth) + 'px');\n\n        var markerGradient = marker.gradient;\n\n        var gradientType = d.mgt;\n        if(gradientType) perPointGradient = true;\n        else gradientType = markerGradient && markerGradient.type;\n\n        // for legend - arrays will propagate through here, but we don't need\n        // to treat it as per-point.\n        if(Lib.isArrayOrTypedArray(gradientType)) {\n            gradientType = gradientType[0];\n            if(!gradientInfo[gradientType]) gradientType = 0;\n        }\n\n        var markerPattern = marker.pattern;\n        var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, d.i, '');\n\n        if(gradientType && gradientType !== 'none') {\n            var gradientColor = d.mgc;\n            if(gradientColor) perPointGradient = true;\n            else gradientColor = markerGradient.color;\n\n            var gradientID = trace.uid;\n            if(perPointGradient) gradientID += '-' + d.i;\n\n            drawing.gradient(sel, gd, gradientID, gradientType,\n                [[0, gradientColor], [1, fillColor]], 'fill');\n        } else if(patternShape) {\n            var perPointPattern = false;\n            var fgcolor = markerPattern.fgcolor;\n            if(!fgcolor && pt && pt.color) {\n                fgcolor = pt.color;\n                perPointPattern = true;\n            }\n            var patternFGColor = drawing.getPatternAttr(fgcolor, d.i, (pt && pt.color) || null);\n\n            var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, d.i, null);\n            var patternFGOpacity = markerPattern.fgopacity;\n            var patternSize = drawing.getPatternAttr(markerPattern.size, d.i, 8);\n            var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, d.i, 0.3);\n            perPointPattern = perPointPattern || d.mcc ||\n                Lib.isArrayOrTypedArray(markerPattern.shape) ||\n                Lib.isArrayOrTypedArray(markerPattern.bgcolor) ||\n                Lib.isArrayOrTypedArray(markerPattern.fgcolor) ||\n                Lib.isArrayOrTypedArray(markerPattern.size) ||\n                Lib.isArrayOrTypedArray(markerPattern.solidity);\n\n            var patternID = trace.uid;\n            if(perPointPattern) patternID += '-' + d.i;\n\n            drawing.pattern(\n                sel, 'point', gd, patternID,\n                patternShape, patternSize, patternSolidity,\n                d.mcc, markerPattern.fillmode,\n                patternBGColor, patternFGColor, patternFGOpacity\n            );\n        } else {\n            Lib.isArrayOrTypedArray(fillColor) ? Color.fill(sel, fillColor[d.i]) : Color.fill(sel, fillColor);\n        }\n\n        if(lineWidth) {\n            Color.stroke(sel, lineColor);\n        }\n    }\n};\n\ndrawing.makePointStyleFns = function(trace) {\n    var out = {};\n    var marker = trace.marker;\n\n    // allow array marker and marker line colors to be\n    // scaled by given max and min to colorscales\n    out.markerScale = drawing.tryColorscale(marker, '');\n    out.lineScale = drawing.tryColorscale(marker, 'line');\n\n    if(Registry.traceIs(trace, 'symbols')) {\n        out.ms2mrc = subTypes.isBubble(trace) ?\n            makeBubbleSizeFn(trace) :\n            function() { return (marker.size || 6) / 2; };\n    }\n\n    if(trace.selectedpoints) {\n        Lib.extendFlat(out, drawing.makeSelectedPointStyleFns(trace));\n    }\n\n    return out;\n};\n\ndrawing.makeSelectedPointStyleFns = function(trace) {\n    var out = {};\n\n    var selectedAttrs = trace.selected || {};\n    var unselectedAttrs = trace.unselected || {};\n\n    var marker = trace.marker || {};\n    var selectedMarker = selectedAttrs.marker || {};\n    var unselectedMarker = unselectedAttrs.marker || {};\n\n    var mo = marker.opacity;\n    var smo = selectedMarker.opacity;\n    var usmo = unselectedMarker.opacity;\n    var smoIsDefined = smo !== undefined;\n    var usmoIsDefined = usmo !== undefined;\n\n    if(Lib.isArrayOrTypedArray(mo) || smoIsDefined || usmoIsDefined) {\n        out.selectedOpacityFn = function(d) {\n            var base = d.mo === undefined ? marker.opacity : d.mo;\n\n            if(d.selected) {\n                return smoIsDefined ? smo : base;\n            } else {\n                return usmoIsDefined ? usmo : DESELECTDIM * base;\n            }\n        };\n    }\n\n    var mc = marker.color;\n    var smc = selectedMarker.color;\n    var usmc = unselectedMarker.color;\n\n    if(smc || usmc) {\n        out.selectedColorFn = function(d) {\n            var base = d.mcc || mc;\n\n            if(d.selected) {\n                return smc || base;\n            } else {\n                return usmc || base;\n            }\n        };\n    }\n\n    var ms = marker.size;\n    var sms = selectedMarker.size;\n    var usms = unselectedMarker.size;\n    var smsIsDefined = sms !== undefined;\n    var usmsIsDefined = usms !== undefined;\n\n    if(Registry.traceIs(trace, 'symbols') && (smsIsDefined || usmsIsDefined)) {\n        out.selectedSizeFn = function(d) {\n            var base = d.mrc || ms / 2;\n\n            if(d.selected) {\n                return smsIsDefined ? sms / 2 : base;\n            } else {\n                return usmsIsDefined ? usms / 2 : base;\n            }\n        };\n    }\n\n    return out;\n};\n\ndrawing.makeSelectedTextStyleFns = function(trace) {\n    var out = {};\n\n    var selectedAttrs = trace.selected || {};\n    var unselectedAttrs = trace.unselected || {};\n\n    var textFont = trace.textfont || {};\n    var selectedTextFont = selectedAttrs.textfont || {};\n    var unselectedTextFont = unselectedAttrs.textfont || {};\n\n    var tc = textFont.color;\n    var stc = selectedTextFont.color;\n    var utc = unselectedTextFont.color;\n\n    out.selectedTextColorFn = function(d) {\n        var base = d.tc || tc;\n\n        if(d.selected) {\n            return stc || base;\n        } else {\n            if(utc) return utc;\n            else return stc ? base : Color.addOpacity(base, DESELECTDIM);\n        }\n    };\n\n    return out;\n};\n\ndrawing.selectedPointStyle = function(s, trace) {\n    if(!s.size() || !trace.selectedpoints) return;\n\n    var fns = drawing.makeSelectedPointStyleFns(trace);\n    var marker = trace.marker || {};\n    var seq = [];\n\n    if(fns.selectedOpacityFn) {\n        seq.push(function(pt, d) {\n            pt.style('opacity', fns.selectedOpacityFn(d));\n        });\n    }\n\n    if(fns.selectedColorFn) {\n        seq.push(function(pt, d) {\n            Color.fill(pt, fns.selectedColorFn(d));\n        });\n    }\n\n    if(fns.selectedSizeFn) {\n        seq.push(function(pt, d) {\n            var mx = d.mx || marker.symbol || 0;\n            var mrc2 = fns.selectedSizeFn(d);\n\n            pt.attr('d', makePointPath(drawing.symbolNumber(mx), mrc2, getMarkerAngle(d, trace), getMarkerStandoff(d, trace)));\n\n            // save for Drawing.selectedTextStyle\n            d.mrc2 = mrc2;\n        });\n    }\n\n    if(seq.length) {\n        s.each(function(d) {\n            var pt = d3.select(this);\n            for(var i = 0; i < seq.length; i++) {\n                seq[i](pt, d);\n            }\n        });\n    }\n};\n\ndrawing.tryColorscale = function(marker, prefix) {\n    var cont = prefix ? Lib.nestedProperty(marker, prefix).get() : marker;\n\n    if(cont) {\n        var colorArray = cont.color;\n        if((cont.colorscale || cont._colorAx) && Lib.isArrayOrTypedArray(colorArray)) {\n            return Colorscale.makeColorScaleFuncFromTrace(cont);\n        }\n    }\n    return Lib.identity;\n};\n\nvar TEXTOFFSETSIGN = {\n    start: 1, end: -1, middle: 0, bottom: 1, top: -1\n};\n\nfunction textPointPosition(s, textPosition, fontSize, markerRadius, dontTouchParent) {\n    var group = d3.select(s.node().parentNode);\n\n    var v = textPosition.indexOf('top') !== -1 ?\n        'top' :\n        textPosition.indexOf('bottom') !== -1 ? 'bottom' : 'middle';\n    var h = textPosition.indexOf('left') !== -1 ?\n        'end' :\n        textPosition.indexOf('right') !== -1 ? 'start' : 'middle';\n\n    // if markers are shown, offset a little more than\n    // the nominal marker size\n    // ie 2/1.6 * nominal, bcs some markers are a bit bigger\n    var r = markerRadius ? markerRadius / 0.8 + 1 : 0;\n\n    var numLines = (svgTextUtils.lineCount(s) - 1) * LINE_SPACING + 1;\n    var dx = TEXTOFFSETSIGN[h] * r;\n    var dy = fontSize * 0.75 + TEXTOFFSETSIGN[v] * r +\n        (TEXTOFFSETSIGN[v] - 1) * numLines * fontSize / 2;\n\n    // fix the overall text group position\n    s.attr('text-anchor', h);\n    if(!dontTouchParent) {\n        group.attr('transform', strTranslate(dx, dy));\n    }\n}\n\nfunction extracTextFontSize(d, trace) {\n    var fontSize = d.ts || trace.textfont.size;\n    return (isNumeric(fontSize) && fontSize > 0) ? fontSize : 0;\n}\n\n// draw text at points\ndrawing.textPointStyle = function(s, trace, gd) {\n    if(!s.size()) return;\n\n    var selectedTextColorFn;\n    if(trace.selectedpoints) {\n        var fns = drawing.makeSelectedTextStyleFns(trace);\n        selectedTextColorFn = fns.selectedTextColorFn;\n    }\n\n    var texttemplate = trace.texttemplate;\n    var fullLayout = gd._fullLayout;\n\n    s.each(function(d) {\n        var p = d3.select(this);\n\n        var text = texttemplate ?\n            Lib.extractOption(d, trace, 'txt', 'texttemplate') :\n            Lib.extractOption(d, trace, 'tx', 'text');\n\n        if(!text && text !== 0) {\n            p.remove();\n            return;\n        }\n\n        if(texttemplate) {\n            var fn = trace._module.formatLabels;\n            var labels = fn ? fn(d, trace, fullLayout) : {};\n            var pointValues = {};\n            appendArrayPointValue(pointValues, trace, d.i);\n            var meta = trace._meta || {};\n            text = Lib.texttemplateString(text, labels, fullLayout._d3locale, pointValues, d, meta);\n        }\n\n        var pos = d.tp || trace.textposition;\n        var fontSize = extracTextFontSize(d, trace);\n        var fontColor = selectedTextColorFn ?\n            selectedTextColorFn(d) :\n            (d.tc || trace.textfont.color);\n\n        p.call(drawing.font,\n                d.tf || trace.textfont.family,\n                fontSize,\n                fontColor)\n            .text(text)\n            .call(svgTextUtils.convertToTspans, gd)\n            .call(textPointPosition, pos, fontSize, d.mrc);\n    });\n};\n\ndrawing.selectedTextStyle = function(s, trace) {\n    if(!s.size() || !trace.selectedpoints) return;\n\n    var fns = drawing.makeSelectedTextStyleFns(trace);\n\n    s.each(function(d) {\n        var tx = d3.select(this);\n        var tc = fns.selectedTextColorFn(d);\n        var tp = d.tp || trace.textposition;\n        var fontSize = extracTextFontSize(d, trace);\n\n        Color.fill(tx, tc);\n        var dontTouchParent = Registry.traceIs(trace, 'bar-like');\n        textPointPosition(tx, tp, fontSize, d.mrc2 || d.mrc, dontTouchParent);\n    });\n};\n\n// generalized Catmull-Rom splines, per\n// http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\nvar CatmullRomExp = 0.5;\ndrawing.smoothopen = function(pts, smoothness) {\n    if(pts.length < 3) { return 'M' + pts.join('L');}\n    var path = 'M' + pts[0];\n    var tangents = [];\n    var i;\n    for(i = 1; i < pts.length - 1; i++) {\n        tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n    }\n    path += 'Q' + tangents[0][0] + ' ' + pts[1];\n    for(i = 2; i < pts.length - 1; i++) {\n        path += 'C' + tangents[i - 2][1] + ' ' + tangents[i - 1][0] + ' ' + pts[i];\n    }\n    path += 'Q' + tangents[pts.length - 3][1] + ' ' + pts[pts.length - 1];\n    return path;\n};\n\ndrawing.smoothclosed = function(pts, smoothness) {\n    if(pts.length < 3) { return 'M' + pts.join('L') + 'Z'; }\n    var path = 'M' + pts[0];\n    var pLast = pts.length - 1;\n    var tangents = [makeTangent(pts[pLast], pts[0], pts[1], smoothness)];\n    var i;\n    for(i = 1; i < pLast; i++) {\n        tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));\n    }\n    tangents.push(\n        makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness)\n    );\n\n    for(i = 1; i <= pLast; i++) {\n        path += 'C' + tangents[i - 1][1] + ' ' + tangents[i][0] + ' ' + pts[i];\n    }\n    path += 'C' + tangents[pLast][1] + ' ' + tangents[0][0] + ' ' + pts[0] + 'Z';\n    return path;\n};\n\nvar lastDrawnX, lastDrawnY;\n\nfunction roundEnd(pt, isY, isLastPoint) {\n    if(isLastPoint) pt = applyBackoff(pt);\n\n    return isY ? roundY(pt[1]) : roundX(pt[0]);\n}\n\nfunction roundX(p) {\n    var v = d3.round(p, 2);\n    lastDrawnX = v;\n    return v;\n}\n\nfunction roundY(p) {\n    var v = d3.round(p, 2);\n    lastDrawnY = v;\n    return v;\n}\n\nfunction makeTangent(prevpt, thispt, nextpt, smoothness) {\n    var d1x = prevpt[0] - thispt[0];\n    var d1y = prevpt[1] - thispt[1];\n    var d2x = nextpt[0] - thispt[0];\n    var d2y = nextpt[1] - thispt[1];\n    var d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2);\n    var d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2);\n    var numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness;\n    var numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness;\n    var denom1 = 3 * d2a * (d1a + d2a);\n    var denom2 = 3 * d1a * (d1a + d2a);\n    return [\n        [\n            roundX(thispt[0] + (denom1 && numx / denom1)),\n            roundY(thispt[1] + (denom1 && numy / denom1))\n        ], [\n            roundX(thispt[0] - (denom2 && numx / denom2)),\n            roundY(thispt[1] - (denom2 && numy / denom2))\n        ]\n    ];\n}\n\n// step paths - returns a generator function for paths\n// with the given step shape\nvar STEPPATH = {\n    hv: function(p0, p1, isLastPoint) {\n        return 'H' +\n            roundX(p1[0]) + 'V' +\n            roundEnd(p1, 1, isLastPoint);\n    },\n    vh: function(p0, p1, isLastPoint) {\n        return 'V' +\n            roundY(p1[1]) + 'H' +\n            roundEnd(p1, 0, isLastPoint);\n    },\n    hvh: function(p0, p1, isLastPoint) {\n        return 'H' +\n            roundX((p0[0] + p1[0]) / 2) + 'V' +\n            roundY(p1[1]) + 'H' +\n            roundEnd(p1, 0, isLastPoint);\n    },\n    vhv: function(p0, p1, isLastPoint) {\n        return 'V' +\n            roundY((p0[1] + p1[1]) / 2) + 'H' +\n            roundX(p1[0]) + 'V' +\n            roundEnd(p1, 1, isLastPoint);\n    }\n};\nvar STEPLINEAR = function(p0, p1, isLastPoint) {\n    return 'L' +\n        roundEnd(p1, 0, isLastPoint) + ',' +\n        roundEnd(p1, 1, isLastPoint);\n};\ndrawing.steps = function(shape) {\n    var onestep = STEPPATH[shape] || STEPLINEAR;\n    return function(pts) {\n        var path = 'M' + roundX(pts[0][0]) + ',' + roundY(pts[0][1]);\n        var len = pts.length;\n        for(var i = 1; i < len; i++) {\n            path += onestep(pts[i - 1], pts[i], i === len - 1);\n        }\n        return path;\n    };\n};\n\nfunction applyBackoff(pt, start) {\n    var backoff = pt.backoff;\n    var trace = pt.trace;\n    var d = pt.d;\n    var i = pt.i;\n\n    if(backoff && trace &&\n        trace.marker &&\n        trace.marker.angle % 360 === 0 &&\n        trace.line &&\n        trace.line.shape !== 'spline'\n    ) {\n        var arrayBackoff = Lib.isArrayOrTypedArray(backoff);\n        var end = pt;\n\n        var x1 = start ? start[0] : lastDrawnX || 0;\n        var y1 = start ? start[1] : lastDrawnY || 0;\n\n        var x2 = end[0];\n        var y2 = end[1];\n\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n\n        var t = Math.atan2(dy, dx);\n\n        var b = arrayBackoff ? backoff[i] : backoff;\n\n        if(b === 'auto') {\n            var endI = end.i;\n            if(trace.type === 'scatter') endI--; // Why we need this hack?\n\n            var endMarker = end.marker;\n            var endMarkerSymbol = endMarker.symbol;\n            if(Lib.isArrayOrTypedArray(endMarkerSymbol)) endMarkerSymbol = endMarkerSymbol[endI];\n\n            var endMarkerSize = endMarker.size;\n            if(Lib.isArrayOrTypedArray(endMarkerSize)) endMarkerSize = endMarkerSize[endI];\n\n            b = endMarker ? drawing.symbolBackOffs[drawing.symbolNumber(endMarkerSymbol)] * endMarkerSize : 0;\n            b += drawing.getMarkerStandoff(d[endI], trace) || 0;\n        }\n\n        var x = x2 - b * Math.cos(t);\n        var y = y2 - b * Math.sin(t);\n\n        if(\n            ((x <= x2 && x >= x1) || (x >= x2 && x <= x1)) &&\n            ((y <= y2 && y >= y1) || (y >= y2 && y <= y1))\n        ) {\n            pt = [x, y];\n        }\n    }\n\n    return pt;\n}\n\ndrawing.applyBackoff = applyBackoff;\n\n// off-screen svg render testing element, shared by the whole page\n// uses the id 'js-plotly-tester' and stores it in drawing.tester\ndrawing.makeTester = function() {\n    var tester = Lib.ensureSingleById(d3.select('body'), 'svg', 'js-plotly-tester', function(s) {\n        s.attr(xmlnsNamespaces.svgAttrs)\n            .style({\n                position: 'absolute',\n                left: '-10000px',\n                top: '-10000px',\n                width: '9000px',\n                height: '9000px',\n                'z-index': '1'\n            });\n    });\n\n    // browsers differ on how they describe the bounding rect of\n    // the svg if its contents spill over... so make a 1x1px\n    // reference point we can measure off of.\n    var testref = Lib.ensureSingle(tester, 'path', 'js-reference-point', function(s) {\n        s.attr('d', 'M0,0H1V1H0Z')\n            .style({\n                'stroke-width': 0,\n                fill: 'black'\n            });\n    });\n\n    drawing.tester = tester;\n    drawing.testref = testref;\n};\n\n/*\n * use our offscreen tester to get a clientRect for an element,\n * in a reference frame where it isn't translated (or transformed) and\n * its anchor point is at (0,0)\n * always returns a copy of the bbox, so the caller can modify it safely\n *\n * @param {SVGElement} node: the element to measure. If possible this should be\n *   a <text> or MathJax <g> element that's already passed through\n *   `convertToTspans` because in that case we can cache the results, but it's\n *   possible to pass in any svg element.\n *\n * @param {boolean} inTester: is this element already in `drawing.tester`?\n *   If you are measuring a dummy element, rather than one you really intend\n *   to use on the plot, making it in `drawing.tester` in the first place\n *   allows us to test faster because it cuts out cloning and appending it.\n *\n * @param {string} hash: for internal use only, if we already know the cache key\n *   for this element beforehand.\n *\n * @return {object}: a plain object containing the width, height, left, right,\n *   top, and bottom of `node`\n */\ndrawing.savedBBoxes = {};\nvar savedBBoxesCount = 0;\nvar maxSavedBBoxes = 10000;\n\ndrawing.bBox = function(node, inTester, hash) {\n    /*\n     * Cache elements we've already measured so we don't have to\n     * remeasure the same thing many times\n     * We have a few bBox callers though who pass a node larger than\n     * a <text> or a MathJax <g>, such as an axis group containing many labels.\n     * These will not generate a hash (unless we figure out an appropriate\n     * hash key for them) and thus we will not hash them.\n     */\n    if(!hash) hash = nodeHash(node);\n    var out;\n    if(hash) {\n        out = drawing.savedBBoxes[hash];\n        if(out) return Lib.extendFlat({}, out);\n    } else if(node.childNodes.length === 1) {\n        /*\n         * If we have only one child element, which is itself hashable, make\n         * a new hash from this element plus its x,y,transform\n         * These bounding boxes *include* x,y,transform - mostly for use by\n         * callers trying to avoid overlaps (ie titles)\n         */\n        var innerNode = node.childNodes[0];\n\n        hash = nodeHash(innerNode);\n        if(hash) {\n            var x = +innerNode.getAttribute('x') || 0;\n            var y = +innerNode.getAttribute('y') || 0;\n            var transform = innerNode.getAttribute('transform');\n\n            if(!transform) {\n                // in this case, just varying x and y, don't bother caching\n                // the final bBox because the alteration is quick.\n                var innerBB = drawing.bBox(innerNode, false, hash);\n                if(x) {\n                    innerBB.left += x;\n                    innerBB.right += x;\n                }\n                if(y) {\n                    innerBB.top += y;\n                    innerBB.bottom += y;\n                }\n                return innerBB;\n            }\n            /*\n             * else we have a transform - rather than make a complicated\n             * (and error-prone and probably slow) transform parser/calculator,\n             * just continue on calculating the boundingClientRect of the group\n             * and use the new composite hash to cache it.\n             * That said, `innerNode.transform.baseVal` is an array of\n             * `SVGTransform` objects, that *do* seem to have a nice matrix\n             * multiplication interface that we could use to avoid making\n             * another getBoundingClientRect call...\n             */\n            hash += '~' + x + '~' + y + '~' + transform;\n\n            out = drawing.savedBBoxes[hash];\n            if(out) return Lib.extendFlat({}, out);\n        }\n    }\n    var testNode, tester;\n    if(inTester) {\n        testNode = node;\n    } else {\n        tester = drawing.tester.node();\n\n        // copy the node to test into the tester\n        testNode = node.cloneNode(true);\n        tester.appendChild(testNode);\n    }\n\n    // standardize its position (and newline tspans if any)\n    d3.select(testNode)\n        .attr('transform', null)\n        .call(svgTextUtils.positionText, 0, 0);\n\n    var testRect = testNode.getBoundingClientRect();\n    var refRect = drawing.testref\n        .node()\n        .getBoundingClientRect();\n\n    if(!inTester) tester.removeChild(testNode);\n\n    var bb = {\n        height: testRect.height,\n        width: testRect.width,\n        left: testRect.left - refRect.left,\n        top: testRect.top - refRect.top,\n        right: testRect.right - refRect.left,\n        bottom: testRect.bottom - refRect.top\n    };\n\n    // make sure we don't have too many saved boxes,\n    // or a long session could overload on memory\n    // by saving boxes for long-gone elements\n    if(savedBBoxesCount >= maxSavedBBoxes) {\n        drawing.savedBBoxes = {};\n        savedBBoxesCount = 0;\n    }\n\n    // cache this bbox\n    if(hash) drawing.savedBBoxes[hash] = bb;\n    savedBBoxesCount++;\n\n    return Lib.extendFlat({}, bb);\n};\n\n// capture everything about a node (at least in our usage) that\n// impacts its bounding box, given that bBox clears x, y, and transform\nfunction nodeHash(node) {\n    var inputText = node.getAttribute('data-unformatted');\n    if(inputText === null) return;\n    return inputText +\n        node.getAttribute('data-math') +\n        node.getAttribute('text-anchor') +\n        node.getAttribute('style');\n}\n\n/**\n * Set clipPath URL in a way that work for all situations.\n *\n * In details, graphs on pages with <base> HTML tags need to prepend\n * the clip path ids with the page's base url EXCEPT during toImage exports.\n *\n * @param {d3 selection} s : node to add clip-path attribute\n * @param {string} localId : local clip-path (w/o base url) id\n * @param {DOM element || object} gd\n * - context._baseUrl {string}\n * - context._exportedPlot {boolean}\n */\ndrawing.setClipUrl = function(s, localId, gd) {\n    s.attr('clip-path', getFullUrl(localId, gd));\n};\n\nfunction getFullUrl(localId, gd) {\n    if(!localId) return null;\n\n    var context = gd._context;\n    var baseUrl = context._exportedPlot ? '' : (context._baseUrl || '');\n    return baseUrl ?\n        'url(\\'' + baseUrl + '#' + localId + '\\')' :\n        'url(#' + localId + ')';\n}\n\ndrawing.getTranslate = function(element) {\n    // Note the separator [^\\d] between x and y in this regex\n    // We generally use ',' but IE will convert it to ' '\n    var re = /.*\\btranslate\\((-?\\d*\\.?\\d*)[^-\\d]*(-?\\d*\\.?\\d*)[^\\d].*/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var transform = element[getter]('transform') || '';\n\n    var translate = transform.replace(re, function(match, p1, p2) {\n        return [p1, p2].join(' ');\n    })\n    .split(' ');\n\n    return {\n        x: +translate[0] || 0,\n        y: +translate[1] || 0\n    };\n};\n\ndrawing.setTranslate = function(element, x, y) {\n    var re = /(\\btranslate\\(.*?\\);?)/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var setter = element.attr ? 'attr' : 'setAttribute';\n    var transform = element[getter]('transform') || '';\n\n    x = x || 0;\n    y = y || 0;\n\n    transform = transform.replace(re, '').trim();\n    transform += strTranslate(x, y);\n    transform = transform.trim();\n\n    element[setter]('transform', transform);\n\n    return transform;\n};\n\ndrawing.getScale = function(element) {\n    var re = /.*\\bscale\\((\\d*\\.?\\d*)[^\\d]*(\\d*\\.?\\d*)[^\\d].*/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var transform = element[getter]('transform') || '';\n\n    var translate = transform.replace(re, function(match, p1, p2) {\n        return [p1, p2].join(' ');\n    })\n    .split(' ');\n\n    return {\n        x: +translate[0] || 1,\n        y: +translate[1] || 1\n    };\n};\n\ndrawing.setScale = function(element, x, y) {\n    var re = /(\\bscale\\(.*?\\);?)/;\n    var getter = element.attr ? 'attr' : 'getAttribute';\n    var setter = element.attr ? 'attr' : 'setAttribute';\n    var transform = element[getter]('transform') || '';\n\n    x = x || 1;\n    y = y || 1;\n\n    transform = transform.replace(re, '').trim();\n    transform += 'scale(' + x + ',' + y + ')';\n    transform = transform.trim();\n\n    element[setter]('transform', transform);\n\n    return transform;\n};\n\nvar SCALE_RE = /\\s*sc.*/;\n\ndrawing.setPointGroupScale = function(selection, xScale, yScale) {\n    xScale = xScale || 1;\n    yScale = yScale || 1;\n\n    if(!selection) return;\n\n    // The same scale transform for every point:\n    var scale = (xScale === 1 && yScale === 1) ?\n        '' :\n        'scale(' + xScale + ',' + yScale + ')';\n\n    selection.each(function() {\n        var t = (this.getAttribute('transform') || '').replace(SCALE_RE, '');\n        t += scale;\n        t = t.trim();\n        this.setAttribute('transform', t);\n    });\n};\n\nvar TEXT_POINT_LAST_TRANSLATION_RE = /translate\\([^)]*\\)\\s*$/;\n\ndrawing.setTextPointsScale = function(selection, xScale, yScale) {\n    if(!selection) return;\n\n    selection.each(function() {\n        var transforms;\n        var el = d3.select(this);\n        var text = el.select('text');\n\n        if(!text.node()) return;\n\n        var x = parseFloat(text.attr('x') || 0);\n        var y = parseFloat(text.attr('y') || 0);\n\n        var existingTransform = (el.attr('transform') || '').match(TEXT_POINT_LAST_TRANSLATION_RE);\n\n        if(xScale === 1 && yScale === 1) {\n            transforms = [];\n        } else {\n            transforms = [\n                strTranslate(x, y),\n                'scale(' + xScale + ',' + yScale + ')',\n                strTranslate(-x, -y),\n            ];\n        }\n\n        if(existingTransform) {\n            transforms.push(existingTransform);\n        }\n\n        el.attr('transform', transforms.join(''));\n    });\n};\n\nfunction getMarkerStandoff(d, trace) {\n    var standoff;\n\n    if(d) standoff = d.mf;\n\n    if(standoff === undefined) {\n        standoff = trace.marker ? trace.marker.standoff || 0 : 0;\n    }\n\n    if(!trace._geo && !trace._xA) {\n        // case of legends\n        return -standoff;\n    }\n\n    return standoff;\n}\n\ndrawing.getMarkerStandoff = getMarkerStandoff;\n\nvar atan2 = Math.atan2;\nvar cos = Math.cos;\nvar sin = Math.sin;\n\nfunction rotate(t, xy) {\n    var x = xy[0];\n    var y = xy[1];\n    return [\n        x * cos(t) - y * sin(t),\n        x * sin(t) + y * cos(t)\n    ];\n}\n\nvar previousLon;\nvar previousLat;\nvar previousX;\nvar previousY;\nvar previousI;\nvar previousTraceUid;\n\nfunction getMarkerAngle(d, trace) {\n    var angle = d.ma;\n\n    if(angle === undefined) {\n        angle = trace.marker.angle;\n        if(!angle || Lib.isArrayOrTypedArray(angle)) {\n            angle = 0;\n        }\n    }\n\n    var x, y;\n    var ref = trace.marker.angleref;\n    if(ref === 'previous' || ref === 'north') {\n        if(trace._geo) {\n            var p = trace._geo.project(d.lonlat);\n            x = p[0];\n            y = p[1];\n        } else {\n            var xa = trace._xA;\n            var ya = trace._yA;\n            if(xa && ya) {\n                x = xa.c2p(d.x);\n                y = ya.c2p(d.y);\n            } else {\n                // case of legends\n                return 90;\n            }\n        }\n\n        if(trace._geo) {\n            var lon = d.lonlat[0];\n            var lat = d.lonlat[1];\n\n            var north = trace._geo.project([\n                lon,\n                lat + 1e-5 // epsilon\n            ]);\n\n            var east = trace._geo.project([\n                lon + 1e-5, // epsilon\n                lat\n            ]);\n\n            var u = atan2(\n                east[1] - y,\n                east[0] - x\n            );\n\n            var v = atan2(\n                north[1] - y,\n                north[0] - x\n            );\n\n            var t;\n            if(ref === 'north') {\n                t = angle / 180 * Math.PI;\n                // To use counter-clockwise angles i.e.\n                // East: 90, West: -90\n                // to facilitate wind visualisations\n                // in future we should use t = -t here.\n            } else if(ref === 'previous') {\n                var lon1 = lon / 180 * Math.PI;\n                var lat1 = lat / 180 * Math.PI;\n                var lon2 = previousLon / 180 * Math.PI;\n                var lat2 = previousLat / 180 * Math.PI;\n\n                var dLon = lon2 - lon1;\n\n                var deltaY = cos(lat2) * sin(dLon);\n                var deltaX = sin(lat2) * cos(lat1) - cos(lat2) * sin(lat1) * cos(dLon);\n\n                t = -atan2(\n                    deltaY,\n                    deltaX\n                ) - Math.PI;\n\n                previousLon = lon;\n                previousLat = lat;\n            }\n\n            var A = rotate(u, [cos(t), 0]);\n            var B = rotate(v, [sin(t), 0]);\n\n            angle = atan2(\n                A[1] + B[1],\n                A[0] + B[0]\n            ) / Math.PI * 180;\n\n            if(ref === 'previous' && !(\n                previousTraceUid === trace.uid &&\n                d.i === previousI + 1\n            )) {\n                angle = null;\n            }\n        }\n\n        if(ref === 'previous' && !trace._geo) {\n            if(\n                previousTraceUid === trace.uid &&\n                d.i === previousI + 1 &&\n                isNumeric(x) &&\n                isNumeric(y)\n            ) {\n                var dX = x - previousX;\n                var dY = y - previousY;\n\n                var shape = trace.line ? trace.line.shape || '' : '';\n\n                var lastShapeChar = shape.slice(shape.length - 1);\n                if(lastShapeChar === 'h') dY = 0;\n                if(lastShapeChar === 'v') dX = 0;\n\n                angle += atan2(dY, dX) / Math.PI * 180 + 90;\n            } else {\n                angle = null;\n            }\n        }\n    }\n\n    previousX = x;\n    previousY = y;\n    previousI = d.i;\n    previousTraceUid = trace.uid;\n\n    return angle;\n}\n\ndrawing.getMarkerAngle = getMarkerAngle;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}