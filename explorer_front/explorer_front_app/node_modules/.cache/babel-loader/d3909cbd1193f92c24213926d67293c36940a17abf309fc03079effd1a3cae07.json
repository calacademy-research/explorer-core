{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar d3 = require('@plotly/d3');\nvar Registry = require('../registry');\nvar Plots = require('../plots/plots');\nvar Lib = require('../lib');\nvar svgTextUtils = require('../lib/svg_text_utils');\nvar clearGlCanvases = require('../lib/clear_gl_canvases');\nvar Color = require('../components/color');\nvar Drawing = require('../components/drawing');\nvar Titles = require('../components/titles');\nvar ModeBar = require('../components/modebar');\nvar Axes = require('../plots/cartesian/axes');\nvar alignmentConstants = require('../constants/alignment');\nvar axisConstraints = require('../plots/cartesian/constraints');\nvar enforceAxisConstraints = axisConstraints.enforce;\nvar cleanAxisConstraints = axisConstraints.clean;\nvar doAutoRange = require('../plots/cartesian/autorange').doAutoRange;\nvar SVG_TEXT_ANCHOR_START = 'start';\nvar SVG_TEXT_ANCHOR_MIDDLE = 'middle';\nvar SVG_TEXT_ANCHOR_END = 'end';\nexports.layoutStyles = function (gd) {\n  return Lib.syncOrAsync([Plots.doAutoMargin, lsInner], gd);\n};\nfunction overlappingDomain(xDomain, yDomain, domains) {\n  for (var i = 0; i < domains.length; i++) {\n    var existingX = domains[i][0];\n    var existingY = domains[i][1];\n    if (existingX[0] >= xDomain[1] || existingX[1] <= xDomain[0]) {\n      continue;\n    }\n    if (existingY[0] < yDomain[1] && existingY[1] > yDomain[0]) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction lsInner(gd) {\n  var fullLayout = gd._fullLayout;\n  var gs = fullLayout._size;\n  var pad = gs.p;\n  var axList = Axes.list(gd, '', true);\n  var i, subplot, plotinfo, ax, xa, ya;\n  fullLayout._paperdiv.style({\n    width: gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroWidth && !gd.layout.width ? '100%' : fullLayout.width + 'px',\n    height: gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroHeight && !gd.layout.height ? '100%' : fullLayout.height + 'px'\n  }).selectAll('.main-svg').call(Drawing.setSize, fullLayout.width, fullLayout.height);\n  gd._context.setBackground(gd, fullLayout.paper_bgcolor);\n  exports.drawMainTitle(gd);\n  ModeBar.manage(gd);\n\n  // _has('cartesian') means SVG specifically, not GL2D - but GL2D\n  // can still get here because it makes some of the SVG structure\n  // for shared features like selections.\n  if (!fullLayout._has('cartesian')) {\n    return Plots.previousPromises(gd);\n  }\n  function getLinePosition(ax, counterAx, side) {\n    var lwHalf = ax._lw / 2;\n    if (ax._id.charAt(0) === 'x') {\n      if (!counterAx) return gs.t + gs.h * (1 - (ax.position || 0)) + lwHalf % 1;else if (side === 'top') return counterAx._offset - pad - lwHalf;\n      return counterAx._offset + counterAx._length + pad + lwHalf;\n    }\n    if (!counterAx) return gs.l + gs.w * (ax.position || 0) + lwHalf % 1;else if (side === 'right') return counterAx._offset + counterAx._length + pad + lwHalf;\n    return counterAx._offset - pad - lwHalf;\n  }\n\n  // some preparation of axis position info\n  for (i = 0; i < axList.length; i++) {\n    ax = axList[i];\n    var counterAx = ax._anchorAxis;\n\n    // clear axis line positions, to be set in the subplot loop below\n    ax._linepositions = {};\n\n    // stash crispRounded linewidth so we don't need to pass gd all over the place\n    ax._lw = Drawing.crispRound(gd, ax.linewidth, 1);\n\n    // figure out the main axis line and main mirror line position.\n    // it's easier to follow the logic if we handle these separately from\n    // ax._linepositions, which are only used by mirror=allticks\n    // for non-main-subplot ticks, and mirror=all(ticks)? for zero line\n    // hiding logic\n    ax._mainLinePosition = getLinePosition(ax, counterAx, ax.side);\n    ax._mainMirrorPosition = ax.mirror && counterAx ? getLinePosition(ax, counterAx, alignmentConstants.OPPOSITE_SIDE[ax.side]) : null;\n  }\n\n  // figure out which backgrounds we need to draw,\n  // and in which layers to put them\n  var lowerBackgroundIDs = [];\n  var backgroundIds = [];\n  var lowerDomains = [];\n  // no need to draw background when paper and plot color are the same color,\n  // activate mode just for large splom (which benefit the most from this\n  // optimization), but this could apply to all cartesian subplots.\n  var noNeedForBg = Color.opacity(fullLayout.paper_bgcolor) === 1 && Color.opacity(fullLayout.plot_bgcolor) === 1 && fullLayout.paper_bgcolor === fullLayout.plot_bgcolor;\n  for (subplot in fullLayout._plots) {\n    plotinfo = fullLayout._plots[subplot];\n    if (plotinfo.mainplot) {\n      // mainplot is a reference to the main plot this one is overlaid on\n      // so if it exists, this is an overlaid plot and we don't need to\n      // give it its own background\n      if (plotinfo.bg) {\n        plotinfo.bg.remove();\n      }\n      plotinfo.bg = undefined;\n    } else {\n      var xDomain = plotinfo.xaxis.domain;\n      var yDomain = plotinfo.yaxis.domain;\n      var plotgroup = plotinfo.plotgroup;\n      if (overlappingDomain(xDomain, yDomain, lowerDomains)) {\n        var pgNode = plotgroup.node();\n        var plotgroupBg = plotinfo.bg = Lib.ensureSingle(plotgroup, 'rect', 'bg');\n        pgNode.insertBefore(plotgroupBg.node(), pgNode.childNodes[0]);\n        backgroundIds.push(subplot);\n      } else {\n        plotgroup.select('rect.bg').remove();\n        lowerDomains.push([xDomain, yDomain]);\n        if (!noNeedForBg) {\n          lowerBackgroundIDs.push(subplot);\n          backgroundIds.push(subplot);\n        }\n      }\n    }\n  }\n\n  // now create all the lower-layer backgrounds at once now that\n  // we have the list of subplots that need them\n  var lowerBackgrounds = fullLayout._bgLayer.selectAll('.bg').data(lowerBackgroundIDs);\n  lowerBackgrounds.enter().append('rect').classed('bg', true);\n  lowerBackgrounds.exit().remove();\n  lowerBackgrounds.each(function (subplot) {\n    fullLayout._plots[subplot].bg = d3.select(this);\n  });\n\n  // style all backgrounds\n  for (i = 0; i < backgroundIds.length; i++) {\n    plotinfo = fullLayout._plots[backgroundIds[i]];\n    xa = plotinfo.xaxis;\n    ya = plotinfo.yaxis;\n    if (plotinfo.bg && xa._offset !== undefined && ya._offset !== undefined) {\n      plotinfo.bg.call(Drawing.setRect, xa._offset - pad, ya._offset - pad, xa._length + 2 * pad, ya._length + 2 * pad).call(Color.fill, fullLayout.plot_bgcolor).style('stroke-width', 0);\n    }\n  }\n  if (!fullLayout._hasOnlyLargeSploms) {\n    for (subplot in fullLayout._plots) {\n      plotinfo = fullLayout._plots[subplot];\n      xa = plotinfo.xaxis;\n      ya = plotinfo.yaxis;\n\n      // Clip so that data only shows up on the plot area.\n      var clipId = plotinfo.clipId = 'clip' + fullLayout._uid + subplot + 'plot';\n      var plotClip = Lib.ensureSingleById(fullLayout._clips, 'clipPath', clipId, function (s) {\n        s.classed('plotclip', true).append('rect');\n      });\n      plotinfo.clipRect = plotClip.select('rect').attr({\n        width: xa._length,\n        height: ya._length\n      });\n      Drawing.setTranslate(plotinfo.plot, xa._offset, ya._offset);\n      var plotClipId;\n      var layerClipId;\n      if (plotinfo._hasClipOnAxisFalse) {\n        plotClipId = null;\n        layerClipId = clipId;\n      } else {\n        plotClipId = clipId;\n        layerClipId = null;\n      }\n      Drawing.setClipUrl(plotinfo.plot, plotClipId, gd);\n\n      // stash layer clipId value (null or same as clipId)\n      // to DRY up Drawing.setClipUrl calls on trace-module and trace layers\n      // downstream\n      plotinfo.layerClipId = layerClipId;\n    }\n  }\n  var xLinesXLeft, xLinesXRight, xLinesYBottom, xLinesYTop, leftYLineWidth, rightYLineWidth;\n  var yLinesYBottom, yLinesYTop, yLinesXLeft, yLinesXRight, connectYBottom, connectYTop;\n  var extraSubplot;\n  function xLinePath(y) {\n    return 'M' + xLinesXLeft + ',' + y + 'H' + xLinesXRight;\n  }\n  function xLinePathFree(y) {\n    return 'M' + xa._offset + ',' + y + 'h' + xa._length;\n  }\n  function yLinePath(x) {\n    return 'M' + x + ',' + yLinesYTop + 'V' + yLinesYBottom;\n  }\n  function yLinePathFree(x) {\n    if (ya._shift !== undefined) {\n      x += ya._shift;\n    }\n    return 'M' + x + ',' + ya._offset + 'v' + ya._length;\n  }\n  function mainPath(ax, pathFn, pathFnFree) {\n    if (!ax.showline || subplot !== ax._mainSubplot) return '';\n    if (!ax._anchorAxis) return pathFnFree(ax._mainLinePosition);\n    var out = pathFn(ax._mainLinePosition);\n    if (ax.mirror) out += pathFn(ax._mainMirrorPosition);\n    return out;\n  }\n  for (subplot in fullLayout._plots) {\n    plotinfo = fullLayout._plots[subplot];\n    xa = plotinfo.xaxis;\n    ya = plotinfo.yaxis;\n\n    /*\n     * x lines get longer where they meet y lines, to make a crisp corner.\n     * The x lines get the padding (margin.pad) plus the y line width to\n     * fill up the corner nicely. Free x lines are excluded - they always\n     * span exactly the data area of the plot\n     *\n     *  | XXXXX\n     *  | XXXXX\n     *  |\n     *  +------\n     *     x1\n     *    -----\n     *     x2\n     */\n    var xPath = 'M0,0';\n    if (shouldShowLinesOrTicks(xa, subplot)) {\n      leftYLineWidth = findCounterAxisLineWidth(xa, 'left', ya, axList);\n      xLinesXLeft = xa._offset - (leftYLineWidth ? pad + leftYLineWidth : 0);\n      rightYLineWidth = findCounterAxisLineWidth(xa, 'right', ya, axList);\n      xLinesXRight = xa._offset + xa._length + (rightYLineWidth ? pad + rightYLineWidth : 0);\n      xLinesYBottom = getLinePosition(xa, ya, 'bottom');\n      xLinesYTop = getLinePosition(xa, ya, 'top');\n\n      // save axis line positions for extra ticks to reference\n      // each subplot that gets ticks from \"allticks\" gets an entry:\n      //    [left or bottom, right or top]\n      extraSubplot = !xa._anchorAxis || subplot !== xa._mainSubplot;\n      if (extraSubplot && (xa.mirror === 'allticks' || xa.mirror === 'all')) {\n        xa._linepositions[subplot] = [xLinesYBottom, xLinesYTop];\n      }\n      xPath = mainPath(xa, xLinePath, xLinePathFree);\n      if (extraSubplot && xa.showline && (xa.mirror === 'all' || xa.mirror === 'allticks')) {\n        xPath += xLinePath(xLinesYBottom) + xLinePath(xLinesYTop);\n      }\n      plotinfo.xlines.style('stroke-width', xa._lw + 'px').call(Color.stroke, xa.showline ? xa.linecolor : 'rgba(0,0,0,0)');\n    }\n    plotinfo.xlines.attr('d', xPath);\n\n    /*\n     * y lines that meet x axes get longer only by margin.pad, because\n     * the x axes fill in the corner space. Free y axes, like free x axes,\n     * always span exactly the data area of the plot\n     *\n     *   |   | XXXX\n     * y2| y1| XXXX\n     *   |   | XXXX\n     *       |\n     *       +-----\n     */\n    var yPath = 'M0,0';\n    if (shouldShowLinesOrTicks(ya, subplot)) {\n      connectYBottom = findCounterAxisLineWidth(ya, 'bottom', xa, axList);\n      yLinesYBottom = ya._offset + ya._length + (connectYBottom ? pad : 0);\n      connectYTop = findCounterAxisLineWidth(ya, 'top', xa, axList);\n      yLinesYTop = ya._offset - (connectYTop ? pad : 0);\n      yLinesXLeft = getLinePosition(ya, xa, 'left');\n      yLinesXRight = getLinePosition(ya, xa, 'right');\n      extraSubplot = !ya._anchorAxis || subplot !== ya._mainSubplot;\n      if (extraSubplot && (ya.mirror === 'allticks' || ya.mirror === 'all')) {\n        ya._linepositions[subplot] = [yLinesXLeft, yLinesXRight];\n      }\n      yPath = mainPath(ya, yLinePath, yLinePathFree);\n      if (extraSubplot && ya.showline && (ya.mirror === 'all' || ya.mirror === 'allticks')) {\n        yPath += yLinePath(yLinesXLeft) + yLinePath(yLinesXRight);\n      }\n      plotinfo.ylines.style('stroke-width', ya._lw + 'px').call(Color.stroke, ya.showline ? ya.linecolor : 'rgba(0,0,0,0)');\n    }\n    plotinfo.ylines.attr('d', yPath);\n  }\n  Axes.makeClipPaths(gd);\n  return Plots.previousPromises(gd);\n}\nfunction shouldShowLinesOrTicks(ax, subplot) {\n  return (ax.ticks || ax.showline) && (subplot === ax._mainSubplot || ax.mirror === 'all' || ax.mirror === 'allticks');\n}\n\n/*\n * should we draw a line on counterAx at this side of ax?\n * It's assumed that counterAx is known to overlay the subplot we're working on\n * but it may not be its main axis.\n */\nfunction shouldShowLineThisSide(ax, side, counterAx) {\n  // does counterAx get a line at all?\n  if (!counterAx.showline || !counterAx._lw) return false;\n\n  // are we drawing *all* lines for counterAx?\n  if (counterAx.mirror === 'all' || counterAx.mirror === 'allticks') return true;\n  var anchorAx = counterAx._anchorAxis;\n\n  // is this a free axis? free axes can only have a subplot side-line with all(ticks)? mirroring\n  if (!anchorAx) return false;\n\n  // in order to handle cases where the user forgot to anchor this axis correctly\n  // (because its default anchor has the same domain on the relevant end)\n  // check whether the relevant position is the same.\n  var sideIndex = alignmentConstants.FROM_BL[side];\n  if (counterAx.side === side) {\n    return anchorAx.domain[sideIndex] === ax.domain[sideIndex];\n  }\n  return counterAx.mirror && anchorAx.domain[1 - sideIndex] === ax.domain[1 - sideIndex];\n}\n\n/*\n * Is there another axis intersecting `side` end of `ax`?\n * First look at `counterAx` (the axis for this subplot),\n * then at all other potential counteraxes on or overlaying this subplot.\n * Take the line width from the first one that has a line.\n */\nfunction findCounterAxisLineWidth(ax, side, counterAx, axList) {\n  if (shouldShowLineThisSide(ax, side, counterAx)) {\n    return counterAx._lw;\n  }\n  for (var i = 0; i < axList.length; i++) {\n    var axi = axList[i];\n    if (axi._mainAxis === counterAx._mainAxis && shouldShowLineThisSide(ax, side, axi)) {\n      return axi._lw;\n    }\n  }\n  return 0;\n}\nexports.drawMainTitle = function (gd) {\n  var title = gd._fullLayout.title;\n  var fullLayout = gd._fullLayout;\n  var textAnchor = getMainTitleTextAnchor(fullLayout);\n  var dy = getMainTitleDy(fullLayout);\n  var y = getMainTitleY(fullLayout, dy);\n  var x = getMainTitleX(fullLayout, textAnchor);\n  Titles.draw(gd, 'gtitle', {\n    propContainer: fullLayout,\n    propName: 'title.text',\n    placeholder: fullLayout._dfltTitle.plot,\n    attributes: {\n      x: x,\n      y: y,\n      'text-anchor': textAnchor,\n      dy: dy\n    }\n  });\n  if (title.text && title.automargin) {\n    var titleObj = d3.selectAll('.gtitle');\n    var titleHeight = Drawing.bBox(titleObj.node()).height;\n    var pushMargin = needsMarginPush(gd, title, titleHeight);\n    if (pushMargin > 0) {\n      applyTitleAutoMargin(gd, y, pushMargin, titleHeight);\n      // Re-position the title once we know where it needs to be\n      titleObj.attr({\n        x: x,\n        y: y,\n        'text-anchor': textAnchor,\n        dy: getMainTitleDyAdj(title.yanchor)\n      }).call(svgTextUtils.positionText, x, y);\n      var extraLines = (title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;\n      if (extraLines) {\n        var delta = alignmentConstants.LINE_SPACING * extraLines + alignmentConstants.MID_SHIFT;\n        if (title.y === 0) {\n          delta = -delta;\n        }\n        titleObj.selectAll('.line').each(function () {\n          var newDy = +this.getAttribute('dy').slice(0, -2) - delta + 'em';\n          this.setAttribute('dy', newDy);\n        });\n      }\n    }\n  }\n};\nfunction isOutsideContainer(gd, title, position, y, titleHeight) {\n  var plotHeight = title.yref === 'paper' ? gd._fullLayout._size.h : gd._fullLayout.height;\n  var yPosTop = Lib.isTopAnchor(title) ? y : y - titleHeight; // Standardize to the top of the title\n  var yPosRel = position === 'b' ? plotHeight - yPosTop : yPosTop; // Position relative to the top or bottom of plot\n  if (Lib.isTopAnchor(title) && position === 't' || Lib.isBottomAnchor(title) && position === 'b') {\n    return false;\n  } else {\n    return yPosRel < titleHeight;\n  }\n}\nfunction containerPushVal(position, titleY, titleYanchor, height, titleDepth) {\n  var push = 0;\n  if (titleYanchor === 'middle') {\n    push += titleDepth / 2;\n  }\n  if (position === 't') {\n    if (titleYanchor === 'top') {\n      push += titleDepth;\n    }\n    push += height - titleY * height;\n  } else {\n    if (titleYanchor === 'bottom') {\n      push += titleDepth;\n    }\n    push += titleY * height;\n  }\n  return push;\n}\nfunction needsMarginPush(gd, title, titleHeight) {\n  var titleY = title.y;\n  var titleYanchor = title.yanchor;\n  var position = titleY > 0.5 ? 't' : 'b';\n  var curMargin = gd._fullLayout.margin[position];\n  var pushMargin = 0;\n  if (title.yref === 'paper') {\n    pushMargin = titleHeight + title.pad.t + title.pad.b;\n  } else if (title.yref === 'container') {\n    pushMargin = containerPushVal(position, titleY, titleYanchor, gd._fullLayout.height, titleHeight) + title.pad.t + title.pad.b;\n  }\n  if (pushMargin > curMargin) {\n    return pushMargin;\n  }\n  return 0;\n}\nfunction applyTitleAutoMargin(gd, y, pushMargin, titleHeight) {\n  var titleID = 'title.automargin';\n  var title = gd._fullLayout.title;\n  var position = title.y > 0.5 ? 't' : 'b';\n  var push = {\n    x: title.x,\n    y: title.y,\n    t: 0,\n    b: 0\n  };\n  var reservedPush = {};\n  if (title.yref === 'paper' && isOutsideContainer(gd, title, position, y, titleHeight)) {\n    push[position] = pushMargin;\n  } else if (title.yref === 'container') {\n    reservedPush[position] = pushMargin;\n    gd._fullLayout._reservedMargin[titleID] = reservedPush;\n  }\n  Plots.allowAutoMargin(gd, titleID);\n  Plots.autoMargin(gd, titleID, push);\n}\nfunction getMainTitleX(fullLayout, textAnchor) {\n  var title = fullLayout.title;\n  var gs = fullLayout._size;\n  var hPadShift = 0;\n  if (textAnchor === SVG_TEXT_ANCHOR_START) {\n    hPadShift = title.pad.l;\n  } else if (textAnchor === SVG_TEXT_ANCHOR_END) {\n    hPadShift = -title.pad.r;\n  }\n  switch (title.xref) {\n    case 'paper':\n      return gs.l + gs.w * title.x + hPadShift;\n    case 'container':\n    default:\n      return fullLayout.width * title.x + hPadShift;\n  }\n}\nfunction getMainTitleY(fullLayout, dy) {\n  var title = fullLayout.title;\n  var gs = fullLayout._size;\n  var vPadShift = 0;\n  if (dy === '0em' || !dy) {\n    vPadShift = -title.pad.b;\n  } else if (dy === alignmentConstants.CAP_SHIFT + 'em') {\n    vPadShift = title.pad.t;\n  }\n  if (title.y === 'auto') {\n    return gs.t / 2;\n  } else {\n    switch (title.yref) {\n      case 'paper':\n        return gs.t + gs.h - gs.h * title.y + vPadShift;\n      case 'container':\n      default:\n        return fullLayout.height - fullLayout.height * title.y + vPadShift;\n    }\n  }\n}\nfunction getMainTitleDyAdj(yanchor) {\n  if (yanchor === 'top') {\n    return alignmentConstants.CAP_SHIFT + 0.3 + 'em';\n  } else if (yanchor === 'bottom') {\n    return '-0.3em';\n  } else {\n    return alignmentConstants.MID_SHIFT + 'em';\n  }\n}\nfunction getMainTitleTextAnchor(fullLayout) {\n  var title = fullLayout.title;\n  var textAnchor = SVG_TEXT_ANCHOR_MIDDLE;\n  if (Lib.isRightAnchor(title)) {\n    textAnchor = SVG_TEXT_ANCHOR_END;\n  } else if (Lib.isLeftAnchor(title)) {\n    textAnchor = SVG_TEXT_ANCHOR_START;\n  }\n  return textAnchor;\n}\nfunction getMainTitleDy(fullLayout) {\n  var title = fullLayout.title;\n  var dy = '0em';\n  if (Lib.isTopAnchor(title)) {\n    dy = alignmentConstants.CAP_SHIFT + 'em';\n  } else if (Lib.isMiddleAnchor(title)) {\n    dy = alignmentConstants.MID_SHIFT + 'em';\n  }\n  return dy;\n}\nexports.doTraceStyle = function (gd) {\n  var calcdata = gd.calcdata;\n  var editStyleCalls = [];\n  var i;\n  for (i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var cd0 = cd[0] || {};\n    var trace = cd0.trace || {};\n    var _module = trace._module || {};\n\n    // See if we need to do arraysToCalcdata\n    // call it regardless of what change we made, in case\n    // supplyDefaults brought in an array that was already\n    // in gd.data but not in gd._fullData previously\n    var arraysToCalcdata = _module.arraysToCalcdata;\n    if (arraysToCalcdata) arraysToCalcdata(cd, trace);\n    var editStyle = _module.editStyle;\n    if (editStyle) editStyleCalls.push({\n      fn: editStyle,\n      cd0: cd0\n    });\n  }\n  if (editStyleCalls.length) {\n    for (i = 0; i < editStyleCalls.length; i++) {\n      var edit = editStyleCalls[i];\n      edit.fn(gd, edit.cd0);\n    }\n    clearGlCanvases(gd);\n    exports.redrawReglTraces(gd);\n  }\n  Plots.style(gd);\n  Registry.getComponentMethod('legend', 'draw')(gd);\n  return Plots.previousPromises(gd);\n};\nexports.doColorBars = function (gd) {\n  Registry.getComponentMethod('colorbar', 'draw')(gd);\n  return Plots.previousPromises(gd);\n};\n\n// force plot() to redo the layout and replot with the modified layout\nexports.layoutReplot = function (gd) {\n  var layout = gd.layout;\n  gd.layout = undefined;\n  return Registry.call('_doPlot', gd, '', layout);\n};\nexports.doLegend = function (gd) {\n  Registry.getComponentMethod('legend', 'draw')(gd);\n  return Plots.previousPromises(gd);\n};\nexports.doTicksRelayout = function (gd) {\n  Axes.draw(gd, 'redraw');\n  if (gd._fullLayout._hasOnlyLargeSploms) {\n    Registry.subplotsRegistry.splom.updateGrid(gd);\n    clearGlCanvases(gd);\n    exports.redrawReglTraces(gd);\n  }\n  exports.drawMainTitle(gd);\n  return Plots.previousPromises(gd);\n};\nexports.doModeBar = function (gd) {\n  var fullLayout = gd._fullLayout;\n  ModeBar.manage(gd);\n  for (var i = 0; i < fullLayout._basePlotModules.length; i++) {\n    var updateFx = fullLayout._basePlotModules[i].updateFx;\n    if (updateFx) updateFx(gd);\n  }\n  return Plots.previousPromises(gd);\n};\nexports.doCamera = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var sceneIds = fullLayout._subplots.gl3d;\n  for (var i = 0; i < sceneIds.length; i++) {\n    var sceneLayout = fullLayout[sceneIds[i]];\n    var scene = sceneLayout._scene;\n    scene.setViewport(sceneLayout);\n  }\n};\nexports.drawData = function (gd) {\n  var fullLayout = gd._fullLayout;\n  clearGlCanvases(gd);\n\n  // loop over the base plot modules present on graph\n  var basePlotModules = fullLayout._basePlotModules;\n  for (var i = 0; i < basePlotModules.length; i++) {\n    basePlotModules[i].plot(gd);\n  }\n  exports.redrawReglTraces(gd);\n\n  // styling separate from drawing\n  Plots.style(gd);\n\n  // draw components that can be drawn on axes,\n  // and that do not push the margins\n  Registry.getComponentMethod('selections', 'draw')(gd);\n  Registry.getComponentMethod('shapes', 'draw')(gd);\n  Registry.getComponentMethod('annotations', 'draw')(gd);\n  Registry.getComponentMethod('images', 'draw')(gd);\n\n  // Mark the first render as complete\n  fullLayout._replotting = false;\n  return Plots.previousPromises(gd);\n};\n\n// Draw (or redraw) all regl-based traces in one go,\n// useful during drag and selection where buffers of targeted traces are updated,\n// but all traces need to be redrawn following clearGlCanvases.\n//\n// Note that _module.plot for regl trace does NOT draw things\n// on the canvas, they only update the buffers.\n// Drawing is perform here.\n//\n// TODO try adding per-subplot option using gl.SCISSOR_TEST for\n// non-overlaying, disjoint subplots.\n//\n// TODO try to include parcoords in here.\n// https://github.com/plotly/plotly.js/issues/3069\nexports.redrawReglTraces = function (gd) {\n  var fullLayout = gd._fullLayout;\n  if (fullLayout._has('regl')) {\n    var fullData = gd._fullData;\n    var cartesianIds = [];\n    var polarIds = [];\n    var i, sp;\n    if (fullLayout._hasOnlyLargeSploms) {\n      fullLayout._splomGrid.draw();\n    }\n\n    // N.B.\n    // - Loop over fullData (not _splomScenes) to preserve splom trace-to-trace ordering\n    // - Fill list if subplot ids (instead of fullLayout._subplots) to handle cases where all traces\n    //   of a given module are `visible !== true`\n    for (i = 0; i < fullData.length; i++) {\n      var trace = fullData[i];\n      if (trace.visible === true && trace._length !== 0) {\n        if (trace.type === 'splom') {\n          fullLayout._splomScenes[trace.uid].draw();\n        } else if (trace.type === 'scattergl') {\n          Lib.pushUnique(cartesianIds, trace.xaxis + trace.yaxis);\n        } else if (trace.type === 'scatterpolargl') {\n          Lib.pushUnique(polarIds, trace.subplot);\n        }\n      }\n    }\n    for (i = 0; i < cartesianIds.length; i++) {\n      sp = fullLayout._plots[cartesianIds[i]];\n      if (sp._scene) sp._scene.draw();\n    }\n    for (i = 0; i < polarIds.length; i++) {\n      sp = fullLayout[polarIds[i]]._subplot;\n      if (sp._scene) sp._scene.draw();\n    }\n  }\n};\nexports.doAutoRangeAndConstraints = function (gd) {\n  var axList = Axes.list(gd, '', true);\n  var ax;\n  var autoRangeDone = {};\n  for (var i = 0; i < axList.length; i++) {\n    ax = axList[i];\n    if (!autoRangeDone[ax._id]) {\n      autoRangeDone[ax._id] = 1;\n      cleanAxisConstraints(gd, ax);\n      doAutoRange(gd, ax);\n\n      // For matching axes, just propagate this autorange to the group.\n      // The extra arg to doAutoRange avoids recalculating the range,\n      // since doAutoRange by itself accounts for all matching axes. but\n      // there are other side-effects of doAutoRange that we still want.\n      var matchGroup = ax._matchGroup;\n      if (matchGroup) {\n        for (var id2 in matchGroup) {\n          var ax2 = Axes.getFromId(gd, id2);\n          doAutoRange(gd, ax2, ax.range);\n          autoRangeDone[id2] = 1;\n        }\n      }\n    }\n  }\n  enforceAxisConstraints(gd);\n};\n\n// An initial paint must be completed before these components can be\n// correctly sized and the whole plot re-margined. fullLayout._replotting must\n// be set to false before these will work properly.\nexports.finalDraw = function (gd) {\n  // TODO: rangesliders really belong in marginPushers but they need to be\n  // drawn after data - can we at least get the margin pushing part separated\n  // out and done earlier?\n  Registry.getComponentMethod('rangeslider', 'draw')(gd);\n  // TODO: rangeselector only needs to be here (in addition to drawMarginPushers)\n  // because the margins need to be fully determined before we can call\n  // autorange and update axis ranges (which rangeselector needs to know which\n  // button is active). Can we break out its automargin step from its draw step?\n  Registry.getComponentMethod('rangeselector', 'draw')(gd);\n};\nexports.drawMarginPushers = function (gd) {\n  Registry.getComponentMethod('legend', 'draw')(gd);\n  Registry.getComponentMethod('rangeselector', 'draw')(gd);\n  Registry.getComponentMethod('sliders', 'draw')(gd);\n  Registry.getComponentMethod('updatemenus', 'draw')(gd);\n  Registry.getComponentMethod('colorbar', 'draw')(gd);\n};","map":{"version":3,"names":["require","d3","Registry","Plots","Lib","svgTextUtils","clearGlCanvases","Color","Drawing","Titles","ModeBar","Axes","alignmentConstants","axisConstraints","enforceAxisConstraints","enforce","cleanAxisConstraints","clean","doAutoRange","SVG_TEXT_ANCHOR_START","SVG_TEXT_ANCHOR_MIDDLE","SVG_TEXT_ANCHOR_END","exports","layoutStyles","gd","syncOrAsync","doAutoMargin","lsInner","overlappingDomain","xDomain","yDomain","domains","i","length","existingX","existingY","fullLayout","_fullLayout","gs","_size","pad","p","axList","list","subplot","plotinfo","ax","xa","ya","_paperdiv","style","width","_context","responsive","autosize","_hasZeroWidth","layout","height","_hasZeroHeight","selectAll","call","setSize","setBackground","paper_bgcolor","drawMainTitle","manage","_has","previousPromises","getLinePosition","counterAx","side","lwHalf","_lw","_id","charAt","t","h","position","_offset","_length","l","w","_anchorAxis","_linepositions","crispRound","linewidth","_mainLinePosition","_mainMirrorPosition","mirror","OPPOSITE_SIDE","lowerBackgroundIDs","backgroundIds","lowerDomains","noNeedForBg","opacity","plot_bgcolor","_plots","mainplot","bg","remove","undefined","xaxis","domain","yaxis","plotgroup","pgNode","node","plotgroupBg","ensureSingle","insertBefore","childNodes","push","select","lowerBackgrounds","_bgLayer","data","enter","append","classed","exit","each","setRect","fill","_hasOnlyLargeSploms","clipId","_uid","plotClip","ensureSingleById","_clips","s","clipRect","attr","setTranslate","plot","plotClipId","layerClipId","_hasClipOnAxisFalse","setClipUrl","xLinesXLeft","xLinesXRight","xLinesYBottom","xLinesYTop","leftYLineWidth","rightYLineWidth","yLinesYBottom","yLinesYTop","yLinesXLeft","yLinesXRight","connectYBottom","connectYTop","extraSubplot","xLinePath","y","xLinePathFree","yLinePath","x","yLinePathFree","_shift","mainPath","pathFn","pathFnFree","showline","_mainSubplot","out","xPath","shouldShowLinesOrTicks","findCounterAxisLineWidth","xlines","stroke","linecolor","yPath","ylines","makeClipPaths","ticks","shouldShowLineThisSide","anchorAx","sideIndex","FROM_BL","axi","_mainAxis","title","textAnchor","getMainTitleTextAnchor","dy","getMainTitleDy","getMainTitleY","getMainTitleX","draw","propContainer","propName","placeholder","_dfltTitle","attributes","text","automargin","titleObj","titleHeight","bBox","pushMargin","needsMarginPush","applyTitleAutoMargin","getMainTitleDyAdj","yanchor","positionText","extraLines","match","BR_TAG_ALL","delta","LINE_SPACING","MID_SHIFT","newDy","getAttribute","slice","setAttribute","isOutsideContainer","plotHeight","yref","yPosTop","isTopAnchor","yPosRel","isBottomAnchor","containerPushVal","titleY","titleYanchor","titleDepth","curMargin","margin","b","titleID","reservedPush","_reservedMargin","allowAutoMargin","autoMargin","hPadShift","r","xref","vPadShift","CAP_SHIFT","isRightAnchor","isLeftAnchor","isMiddleAnchor","doTraceStyle","calcdata","editStyleCalls","cd","cd0","trace","_module","arraysToCalcdata","editStyle","fn","edit","redrawReglTraces","getComponentMethod","doColorBars","layoutReplot","doLegend","doTicksRelayout","subplotsRegistry","splom","updateGrid","doModeBar","_basePlotModules","updateFx","doCamera","sceneIds","_subplots","gl3d","sceneLayout","scene","_scene","setViewport","drawData","basePlotModules","_replotting","fullData","_fullData","cartesianIds","polarIds","sp","_splomGrid","visible","type","_splomScenes","uid","pushUnique","_subplot","doAutoRangeAndConstraints","autoRangeDone","matchGroup","_matchGroup","id2","ax2","getFromId","range","finalDraw","drawMarginPushers"],"sources":["/home/zhu/Documents/github/explorer_front/explorer_front_app/node_modules/plotly.js/src/plot_api/subroutines.js"],"sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Registry = require('../registry');\nvar Plots = require('../plots/plots');\n\nvar Lib = require('../lib');\nvar svgTextUtils = require('../lib/svg_text_utils');\nvar clearGlCanvases = require('../lib/clear_gl_canvases');\n\nvar Color = require('../components/color');\nvar Drawing = require('../components/drawing');\nvar Titles = require('../components/titles');\nvar ModeBar = require('../components/modebar');\n\nvar Axes = require('../plots/cartesian/axes');\nvar alignmentConstants = require('../constants/alignment');\nvar axisConstraints = require('../plots/cartesian/constraints');\nvar enforceAxisConstraints = axisConstraints.enforce;\nvar cleanAxisConstraints = axisConstraints.clean;\nvar doAutoRange = require('../plots/cartesian/autorange').doAutoRange;\n\nvar SVG_TEXT_ANCHOR_START = 'start';\nvar SVG_TEXT_ANCHOR_MIDDLE = 'middle';\nvar SVG_TEXT_ANCHOR_END = 'end';\n\nexports.layoutStyles = function(gd) {\n    return Lib.syncOrAsync([Plots.doAutoMargin, lsInner], gd);\n};\n\nfunction overlappingDomain(xDomain, yDomain, domains) {\n    for(var i = 0; i < domains.length; i++) {\n        var existingX = domains[i][0];\n        var existingY = domains[i][1];\n\n        if(existingX[0] >= xDomain[1] || existingX[1] <= xDomain[0]) {\n            continue;\n        }\n        if(existingY[0] < yDomain[1] && existingY[1] > yDomain[0]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction lsInner(gd) {\n    var fullLayout = gd._fullLayout;\n    var gs = fullLayout._size;\n    var pad = gs.p;\n    var axList = Axes.list(gd, '', true);\n    var i, subplot, plotinfo, ax, xa, ya;\n\n    fullLayout._paperdiv.style({\n        width: (gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroWidth && !gd.layout.width) ? '100%' : fullLayout.width + 'px',\n        height: (gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroHeight && !gd.layout.height) ? '100%' : fullLayout.height + 'px'\n    })\n    .selectAll('.main-svg')\n    .call(Drawing.setSize, fullLayout.width, fullLayout.height);\n    gd._context.setBackground(gd, fullLayout.paper_bgcolor);\n\n    exports.drawMainTitle(gd);\n    ModeBar.manage(gd);\n\n    // _has('cartesian') means SVG specifically, not GL2D - but GL2D\n    // can still get here because it makes some of the SVG structure\n    // for shared features like selections.\n    if(!fullLayout._has('cartesian')) {\n        return Plots.previousPromises(gd);\n    }\n\n    function getLinePosition(ax, counterAx, side) {\n        var lwHalf = ax._lw / 2;\n\n        if(ax._id.charAt(0) === 'x') {\n            if(!counterAx) return gs.t + gs.h * (1 - (ax.position || 0)) + (lwHalf % 1);\n            else if(side === 'top') return counterAx._offset - pad - lwHalf;\n            return counterAx._offset + counterAx._length + pad + lwHalf;\n        }\n\n        if(!counterAx) return gs.l + gs.w * (ax.position || 0) + (lwHalf % 1);\n        else if(side === 'right') return counterAx._offset + counterAx._length + pad + lwHalf;\n        return counterAx._offset - pad - lwHalf;\n    }\n\n    // some preparation of axis position info\n    for(i = 0; i < axList.length; i++) {\n        ax = axList[i];\n\n        var counterAx = ax._anchorAxis;\n\n        // clear axis line positions, to be set in the subplot loop below\n        ax._linepositions = {};\n\n        // stash crispRounded linewidth so we don't need to pass gd all over the place\n        ax._lw = Drawing.crispRound(gd, ax.linewidth, 1);\n\n        // figure out the main axis line and main mirror line position.\n        // it's easier to follow the logic if we handle these separately from\n        // ax._linepositions, which are only used by mirror=allticks\n        // for non-main-subplot ticks, and mirror=all(ticks)? for zero line\n        // hiding logic\n        ax._mainLinePosition = getLinePosition(ax, counterAx, ax.side);\n        ax._mainMirrorPosition = (ax.mirror && counterAx) ?\n            getLinePosition(ax, counterAx,\n                alignmentConstants.OPPOSITE_SIDE[ax.side]) : null;\n    }\n\n    // figure out which backgrounds we need to draw,\n    // and in which layers to put them\n    var lowerBackgroundIDs = [];\n    var backgroundIds = [];\n    var lowerDomains = [];\n    // no need to draw background when paper and plot color are the same color,\n    // activate mode just for large splom (which benefit the most from this\n    // optimization), but this could apply to all cartesian subplots.\n    var noNeedForBg = (\n        Color.opacity(fullLayout.paper_bgcolor) === 1 &&\n        Color.opacity(fullLayout.plot_bgcolor) === 1 &&\n        fullLayout.paper_bgcolor === fullLayout.plot_bgcolor\n    );\n\n    for(subplot in fullLayout._plots) {\n        plotinfo = fullLayout._plots[subplot];\n\n        if(plotinfo.mainplot) {\n            // mainplot is a reference to the main plot this one is overlaid on\n            // so if it exists, this is an overlaid plot and we don't need to\n            // give it its own background\n            if(plotinfo.bg) {\n                plotinfo.bg.remove();\n            }\n            plotinfo.bg = undefined;\n        } else {\n            var xDomain = plotinfo.xaxis.domain;\n            var yDomain = plotinfo.yaxis.domain;\n            var plotgroup = plotinfo.plotgroup;\n\n            if(overlappingDomain(xDomain, yDomain, lowerDomains)) {\n                var pgNode = plotgroup.node();\n                var plotgroupBg = plotinfo.bg = Lib.ensureSingle(plotgroup, 'rect', 'bg');\n                pgNode.insertBefore(plotgroupBg.node(), pgNode.childNodes[0]);\n                backgroundIds.push(subplot);\n            } else {\n                plotgroup.select('rect.bg').remove();\n                lowerDomains.push([xDomain, yDomain]);\n                if(!noNeedForBg) {\n                    lowerBackgroundIDs.push(subplot);\n                    backgroundIds.push(subplot);\n                }\n            }\n        }\n    }\n\n    // now create all the lower-layer backgrounds at once now that\n    // we have the list of subplots that need them\n    var lowerBackgrounds = fullLayout._bgLayer.selectAll('.bg')\n        .data(lowerBackgroundIDs);\n\n    lowerBackgrounds.enter().append('rect')\n        .classed('bg', true);\n\n    lowerBackgrounds.exit().remove();\n\n    lowerBackgrounds.each(function(subplot) {\n        fullLayout._plots[subplot].bg = d3.select(this);\n    });\n\n    // style all backgrounds\n    for(i = 0; i < backgroundIds.length; i++) {\n        plotinfo = fullLayout._plots[backgroundIds[i]];\n        xa = plotinfo.xaxis;\n        ya = plotinfo.yaxis;\n\n        if(plotinfo.bg && xa._offset !== undefined && ya._offset !== undefined) {\n            plotinfo.bg\n                .call(Drawing.setRect,\n                    xa._offset - pad, ya._offset - pad,\n                    xa._length + 2 * pad, ya._length + 2 * pad)\n                .call(Color.fill, fullLayout.plot_bgcolor)\n                .style('stroke-width', 0);\n        }\n    }\n\n    if(!fullLayout._hasOnlyLargeSploms) {\n        for(subplot in fullLayout._plots) {\n            plotinfo = fullLayout._plots[subplot];\n            xa = plotinfo.xaxis;\n            ya = plotinfo.yaxis;\n\n            // Clip so that data only shows up on the plot area.\n            var clipId = plotinfo.clipId = 'clip' + fullLayout._uid + subplot + 'plot';\n\n            var plotClip = Lib.ensureSingleById(fullLayout._clips, 'clipPath', clipId, function(s) {\n                s.classed('plotclip', true)\n                    .append('rect');\n            });\n\n            plotinfo.clipRect = plotClip.select('rect').attr({\n                width: xa._length,\n                height: ya._length\n            });\n\n            Drawing.setTranslate(plotinfo.plot, xa._offset, ya._offset);\n\n            var plotClipId;\n            var layerClipId;\n\n            if(plotinfo._hasClipOnAxisFalse) {\n                plotClipId = null;\n                layerClipId = clipId;\n            } else {\n                plotClipId = clipId;\n                layerClipId = null;\n            }\n\n            Drawing.setClipUrl(plotinfo.plot, plotClipId, gd);\n\n            // stash layer clipId value (null or same as clipId)\n            // to DRY up Drawing.setClipUrl calls on trace-module and trace layers\n            // downstream\n            plotinfo.layerClipId = layerClipId;\n        }\n    }\n\n    var xLinesXLeft, xLinesXRight, xLinesYBottom, xLinesYTop,\n        leftYLineWidth, rightYLineWidth;\n    var yLinesYBottom, yLinesYTop, yLinesXLeft, yLinesXRight,\n        connectYBottom, connectYTop;\n    var extraSubplot;\n\n    function xLinePath(y) {\n        return 'M' + xLinesXLeft + ',' + y + 'H' + xLinesXRight;\n    }\n\n    function xLinePathFree(y) {\n        return 'M' + xa._offset + ',' + y + 'h' + xa._length;\n    }\n\n    function yLinePath(x) {\n        return 'M' + x + ',' + yLinesYTop + 'V' + yLinesYBottom;\n    }\n\n    function yLinePathFree(x) {\n        if(ya._shift !== undefined) {\n            x += ya._shift;\n        }\n        return 'M' + x + ',' + ya._offset + 'v' + ya._length;\n    }\n\n    function mainPath(ax, pathFn, pathFnFree) {\n        if(!ax.showline || subplot !== ax._mainSubplot) return '';\n        if(!ax._anchorAxis) return pathFnFree(ax._mainLinePosition);\n        var out = pathFn(ax._mainLinePosition);\n        if(ax.mirror) out += pathFn(ax._mainMirrorPosition);\n        return out;\n    }\n\n    for(subplot in fullLayout._plots) {\n        plotinfo = fullLayout._plots[subplot];\n        xa = plotinfo.xaxis;\n        ya = plotinfo.yaxis;\n\n        /*\n         * x lines get longer where they meet y lines, to make a crisp corner.\n         * The x lines get the padding (margin.pad) plus the y line width to\n         * fill up the corner nicely. Free x lines are excluded - they always\n         * span exactly the data area of the plot\n         *\n         *  | XXXXX\n         *  | XXXXX\n         *  |\n         *  +------\n         *     x1\n         *    -----\n         *     x2\n         */\n        var xPath = 'M0,0';\n        if(shouldShowLinesOrTicks(xa, subplot)) {\n            leftYLineWidth = findCounterAxisLineWidth(xa, 'left', ya, axList);\n            xLinesXLeft = xa._offset - (leftYLineWidth ? (pad + leftYLineWidth) : 0);\n            rightYLineWidth = findCounterAxisLineWidth(xa, 'right', ya, axList);\n            xLinesXRight = xa._offset + xa._length + (rightYLineWidth ? (pad + rightYLineWidth) : 0);\n            xLinesYBottom = getLinePosition(xa, ya, 'bottom');\n            xLinesYTop = getLinePosition(xa, ya, 'top');\n\n            // save axis line positions for extra ticks to reference\n            // each subplot that gets ticks from \"allticks\" gets an entry:\n            //    [left or bottom, right or top]\n            extraSubplot = (!xa._anchorAxis || subplot !== xa._mainSubplot);\n            if(extraSubplot && (xa.mirror === 'allticks' || xa.mirror === 'all')) {\n                xa._linepositions[subplot] = [xLinesYBottom, xLinesYTop];\n            }\n\n            xPath = mainPath(xa, xLinePath, xLinePathFree);\n            if(extraSubplot && xa.showline && (xa.mirror === 'all' || xa.mirror === 'allticks')) {\n                xPath += xLinePath(xLinesYBottom) + xLinePath(xLinesYTop);\n            }\n\n            plotinfo.xlines\n                .style('stroke-width', xa._lw + 'px')\n                .call(Color.stroke, xa.showline ?\n                    xa.linecolor : 'rgba(0,0,0,0)');\n        }\n        plotinfo.xlines.attr('d', xPath);\n\n        /*\n         * y lines that meet x axes get longer only by margin.pad, because\n         * the x axes fill in the corner space. Free y axes, like free x axes,\n         * always span exactly the data area of the plot\n         *\n         *   |   | XXXX\n         * y2| y1| XXXX\n         *   |   | XXXX\n         *       |\n         *       +-----\n         */\n        var yPath = 'M0,0';\n        if(shouldShowLinesOrTicks(ya, subplot)) {\n            connectYBottom = findCounterAxisLineWidth(ya, 'bottom', xa, axList);\n            yLinesYBottom = ya._offset + ya._length + (connectYBottom ? pad : 0);\n            connectYTop = findCounterAxisLineWidth(ya, 'top', xa, axList);\n            yLinesYTop = ya._offset - (connectYTop ? pad : 0);\n            yLinesXLeft = getLinePosition(ya, xa, 'left');\n            yLinesXRight = getLinePosition(ya, xa, 'right');\n\n            extraSubplot = (!ya._anchorAxis || subplot !== ya._mainSubplot);\n            if(extraSubplot && (ya.mirror === 'allticks' || ya.mirror === 'all')) {\n                ya._linepositions[subplot] = [yLinesXLeft, yLinesXRight];\n            }\n\n            yPath = mainPath(ya, yLinePath, yLinePathFree);\n            if(extraSubplot && ya.showline && (ya.mirror === 'all' || ya.mirror === 'allticks')) {\n                yPath += yLinePath(yLinesXLeft) + yLinePath(yLinesXRight);\n            }\n\n            plotinfo.ylines\n                .style('stroke-width', ya._lw + 'px')\n                .call(Color.stroke, ya.showline ?\n                    ya.linecolor : 'rgba(0,0,0,0)');\n        }\n        plotinfo.ylines.attr('d', yPath);\n    }\n\n    Axes.makeClipPaths(gd);\n\n    return Plots.previousPromises(gd);\n}\n\nfunction shouldShowLinesOrTicks(ax, subplot) {\n    return (ax.ticks || ax.showline) &&\n        (subplot === ax._mainSubplot || ax.mirror === 'all' || ax.mirror === 'allticks');\n}\n\n/*\n * should we draw a line on counterAx at this side of ax?\n * It's assumed that counterAx is known to overlay the subplot we're working on\n * but it may not be its main axis.\n */\nfunction shouldShowLineThisSide(ax, side, counterAx) {\n    // does counterAx get a line at all?\n    if(!counterAx.showline || !counterAx._lw) return false;\n\n    // are we drawing *all* lines for counterAx?\n    if(counterAx.mirror === 'all' || counterAx.mirror === 'allticks') return true;\n\n    var anchorAx = counterAx._anchorAxis;\n\n    // is this a free axis? free axes can only have a subplot side-line with all(ticks)? mirroring\n    if(!anchorAx) return false;\n\n    // in order to handle cases where the user forgot to anchor this axis correctly\n    // (because its default anchor has the same domain on the relevant end)\n    // check whether the relevant position is the same.\n    var sideIndex = alignmentConstants.FROM_BL[side];\n    if(counterAx.side === side) {\n        return anchorAx.domain[sideIndex] === ax.domain[sideIndex];\n    }\n    return counterAx.mirror && anchorAx.domain[1 - sideIndex] === ax.domain[1 - sideIndex];\n}\n\n/*\n * Is there another axis intersecting `side` end of `ax`?\n * First look at `counterAx` (the axis for this subplot),\n * then at all other potential counteraxes on or overlaying this subplot.\n * Take the line width from the first one that has a line.\n */\nfunction findCounterAxisLineWidth(ax, side, counterAx, axList) {\n    if(shouldShowLineThisSide(ax, side, counterAx)) {\n        return counterAx._lw;\n    }\n    for(var i = 0; i < axList.length; i++) {\n        var axi = axList[i];\n        if(axi._mainAxis === counterAx._mainAxis && shouldShowLineThisSide(ax, side, axi)) {\n            return axi._lw;\n        }\n    }\n    return 0;\n}\n\nexports.drawMainTitle = function(gd) {\n    var title = gd._fullLayout.title;\n    var fullLayout = gd._fullLayout;\n    var textAnchor = getMainTitleTextAnchor(fullLayout);\n    var dy = getMainTitleDy(fullLayout);\n    var y = getMainTitleY(fullLayout, dy);\n    var x = getMainTitleX(fullLayout, textAnchor);\n\n    Titles.draw(gd, 'gtitle', {\n        propContainer: fullLayout,\n        propName: 'title.text',\n        placeholder: fullLayout._dfltTitle.plot,\n        attributes: ({\n            x: x,\n            y: y,\n            'text-anchor': textAnchor,\n            dy: dy\n        })\n    });\n\n    if(title.text && title.automargin) {\n        var titleObj = d3.selectAll('.gtitle');\n        var titleHeight = Drawing.bBox(titleObj.node()).height;\n        var pushMargin = needsMarginPush(gd, title, titleHeight);\n        if(pushMargin > 0) {\n            applyTitleAutoMargin(gd, y, pushMargin, titleHeight);\n            // Re-position the title once we know where it needs to be\n            titleObj.attr({\n                x: x,\n                y: y,\n                'text-anchor': textAnchor,\n                dy: getMainTitleDyAdj(title.yanchor)\n            }).call(svgTextUtils.positionText, x, y);\n\n            var extraLines = (title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;\n            if(extraLines) {\n                var delta = alignmentConstants.LINE_SPACING * extraLines + alignmentConstants.MID_SHIFT;\n                if(title.y === 0) {\n                    delta = -delta;\n                }\n\n                titleObj.selectAll('.line').each(function() {\n                    var newDy = +(this.getAttribute('dy')).slice(0, -2) - delta + 'em';\n                    this.setAttribute('dy', newDy);\n                });\n            }\n        }\n    }\n};\n\n\nfunction isOutsideContainer(gd, title, position, y, titleHeight) {\n    var plotHeight = title.yref === 'paper' ? gd._fullLayout._size.h : gd._fullLayout.height;\n    var yPosTop = Lib.isTopAnchor(title) ? y : y - titleHeight; // Standardize to the top of the title\n    var yPosRel = position === 'b' ? plotHeight - yPosTop : yPosTop; // Position relative to the top or bottom of plot\n    if((Lib.isTopAnchor(title) && position === 't') || Lib.isBottomAnchor(title) && position === 'b') {\n        return false;\n    } else {\n        return yPosRel < titleHeight;\n    }\n}\n\nfunction containerPushVal(position, titleY, titleYanchor, height, titleDepth) {\n    var push = 0;\n    if(titleYanchor === 'middle') {\n        push += titleDepth / 2;\n    }\n    if(position === 't') {\n        if(titleYanchor === 'top') {\n            push += titleDepth;\n        }\n        push += (height - titleY * height);\n    } else {\n        if(titleYanchor === 'bottom') {\n            push += titleDepth;\n        }\n        push += titleY * height;\n    }\n    return push;\n}\n\nfunction needsMarginPush(gd, title, titleHeight) {\n    var titleY = title.y;\n    var titleYanchor = title.yanchor;\n    var position = titleY > 0.5 ? 't' : 'b';\n    var curMargin = gd._fullLayout.margin[position];\n    var pushMargin = 0;\n    if(title.yref === 'paper') {\n        pushMargin = (\n            titleHeight +\n            title.pad.t +\n            title.pad.b\n        );\n    } else if(title.yref === 'container') {\n        pushMargin = (\n            containerPushVal(position, titleY, titleYanchor, gd._fullLayout.height, titleHeight) +\n            title.pad.t +\n            title.pad.b\n        );\n    }\n    if(pushMargin > curMargin) {\n        return pushMargin;\n    }\n    return 0;\n}\n\nfunction applyTitleAutoMargin(gd, y, pushMargin, titleHeight) {\n    var titleID = 'title.automargin';\n    var title = gd._fullLayout.title;\n    var position = title.y > 0.5 ? 't' : 'b';\n    var push = {\n        x: title.x,\n        y: title.y,\n        t: 0,\n        b: 0\n    };\n    var reservedPush = {};\n\n    if(title.yref === 'paper' && isOutsideContainer(gd, title, position, y, titleHeight)) {\n        push[position] = pushMargin;\n    } else if(title.yref === 'container') {\n        reservedPush[position] = pushMargin;\n        gd._fullLayout._reservedMargin[titleID] = reservedPush;\n    }\n    Plots.allowAutoMargin(gd, titleID);\n    Plots.autoMargin(gd, titleID, push);\n}\n\nfunction getMainTitleX(fullLayout, textAnchor) {\n    var title = fullLayout.title;\n    var gs = fullLayout._size;\n    var hPadShift = 0;\n\n    if(textAnchor === SVG_TEXT_ANCHOR_START) {\n        hPadShift = title.pad.l;\n    } else if(textAnchor === SVG_TEXT_ANCHOR_END) {\n        hPadShift = -title.pad.r;\n    }\n\n    switch(title.xref) {\n        case 'paper':\n            return gs.l + gs.w * title.x + hPadShift;\n        case 'container':\n        default:\n            return fullLayout.width * title.x + hPadShift;\n    }\n}\n\nfunction getMainTitleY(fullLayout, dy) {\n    var title = fullLayout.title;\n    var gs = fullLayout._size;\n    var vPadShift = 0;\n    if(dy === '0em' || !dy) {\n        vPadShift = -title.pad.b;\n    } else if(dy === alignmentConstants.CAP_SHIFT + 'em') {\n        vPadShift = title.pad.t;\n    }\n\n    if(title.y === 'auto') {\n        return gs.t / 2;\n    } else {\n        switch(title.yref) {\n            case 'paper':\n                return gs.t + gs.h - gs.h * title.y + vPadShift;\n            case 'container':\n            default:\n                return fullLayout.height - fullLayout.height * title.y + vPadShift;\n        }\n    }\n}\n\nfunction getMainTitleDyAdj(yanchor) {\n    if(yanchor === 'top') {\n        return alignmentConstants.CAP_SHIFT + 0.3 + 'em';\n    } else if(yanchor === 'bottom') {\n        return '-0.3em';\n    } else {\n        return alignmentConstants.MID_SHIFT + 'em';\n    }\n}\n\nfunction getMainTitleTextAnchor(fullLayout) {\n    var title = fullLayout.title;\n\n    var textAnchor = SVG_TEXT_ANCHOR_MIDDLE;\n    if(Lib.isRightAnchor(title)) {\n        textAnchor = SVG_TEXT_ANCHOR_END;\n    } else if(Lib.isLeftAnchor(title)) {\n        textAnchor = SVG_TEXT_ANCHOR_START;\n    }\n\n    return textAnchor;\n}\n\nfunction getMainTitleDy(fullLayout) {\n    var title = fullLayout.title;\n\n    var dy = '0em';\n    if(Lib.isTopAnchor(title)) {\n        dy = alignmentConstants.CAP_SHIFT + 'em';\n    } else if(Lib.isMiddleAnchor(title)) {\n        dy = alignmentConstants.MID_SHIFT + 'em';\n    }\n\n    return dy;\n}\n\nexports.doTraceStyle = function(gd) {\n    var calcdata = gd.calcdata;\n    var editStyleCalls = [];\n    var i;\n\n    for(i = 0; i < calcdata.length; i++) {\n        var cd = calcdata[i];\n        var cd0 = cd[0] || {};\n        var trace = cd0.trace || {};\n        var _module = trace._module || {};\n\n        // See if we need to do arraysToCalcdata\n        // call it regardless of what change we made, in case\n        // supplyDefaults brought in an array that was already\n        // in gd.data but not in gd._fullData previously\n        var arraysToCalcdata = _module.arraysToCalcdata;\n        if(arraysToCalcdata) arraysToCalcdata(cd, trace);\n\n        var editStyle = _module.editStyle;\n        if(editStyle) editStyleCalls.push({fn: editStyle, cd0: cd0});\n    }\n\n    if(editStyleCalls.length) {\n        for(i = 0; i < editStyleCalls.length; i++) {\n            var edit = editStyleCalls[i];\n            edit.fn(gd, edit.cd0);\n        }\n        clearGlCanvases(gd);\n        exports.redrawReglTraces(gd);\n    }\n\n    Plots.style(gd);\n    Registry.getComponentMethod('legend', 'draw')(gd);\n\n    return Plots.previousPromises(gd);\n};\n\nexports.doColorBars = function(gd) {\n    Registry.getComponentMethod('colorbar', 'draw')(gd);\n    return Plots.previousPromises(gd);\n};\n\n// force plot() to redo the layout and replot with the modified layout\nexports.layoutReplot = function(gd) {\n    var layout = gd.layout;\n    gd.layout = undefined;\n    return Registry.call('_doPlot', gd, '', layout);\n};\n\nexports.doLegend = function(gd) {\n    Registry.getComponentMethod('legend', 'draw')(gd);\n    return Plots.previousPromises(gd);\n};\n\nexports.doTicksRelayout = function(gd) {\n    Axes.draw(gd, 'redraw');\n\n    if(gd._fullLayout._hasOnlyLargeSploms) {\n        Registry.subplotsRegistry.splom.updateGrid(gd);\n        clearGlCanvases(gd);\n        exports.redrawReglTraces(gd);\n    }\n\n    exports.drawMainTitle(gd);\n    return Plots.previousPromises(gd);\n};\n\nexports.doModeBar = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    ModeBar.manage(gd);\n\n    for(var i = 0; i < fullLayout._basePlotModules.length; i++) {\n        var updateFx = fullLayout._basePlotModules[i].updateFx;\n        if(updateFx) updateFx(gd);\n    }\n\n    return Plots.previousPromises(gd);\n};\n\nexports.doCamera = function(gd) {\n    var fullLayout = gd._fullLayout;\n    var sceneIds = fullLayout._subplots.gl3d;\n\n    for(var i = 0; i < sceneIds.length; i++) {\n        var sceneLayout = fullLayout[sceneIds[i]];\n        var scene = sceneLayout._scene;\n\n        scene.setViewport(sceneLayout);\n    }\n};\n\nexports.drawData = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    clearGlCanvases(gd);\n\n    // loop over the base plot modules present on graph\n    var basePlotModules = fullLayout._basePlotModules;\n    for(var i = 0; i < basePlotModules.length; i++) {\n        basePlotModules[i].plot(gd);\n    }\n\n    exports.redrawReglTraces(gd);\n\n    // styling separate from drawing\n    Plots.style(gd);\n\n    // draw components that can be drawn on axes,\n    // and that do not push the margins\n    Registry.getComponentMethod('selections', 'draw')(gd);\n    Registry.getComponentMethod('shapes', 'draw')(gd);\n    Registry.getComponentMethod('annotations', 'draw')(gd);\n    Registry.getComponentMethod('images', 'draw')(gd);\n\n    // Mark the first render as complete\n    fullLayout._replotting = false;\n\n    return Plots.previousPromises(gd);\n};\n\n// Draw (or redraw) all regl-based traces in one go,\n// useful during drag and selection where buffers of targeted traces are updated,\n// but all traces need to be redrawn following clearGlCanvases.\n//\n// Note that _module.plot for regl trace does NOT draw things\n// on the canvas, they only update the buffers.\n// Drawing is perform here.\n//\n// TODO try adding per-subplot option using gl.SCISSOR_TEST for\n// non-overlaying, disjoint subplots.\n//\n// TODO try to include parcoords in here.\n// https://github.com/plotly/plotly.js/issues/3069\nexports.redrawReglTraces = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    if(fullLayout._has('regl')) {\n        var fullData = gd._fullData;\n        var cartesianIds = [];\n        var polarIds = [];\n        var i, sp;\n\n        if(fullLayout._hasOnlyLargeSploms) {\n            fullLayout._splomGrid.draw();\n        }\n\n        // N.B.\n        // - Loop over fullData (not _splomScenes) to preserve splom trace-to-trace ordering\n        // - Fill list if subplot ids (instead of fullLayout._subplots) to handle cases where all traces\n        //   of a given module are `visible !== true`\n        for(i = 0; i < fullData.length; i++) {\n            var trace = fullData[i];\n\n            if(trace.visible === true && trace._length !== 0) {\n                if(trace.type === 'splom') {\n                    fullLayout._splomScenes[trace.uid].draw();\n                } else if(trace.type === 'scattergl') {\n                    Lib.pushUnique(cartesianIds, trace.xaxis + trace.yaxis);\n                } else if(trace.type === 'scatterpolargl') {\n                    Lib.pushUnique(polarIds, trace.subplot);\n                }\n            }\n        }\n\n        for(i = 0; i < cartesianIds.length; i++) {\n            sp = fullLayout._plots[cartesianIds[i]];\n            if(sp._scene) sp._scene.draw();\n        }\n\n        for(i = 0; i < polarIds.length; i++) {\n            sp = fullLayout[polarIds[i]]._subplot;\n            if(sp._scene) sp._scene.draw();\n        }\n    }\n};\n\nexports.doAutoRangeAndConstraints = function(gd) {\n    var axList = Axes.list(gd, '', true);\n    var ax;\n\n    var autoRangeDone = {};\n\n    for(var i = 0; i < axList.length; i++) {\n        ax = axList[i];\n\n        if(!autoRangeDone[ax._id]) {\n            autoRangeDone[ax._id] = 1;\n            cleanAxisConstraints(gd, ax);\n            doAutoRange(gd, ax);\n\n            // For matching axes, just propagate this autorange to the group.\n            // The extra arg to doAutoRange avoids recalculating the range,\n            // since doAutoRange by itself accounts for all matching axes. but\n            // there are other side-effects of doAutoRange that we still want.\n            var matchGroup = ax._matchGroup;\n            if(matchGroup) {\n                for(var id2 in matchGroup) {\n                    var ax2 = Axes.getFromId(gd, id2);\n                    doAutoRange(gd, ax2, ax.range);\n                    autoRangeDone[id2] = 1;\n                }\n            }\n        }\n    }\n\n    enforceAxisConstraints(gd);\n};\n\n// An initial paint must be completed before these components can be\n// correctly sized and the whole plot re-margined. fullLayout._replotting must\n// be set to false before these will work properly.\nexports.finalDraw = function(gd) {\n    // TODO: rangesliders really belong in marginPushers but they need to be\n    // drawn after data - can we at least get the margin pushing part separated\n    // out and done earlier?\n    Registry.getComponentMethod('rangeslider', 'draw')(gd);\n    // TODO: rangeselector only needs to be here (in addition to drawMarginPushers)\n    // because the margins need to be fully determined before we can call\n    // autorange and update axis ranges (which rangeselector needs to know which\n    // button is active). Can we break out its automargin step from its draw step?\n    Registry.getComponentMethod('rangeselector', 'draw')(gd);\n};\n\nexports.drawMarginPushers = function(gd) {\n    Registry.getComponentMethod('legend', 'draw')(gd);\n    Registry.getComponentMethod('rangeselector', 'draw')(gd);\n    Registry.getComponentMethod('sliders', 'draw')(gd);\n    Registry.getComponentMethod('updatemenus', 'draw')(gd);\n    Registry.getComponentMethod('colorbar', 'draw')(gd);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}